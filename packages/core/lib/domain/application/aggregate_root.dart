// part of ednet_core;
//
// /// Represents an aggregate root in Domain-Driven Design.
// ///
// /// The [AggregateRoot] class serves as a transactional consistency boundary:
// /// - Contains a cluster of domain objects treated as a unit
// /// - Enforces invariants across all contained objects
// /// - Is the only object that outside references can directly hold
// /// - Handles commands and emits events
// ///
// /// This class extends the base [model.AggregateRoot] class to ensure
// /// compatibility with the core domain model while adding application-specific
// /// functionality like event tracking and command processing.
// ///
// /// Example usage:
// /// ```dart
// /// class Order extends AggregateRoot<Order> {
// ///   String customerId;
// ///   List<OrderLine> orderLines = [];
// ///   OrderStatus status = OrderStatus.created;
// ///
// ///   Order({required this.customerId});
// ///
// ///   bool processShipOrder(ShipOrderCommand command) {
// ///     if (status != OrderStatus.paid) {
// ///       return false;
// ///     }
// ///
// ///     status = OrderStatus.shipped;
// ///     applyChange(OrderShippedEvent(orderId: id.toString()));
// ///     return true;
// ///   }
// ///
// ///   @override
// ///   void apply(IDomainEvent event) {
// ///     if (event is OrderShippedEvent) {
// ///       status = OrderStatus.shipped;
// ///     }
// ///   }
// /// }
// /// ```
// abstract class AggregateRoot<T extends AggregateRoot<T>> extends model.AggregateRoot {
//   /// The list of uncommitted domain events generated by this aggregate.
//   final List<IDomainEvent> _uncommittedEvents = [];
//
//   /// A version number for optimistic concurrency control.
//   int version = 0;
//
//   /// The unique identifier for this aggregate instance.
//   /// This is typically set when the aggregate is created or reconstituted.
//   String get aggregateId => id?.toString() ?? '';
//
//   /// The type name of this aggregate, used for event sourcing.
//   /// By default, this is the class name, but can be overridden.
//   String get aggregateType => runtimeType.toString();
//
//   /// Processes a command and applies its effects to this aggregate.
//   ///
//   /// This method should:
//   /// 1. Validate the command
//   /// 2. Apply its effects
//   /// 3. Generate domain events
//   ///
//   /// Parameters:
//   /// - [command]: The command to process
//   ///
//   /// Returns:
//   /// True if the command was successfully processed, false otherwise
//   bool processCommand(ICommand command) {
//     return command.doIt();
//   }
//
//   /// Applies a change to the aggregate by creating and applying an event.
//   ///
//   /// This is the primary way to modify an aggregate. Instead of changing
//   /// state directly, you create an event and apply it. This ensures that
//   /// all state changes are captured as events.
//   ///
//   /// Parameters:
//   /// - [event]: The domain event representing the change
//   void applyChange(IDomainEvent event) {
//     // Set aggregate metadata on the event
//     _setEventMetadata(event);
//
//     // Apply the event to change the aggregate's state
//     apply(event);
//
//     // Track the event for later publishing
//     _uncommittedEvents.add(event);
//
//     // Increment version with each applied change
//     incrementVersion();
//   }
//
//   /// Adds a domain event to the list of uncommitted events without applying it.
//   ///
//   /// This method is used when you need to track an event but don't want to
//   /// apply its effects (for example, for events that don't change state).
//   ///
//   /// Parameters:
//   /// - [event]: The domain event to add
//   ///
//   /// @deprecated Use applyChange instead, which properly captures state changes
//   void addEvent(IDomainEvent event) {
//     _setEventMetadata(event);
//     _uncommittedEvents.add(event);
//   }
//
//   /// Gets the list of uncommitted domain events.
//   ///
//   /// Returns:
//   /// The list of uncommitted domain events
//   List<IDomainEvent> getUncommittedEvents() {
//     return List.unmodifiable(_uncommittedEvents);
//   }
//
//   /// Clears the list of uncommitted domain events.
//   ///
//   /// This should be called after the events have been processed.
//   void clearUncommittedEvents() {
//     _uncommittedEvents.clear();
//   }
//
//   /// Applies a domain event to this aggregate.
//   ///
//   /// This method should update the aggregate's state based on the event.
//   /// It must be implemented by subclasses to define how each event type
//   /// affects the aggregate's state.
//   ///
//   /// Parameters:
//   /// - [event]: The domain event to apply
//   void apply(IDomainEvent event);
//
//   /// Increments the version number of this aggregate.
//   ///
//   /// This should be called:
//   /// - When the aggregate is saved
//   /// - When reconstituting from event history
//   void incrementVersion() {
//     version++;
//   }
//
//   /// Loads the aggregate state from a series of domain events.
//   ///
//   /// This method is used to reconstitute an aggregate from its event history.
//   /// Each event is applied in sequence to rebuild the aggregate's state.
//   ///
//   /// Parameters:
//   /// - [events]: The list of domain events to apply
//   void loadFromHistory(List<IDomainEvent> events) {
//     for (final event in events) {
//       apply(event);
//       incrementVersion();
//     }
//   }
//
//   /// Sets metadata on the event related to this aggregate.
//   ///
//   /// Parameters:
//   /// - [event]: The event to update with metadata
//   void _setEventMetadata(IDomainEvent event) {
//     event.aggregateId = aggregateId;
//     event.aggregateType = aggregateType;
//     event.aggregateVersion = version;
//   }
//
//   /// Converts this aggregate's uncommitted events to the base Event type
//   /// for compatibility with the domain model.
//   ///
//   /// Returns:
//   /// A list of base Event objects
//   List<Event> toBaseEvents() {
//     return _uncommittedEvents.map((e) =>
//       Event(
//         name: e.name,
//         timestamp: e.timestamp,
//         id: e.id
//       )
//     ).toList();
//   }
// }