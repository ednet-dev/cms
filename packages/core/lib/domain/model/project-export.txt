PROJECT EXPORT

PROJECT STRUCTURE:

📁 aggregate_root
  📄 aggregate_root.dart
  📄 README.md
📁 commands
  📁 interfaces
    📄 i_basic_command.dart
    📄 i_command_reaction.dart
    📄 i_command.dart
    📄 i_entities_command.dart
    📄 i_entity_command.dart
    📄 i_past_command.dart
    📄 i_past.dart
    📄 i_source_of_command_reaction.dart
    📄 i_source_of_past_reaction.dart
    📄 i_transaction.dart
  📄 add_command.dart
  📄 past.dart
  📄 remove_command.dart
  📄 set_attribute_command.dart
  📄 set_child_command.dart
  📄 set_parent_command.dart
  📄 transaction.dart
📁 criteria
  📄 filter_criteria.dart
📁 entity
  📁 interfaces
    📄 i_entities.dart
    📄 i_entity.dart
    📄 i_id.dart
  📄 entities.dart
  📄 entity.dart
  📄 id.dart
  📄 README.md
📁 error
  📄 exceptions.dart
  📄 i_validation_exception.dart
  📄 validation_exception.dart
  📄 validation_exceptions.dart
📁 event
  📄 event.dart
📁 id
📁 policy
  📄 attribute_policy.dart
  📄 composite_policy.dart
  📄 entity_policies.dart
  📄 entity_policy_factory.dart
  📄 i_event_triggered_policy.dart
  📄 i_policy.dart
  📄 policy_engine.dart
  📄 policy_evaluation_tracer.dart
  📄 policy_evaluator.dart
  📄 policy_registry.dart
  📄 policy_scope.dart
  📄 policy_violation_exception.dart
  📄 relationship_policy.dart
  📄 time_based_policy.dart
  📄 todo.md
📁 primitives
  📄 dart_basic_types.dart
📁 queries
  📁 expressions
    📄 query_expression.dart
  📁 interfaces
    📄 i_query_handler.dart
    📄 i_query_result.dart
    📄 i_query.dart
  📁 query_handler
    📄 application_query_handler.dart
    📄 base_query_handler.dart
    📄 concept_query_handler.dart
    📄 default_concept_query_handler.dart
    📄 expression_query_handler.dart
    📄 query_dispatcher.dart
    📄 repository_query_handler.dart
  📄 concept_query.dart
  📄 entity_query_result.dart
  📄 expression_query.dart
  📄 query_builder.dart
  📄 query_dispatcher.dart
  📄 query_handler.dart
  📄 query_result.dart
  📄 query.dart
📁 session
📁 transfer
  📄 json.dart
📄 i_model_entries.dart
📄 model_entries.dart
📄 oid.dart
📄 reference.dart

FILES:

=== aggregate_root/README.md ===

# AggregateRoot in EDNet Core

## Overview

The AggregateRoot pattern in EDNet Core is an implementation of the Domain-Driven Design (DDD) tactical pattern that represents a cluster of domain objects treated as a single unit for data changes.

In DDD, an aggregate is a pattern that:
- Encapsulates related objects as a single unit
- Enforces invariants at the aggregate boundary
- Ensures transactional consistency 
- Provides a single entry point to interact with the cluster of objects

## Relationship to EDNet Core Concepts

In EDNet Core, the AggregateRoot pattern is connected to concepts where `entry = true`. This alignment makes sense because:

1. Entry concepts in EDNet Core are the roots of a conceptual hierarchy
2. They serve as access points into the domain model
3. They represent complete, independently meaningful business entities

## Implementation

The `AggregateRoot<T>` class extends the `Entity<T>` class and adds:

- Version tracking for optimistic concurrency control
- Validation of business invariants
- Command handling capabilities
- Event generation and application (for event sourcing)
- Relationship integrity enforcement
- Policy integration for event-driven workflows

## The Command-Event-Policy Cycle

One of the key architectural patterns enabled by the AggregateRoot is the command-event-policy cycle:

1. **Commands** are executed on AggregateRoots
2. AggregateRoots emit **Events** when state changes
3. Events trigger **Policies**
4. Policies generate new **Commands**
5. The cycle continues...

This creates a powerful reactive architecture where business processes can flow naturally through the domain model.

```
┌─────────────┐     executes     ┌──────────────────┐
│   Command   │─────────────────▶│   AggregateRoot  │
└─────────────┘                  └──────────────────┘
      ▲                                   │
      │                                   │
      │                                   │ emits
      │                                   │
      │                                   ▼
┌─────────────┐     triggers     ┌──────────────────┐
│   Policy    │◀────────────────│      Event       │
└─────────────┘                  └──────────────────┘
      │
      │ generates
      │
      ▼
┌─────────────┐
│   Command   │
└─────────────┘
```

## How AggregateRoot Addresses Validation Warnings

One of the key benefits of using the AggregateRoot pattern is that it can automatically manage required relationships between entities, addressing validation warnings like:

- `IzbornaLista.election parent is required`
- `IzbornaJedinica.election parent is required`
- `Glas.election parent is required`

These warnings occur because the entities in the model have required parent-child relationships that aren't always set when creating the entities individually. The AggregateRoot pattern ensures these relationships are properly established.

## Example Usage

A concrete implementation for managing elections might look like:

```dart
// Create an AggregateRoot
final electionAggregate = usDomain.createElectionAggregate(
  name: 'Election 2022',
  // ... other properties
);

// Add child entities through the aggregate
electionAggregate.addElectionList(democrats);
electionAggregate.addElectionList(republicans);
electionAggregate.addelectoralUnit(unit);
electionAggregate.registerVote(vote);

// Validate relationships
final validationErrors = electionAggregate.validateRelationships();
```

## Integration with Policies

AggregateRoots can now work with policies that trigger based on events:

```dart
// Define a policy that reacts to vote registration events
class VoteAuditPolicy implements IEventTriggeredPolicy {
  @override
  bool evaluate(Entity entity) {
    return entity is Election;
  }
  
  @override
  bool shouldTriggerOnEvent(Event event) {
    return event.name == 'VoteRegistered';
  }
  
  @override
  void executeActions(Entity entity, Event event) {
    print('Auditing vote from ${event.data['voterId']}');
  }
  
  @override
  List<ICommand> generateCommands(Entity entity, Event event) {
    return [
      RecordAuditLogCommand(
        entityId: entity.id,
        action: 'Vote',
        userId: event.data['voterId'],
        timestamp: DateTime.now()
      )
    ];
  }
}

// Register the policy with the aggregate
electionAggregate.registerPolicy(VoteAuditPolicy());

// Execute a command that will emit an event
electionAggregate.executeCommand(
  RegisterVoteCommand(voterId: 'citizen1', candidateId: 'candidate1')
);
// This will automatically:
// 1. Execute the command
// 2. Emit a VoteRegistered event
// 3. Trigger the VoteAuditPolicy
// 4. Generate and execute the RecordAuditLogCommand
```

## Philosophical and Practical Implications

### Consistency Boundary

The AggregateRoot defines a consistency boundary. Inside this boundary, business rules must be consistent. This is why many validation issues can be solved by applying this pattern - it ensures the right relationships exist.

### Entity Lifecycle Management

By managing the lifecycle of entities within the aggregate, the AggregateRoot helps prevent "orphaned" entities or invalid relationships.

### Transactional Consistency

All changes to entities within an aggregate should be committed in a single transaction, which helps maintain data integrity.

### Event-Driven Architecture

The integration with events and policies enables reactive, event-driven architectures where business processes can flow naturally through domain events.

## Integration with Event Sourcing

The AggregateRoot also supports event sourcing by providing methods to:
- Create events based on state changes
- Apply events to reconstruct the aggregate's state

This makes it suitable for systems that need to track the full history of domain changes.

## Best Practices

1. Keep aggregates small - only include entities that must change together
2. Identify proper aggregate boundaries based on business rules
3. Access entities in the aggregate only through the aggregate root
4. Use repository queries to load complete aggregates
5. Apply updates atomically to maintain consistency 

## Roadmap

### Short-term (Next 3 months)
- Enhance command handling capabilities with more structured command objects
- Improve integration with event sourcing by adding support for event replay
- Add more comprehensive validation for aggregate relationships
- Develop standard patterns for inter-aggregate communication

### Medium-term (6-12 months)
- Create a repository pattern specifically optimized for aggregates
- Add support for optimistic concurrency control with version checking
- Develop tooling for visualizing aggregate boundaries
- Add performance optimizations for large aggregate loads

### Long-term (Beyond 12 months)
- Support for distributed aggregates in microservice architectures
- Add AI-assisted aggregate boundary detection and optimization
- Create integration patterns with CQRS architecture
- Develop comprehensive monitoring and metrics for aggregate health 

========================================

=== aggregate_root/aggregate_root.dart ===

part of ednet_core;

/// AggregateRoot represents a DDD tactical pattern that serves as the entry point and consistency boundary
/// for a graph of objects that represent a cohesive domain concept.
///
/// An AggregateRoot is responsible for:
/// 1. Enforcing invariants across the entire aggregate
/// 2. Ensuring transactional consistency
/// 3. Protecting the internal state of the aggregate
/// 4. Providing a single entry point into the aggregate
/// 5. Being the only object within the aggregate that outside objects can reference
///
/// In ednet_core, an AggregateRoot is built on top of the existing Entity framework
/// and connected to concepts where entry = true.
abstract class AggregateRoot<T extends Entity<T>> extends Entity<T> {
  /// List of pending events that occurred but haven't been processed yet
  final List<dynamic> _pendingEvents = [];

  /// The domain session this aggregate operates within
  dynamic _session;

  /// Policy engine for handling policy enforcement and triggering
  dynamic _policyEngine;

  /// Stores the current state/version of the aggregate
  int _version = 0;

  /// Create a new aggregate root
  AggregateRoot() : super();

  /// Get the current version of the aggregate
  int get version => _version;

  /// Get the domain session this aggregate operates within
  dynamic get session => _session;

  /// Set the domain session for this aggregate
  set session(dynamic session) {
    _session = session;
    if (session != null && _policyEngine == null) {
      _policyEngine = PolicyEngine(session);
    }
  }

  /// Get the policy engine for this aggregate
  dynamic get policyEngine => _policyEngine;

  /// Set the policy engine for this aggregate
  set policyEngine(dynamic engine) {
    _policyEngine = engine;
  }

  /// Get pending events that need to be processed
  List<dynamic> get pendingEvents => List.unmodifiable(_pendingEvents);

  /// Marks all pending events as processed
  void markEventsAsProcessed() {
    _pendingEvents.clear();
  }

  /// Records a domain event and adds it to pending events
  /// Also triggers policy evaluation if a policy engine is attached
  dynamic recordEvent(
    String name,
    String description,
    List<String> handlers, {
    Map<String, dynamic> data = const {},
  }) {
    final event = Event(name, description, handlers, this, data);
    _pendingEvents.add(event);

    // Apply the event to update aggregate state
    applyEvent(event);

    // Trigger policies if available
    if (_policyEngine != null) {
      _triggerPoliciesFromEvent(event);
    }

    return event;
  }

  /// Checks if this Entity's concept is marked as an entry point
  bool get isAggregateRoot => concept.entry;

  /// Validates that this entity can function as an aggregate root
  void enforceAggregateRootInvariants() {
    if (!isAggregateRoot) {
      throw ValidationException(
        'entry',
        'AggregateRoot must be applied to entry concepts only.',
        entity: this,
      );
    }
  }

  /// Protects the aggregate by enforcing its business rules and invariants
  /// Should be overridden by concrete implementations to express domain-specific rules
  ValidationExceptions enforceBusinessInvariants() {
    final exceptions = ValidationExceptions();
    // Domain-specific business rules should be implemented here by subclasses
    // Example:
    // if (election.registeredVoters < election.minimumRequiredVoters) {
    //   exceptions.add(ValidationException(
    //     'registeredVoters',
    //     'Insufficient voters for election',
    //     entity: election
    //   ));
    // }
    return exceptions;
  }

  /// Executes a command against this aggregate root, ensuring all business rules are satisfied
  /// Returns a CommandResult indicating success or failure
  dynamic executeCommand(dynamic command) {
    // Validate that this is a proper aggregate root
    enforceAggregateRootInvariants();

    // Begin transaction
    try {
      // Execute the command using the existing command infrastructure
      bool executed = false;

      if (command.doIt != null && command.doIt is Function) {
        executed = command.doIt();
      }

      if (!executed) {
        return {"isSuccess": false, "errorMessage": "Command execution failed"};
      }

      // Validate business rules after command execution
      ValidationExceptions validationResults = enforceBusinessInvariants();

      if (!validationResults.isEmpty) {
        // If validation fails, try to undo the command
        if (command.undo != null && command.undo is Function) {
          command.undo();
        }
        return {
          "isSuccess": false,
          "errorMessage": validationResults.toString(),
        };
      }

      // If everything is valid, increment version and collect events
      _version++;

      // Add any command events to our pending events
      if (command.getEvents != null && command.getEvents is Function) {
        final commandEvents = command.getEvents();
        _pendingEvents.addAll(commandEvents);

        // Apply each event to update state
        for (var event in commandEvents) {
          applyEvent(event);
        }

        // Trigger policies based on each event
        if (_policyEngine != null) {
          for (var event in commandEvents) {
            _triggerPoliciesFromEvent(event);
          }
        }
      }

      // Return success with aggregate information
      return {
        "isSuccess": true,
        "data": {
          'id': oid.toString(),
          'version': _version,
          'pendingEvents': pendingEvents,
        },
      };
    } catch (e) {
      // If any domain rule is violated, reject the command
      return {
        "isSuccess": false,
        "errorMessage": "Command execution failed: ${e.toString()}",
      };
    }
  }

  /// Creates a transaction for this aggregate root
  Transaction beginTransaction(String name, DomainSession session) {
    this.session = session;
    return Transaction(name, session);
  }

  /// Registers a policy with this aggregate
  void registerPolicy(Policy policy) {
    if (_policyEngine == null) {
      _policyEngine = PolicyEngine(session);
    }
    _policyEngine.addPolicy(policy);
  }

  /// Trigger policies based on an event
  void _triggerPoliciesFromEvent(dynamic event) {
    if (_policyEngine == null) return;

    // First, evaluate which policies apply to this entity
    final applicablePolicies = _policyEngine.getApplicablePolicies(this);

    // For each applicable policy, check if it should trigger on this event
    for (var policy in applicablePolicies) {
      if (_isEventTriggeredPolicy(policy)) {
        dynamic dynamicPolicy = policy;
        if (dynamicPolicy.shouldTriggerOnEvent(event)) {
          // Policy is triggered by this event, execute its actions
          dynamicPolicy.executeActions(this, event);

          // If the policy generates commands, execute them
          final commands = dynamicPolicy.generateCommands(this, event);
          for (var command in commands) {
            if (command.doIt != null && command.doIt is Function) {
              // Link the command to this aggregate's session if not already set
              if (_isSessionAware(command) && session != null) {
                (command as dynamic).setSession(session);
              }

              // Execute the command
              executeCommand(command);
            }
          }
        }
      }
    }
  }

  /// Helper method to check if an object implements IEventTriggeredPolicy
  bool _isEventTriggeredPolicy(dynamic obj) {
    return obj != null &&
        obj.shouldTriggerOnEvent is Function &&
        obj.executeActions is Function &&
        obj.generateCommands is Function;
  }

  /// Helper method to check if an object implements SessionAware
  bool _isSessionAware(dynamic obj) {
    return obj != null && obj.setSession is Function;
  }

  /// Reconstructs the aggregate's state from its event history
  /// Used in event sourcing scenarios
  void rehydrateFromEventHistory(List<dynamic> eventHistory) {
    for (var event in eventHistory) {
      applyEvent(event);
      _version++;
    }
  }

  /// Applies a single event to update the aggregate's state
  /// Should be overridden by concrete implementations with domain-specific logic
  void applyEvent(dynamic event) {
    // Each specific AggregateRoot should override this with domain-specific logic
    // Example:
    // if (event.name == 'VoteCast') {
    //   _recordVote(event.data['voterId'], event.data['candidateId']);
    // } else if (event.name == 'CandidateRegistered') {
    //   _registerCandidate(event.data['candidateId'], event.data['candidateName']);
    // }
  }

  /// Ensures that domain relationships maintain the aggregate's consistency boundaries
  /// This helps address the validation warnings by maintaining proper domain relationships
  ValidationExceptions maintainRelationshipIntegrity() {
    final exceptions = ValidationExceptions();

    // To be implemented by concrete classes for their specific relationship rules
    // Example:
    // for (var ballot in ballots) {
    //   if (ballot.election != this) {
    //     try {
    //       // Use existing command infrastructure to set parent
    //       var setParentCmd = SetParentCommand(session, ballot, 'election', this);
    //       setParentCmd.doIt();
    //     } catch (e) {
    //       exceptions.add(ValidationException(
    //         'relationship',
    //         e.toString(),
    //         entity: ballot
    //       ));
    //     }
    //   }
    // }

    return exceptions;
  }

  /// Validates the entire aggregate against domain rules
  ValidationExceptions validateAggregate() {
    // Start with relationship integrity checks
    ValidationExceptions exceptions = maintainRelationshipIntegrity();

    // Then add business rule validations
    ValidationExceptions businessRuleExceptions = enforceBusinessInvariants();
    var iterator = businessRuleExceptions.iterator;
    while (iterator.moveNext()) {
      exceptions.add(iterator.current);
    }

    return exceptions;
  }

  /// Creates a graph representation of the entire aggregate
  @override
  Map<String, dynamic> toGraph() {
    final graph = super.toGraph();
    graph['isAggregateRoot'] = true;
    graph['version'] = _version;
    graph['pendingEventCount'] = _pendingEvents.length;
    return graph;
  }
}

/// Interface for objects that can be associated with a domain session
abstract class SessionAware {
  /// Sets the domain session for this object
  void setSession(dynamic session);
}

/// Base class for all domain events in the system
abstract class DomainEvent {
  final String aggregateId;
  final int version;
  final DateTime timestamp;

  DomainEvent(this.aggregateId, this.version) : timestamp = DateTime.now();

  Map<String, dynamic> toMap();
}

/// Base class for all commands in the system
abstract class Command {
  void execute(AggregateRoot aggregateRoot);
}

/// Exception specifically for domain validation failures
class DomainValidationException implements Exception {
  final String message;
  final Entity? entity;

  DomainValidationException(this.message, {this.entity});

  @override
  String toString() =>
      'Domain Validation Error: $message${entity != null ? ' in ${entity.runtimeType}' : ''}';
}


========================================

=== commands/add_command.dart ===

part of ednet_core;

class AddCommand extends IEntitiesCommand {
  AddCommand(DomainSession session, Entities entities, Entity entity)
      : super('add', session, entities, entity) {
    category = 'entity';
  }
}


========================================

=== commands/interfaces/i_basic_command.dart ===

part of ednet_core;

abstract class IBasicCommand implements ICommand {
  final String name;
  late String category;
  String state = 'started';
  String description;
  final DomainSession session;
  bool partOfTransaction = false;
  List<Event> events = [];

  IBasicCommand(
    this.name,
    this.session, {
    this.description = 'Basic command',
  });

  @override
  Event get successEvent => Event.SuccessEvent(name, description, [], null);

  @override
  Event get failureEvent => Event.FailureEvent(name, description, [], null);

  @override
  bool doIt();

  @override
  bool undo();

  @override
  bool redo();

  bool get started => state == 'started' ? true : false;

  @override
  bool get done => state == 'done' ? true : false;

  @override
  bool get undone => state == 'undone' ? true : false;

  @override
  bool get redone => state == 'redone' ? true : false;

  @override
  toString() => 'command: $name; state: $state -- description: $description';

  @override
  List<Event> getEvents() {
    return events;
  }

  void addEvent(Event event) {
    events.add(event);
  }

  display({String title = 'BasicCommand'}) {
    print('');
    print('======================================');
    print('$title                                ');
    print('======================================');
    print('');
    print('$this');
    print('');
  }
}


========================================

=== commands/interfaces/i_command.dart ===

part of ednet_core;

abstract class ICommand {
  String get name;

  String get category;

  String get description;

  Event get successEvent;

  Event get failureEvent;

  bool get done;

  bool get undone;

  bool get redone;

  bool doIt();

  bool undo();

  bool redo();

  List<Event> getEvents();
}


========================================

=== commands/interfaces/i_command_reaction.dart ===

part of ednet_core;

/// Interface defining a reaction to a command in the domain model.
///
/// This interface represents a component that can react to domain commands.
/// It is part of the command pattern implementation, allowing for decoupled
/// command handling and reaction logic.
///
/// Example usage:
/// ```dart
/// class UserCreationReaction implements ICommandReaction {
///   @override
///   void react(ICommand action) {
///     if (action is CreateUserCommand) {
///       // Handle user creation
///     }
///   }
/// }
/// ```
abstract class ICommandReaction {
  /// Reacts to a domain command.
  ///
  /// [action] is the command that triggered this reaction.
  /// Implementations should define specific behavior based on the command type.
  void react(ICommand action);
}


========================================

=== commands/interfaces/i_entities_command.dart ===

part of ednet_core;

abstract class IEntitiesCommand extends IBasicCommand {
  Entities entities;
  Entity entity;

  IEntitiesCommand(
      String name, DomainSession session, this.entities, this.entity)
      : super(name, session);

  @override
  bool doIt() {
    bool done = false;
    if (state == 'started') {
      if (name == 'add') {
        done = entities.add(entity);
      } else if (name == 'remove') {
        done = entities.remove(entity);
      } else {
        throw CommandException(
            'Allowed commands on entities for doit are add or remove.');
      }
      if (done) {
        state = 'done';
        if (!partOfTransaction) {
          session.past.add(this);
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return done;
  }

  @override
  bool undo() {
    bool undone = false;
    if (state == 'done' || state == 'redone') {
      if (name == 'add') {
        undone = entities.remove(entity);
      } else if (name == 'remove') {
        undone = entities.add(entity);
      } else {
        throw CommandException(
            'Allowed commands on entities for undo are add or remove.');
      }
      if (undone) {
        state = 'undone';
        if (!partOfTransaction) {
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return undone;
  }

  @override
  bool redo() {
    bool redone = false;
    if (state == 'undone') {
      if (name == 'add') {
        redone = entities.add(entity);
      } else if (name == 'remove') {
        redone = entities.remove(entity);
      } else {
        throw CommandException(
            'Allowed commands on entities for redo are add or remove.');
      }
      if (redone) {
        state = 'redone';
        if (!partOfTransaction) {
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return redone;
  }
}


========================================

=== commands/interfaces/i_entity_command.dart ===

part of ednet_core;

abstract class IEntityCommand extends IBasicCommand {
  Entity entity;
  String property;
  Object? before;
  Object after;

  IEntityCommand(DomainSession session, this.entity, this.property, this.after)
      : before = entity.getAttribute(property),
        super('set', session);

  @override
  bool doIt() {
    bool done = false;
    if (state == 'started') {
      if (name == 'set' && category == 'attribute') {
        done = entity.setAttribute(property, after);
      } else if (name == 'set' && category == 'parent') {
        done = entity.setParent(property, after as Entity);
      } else if (name == 'set' && category == 'child') {
        done = entity.setChild(property, after);
      } else {
        throw CommandException(
            'Allowed commands on entity for doIt are set attribute, parent or child.');
      }
      if (done) {
        state = 'done';
        if (!partOfTransaction) {
          session.past.add(this);
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return done;
  }

  @override
  bool undo() {
    bool undone = false;
    if (state == 'done' || state == 'redone') {
      if (name == 'set' && category == 'attribute') {
        undone = entity.setAttribute(property, before);
      } else if (name == 'set' && category == 'parent') {
        undone = entity.setParent(property, before as Entity);
      } else if (name == 'set' && category == 'child') {
        undone = entity.setChild(property, before!);
      } else {
        throw CommandException(
            'Allowed commands on entity for undo are set attribute, parent or child.');
      }
      if (undone) {
        state = 'undone';
        if (!partOfTransaction) {
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return undone;
  }

  @override
  bool redo() {
    bool redone = false;
    if (state == 'undone') {
      if (name == 'set' && category == 'attribute') {
        redone = entity.setAttribute(property, after);
      } else if (name == 'set' && category == 'parent') {
        redone = entity.setParent(property, after as Entity<Entity>);
      } else if (name == 'set' && category == 'child') {
        redone = entity.setChild(property, after);
      } else {
        throw CommandException(
            'Allowed commands on entity for redo are set attribute, parent or child.');
      }
      if (redone) {
        state = 'redone';
        if (!partOfTransaction) {
          session.domainModels.notifyCommandReactions(this);
        }
      }
    }
    return redone;
  }

  @override
  toString() => 'command: $name; category: $category; state: $state -- '
      'property: $property; before: $before; after: $after';
}


========================================

=== commands/interfaces/i_past.dart ===

part of ednet_core;

/// Interface defining a command history or undo/redo stack in the domain model.
///
/// This interface represents a component that maintains a history of commands
/// and provides functionality for executing, undoing, and redoing commands.
/// It extends [ISourceOfPastReaction] to allow other components to react to
/// changes in the command history.
///
/// Example usage:
/// ```dart
/// class CommandHistory implements IPast {
///   final List<ICommand> _commands = [];
///   int _currentIndex = -1;
///
///   @override
///   void add(ICommand command) {
///     _commands.add(command);
///     _currentIndex = _commands.length - 1;
///   }
///
///   @override
///   List<ICommand> get commands => List.unmodifiable(_commands);
///
///   @override
///   void clear() {
///     _commands.clear();
///     _currentIndex = -1;
///   }
///
///   @override
///   bool get empty => _commands.isEmpty;
///
///   @override
///   bool get undoLimit => _currentIndex < 0;
///
///   @override
///   bool get redoLimit => _currentIndex >= _commands.length - 1;
///
///   @override
///   bool doIt() {
///     if (redoLimit) return false;
///     _currentIndex++;
///     return _commands[_currentIndex].execute();
///   }
///
///   @override
///   bool undo() {
///     if (undoLimit) return false;
///     _currentIndex--;
///     return true;
///   }
///
///   @override
///   bool redo() {
///     if (redoLimit) return false;
///     _currentIndex++;
///     return _commands[_currentIndex].execute();
///   }
/// }
/// ```
abstract class IPast implements ISourceOfPastReaction {
  /// Adds a new command to the history.
  ///
  /// [command] is the command to be added to the history.
  /// This should be called before executing a new command.
  void add(ICommand command);

  /// Returns the list of all commands in the history.
  ///
  /// The returned list should be unmodifiable to prevent external changes
  /// to the command history.
  List<ICommand> get commands;

  /// Clears all commands from the history.
  ///
  /// This resets the command history to its initial state.
  void clear();

  /// Returns true if there are no commands in the history.
  bool get empty;

  /// Returns true if undo operation is not possible (at the beginning of history).
  bool get undoLimit;

  /// Returns true if redo operation is not possible (at the end of history).
  bool get redoLimit;

  /// Executes the next command in the history.
  ///
  /// Returns true if the command was executed successfully, false otherwise.
  bool doIt();

  /// Undoes the last executed command.
  ///
  /// Returns true if the command was undone successfully, false if at undo limit.
  bool undo();

  /// Redoes the last undone command.
  ///
  /// Returns true if the command was redone successfully, false if at redo limit.
  bool redo();
}


========================================

=== commands/interfaces/i_past_command.dart ===

part of ednet_core;

/// Interface defining a command that can react to undo/redo state changes.
///
/// This interface represents a command that needs to be aware of and respond to
/// changes in the undo/redo capabilities of the command history. It allows
/// commands to update their state or UI based on whether undo/redo operations
/// are available.
///
/// Example usage:
/// ```dart
/// class UndoableCommand implements IPastCommand {
///   bool _canUndo = false;
///   bool _canRedo = false;
///
///   @override
///   void reactCannotUndo() {
///     _canUndo = false;
///     updateUI();
///   }
///
///   @override
///   void reactCanUndo() {
///     _canUndo = true;
///     updateUI();
///   }
///
///   @override
///   void reactCanRedo() {
///     _canRedo = true;
///     updateUI();
///   }
///
///   @override
///   void reactCannotRedo() {
///     _canRedo = false;
///     updateUI();
///   }
///
///   void updateUI() {
///     // Update UI elements based on undo/redo state
///   }
/// }
/// ```
abstract class IPastCommand {
  /// Called when an undo operation becomes impossible.
  ///
  /// This method should be implemented to handle the case where the command
  /// history reaches its beginning and undo operations are no longer possible.
  void reactCannotUndo();

  /// Called when an undo operation becomes possible.
  ///
  /// This method should be implemented to handle the case where undo operations
  /// become available after previously being unavailable.
  void reactCanUndo();

  /// Called when a redo operation becomes possible.
  ///
  /// This method should be implemented to handle the case where redo operations
  /// become available after previously being unavailable.
  void reactCanRedo();

  /// Called when a redo operation becomes impossible.
  ///
  /// This method should be implemented to handle the case where the command
  /// history reaches its end and redo operations are no longer possible.
  void reactCannotRedo();
}


========================================

=== commands/interfaces/i_source_of_command_reaction.dart ===

part of ednet_core;

/// Interface defining a source of command reactions in the domain model.
///
/// This interface represents a component that can manage command reactions,
/// allowing other components to register for and receive notifications about
/// command executions. It implements the observer pattern for command handling.
///
/// Example usage:
/// ```dart
/// class CommandManager implements ISourceOfCommandReaction {
///   final List<ICommandReaction> _reactions = [];
///
///   @override
///   void startCommandReaction(ICommandReaction reaction) {
///     _reactions.add(reaction);
///   }
///
///   @override
///   void cancelCommandReaction(ICommandReaction reaction) {
///     _reactions.remove(reaction);
///   }
///
///   @override
///   void notifyCommandReactions(ICommand action) {
///     for (final reaction in _reactions) {
///       reaction.react(action);
///     }
///   }
/// }
/// ```
abstract class ISourceOfCommandReaction {
  /// Registers a new command reaction to receive notifications.
  ///
  /// [reaction] is the component that should receive command notifications.
  /// This method should be called when a component wants to start
  /// receiving command notifications.
  void startCommandReaction(ICommandReaction reaction);

  /// Unregisters a command reaction from receiving notifications.
  ///
  /// [reaction] is the component that should no longer receive command
  /// notifications. This method should be called when a component wants
  /// to stop receiving command notifications.
  void cancelCommandReaction(ICommandReaction reaction);

  /// Notifies all registered reactions about a command execution.
  ///
  /// [action] is the command that was executed and should trigger reactions.
  /// This method should be called after a command is executed to notify
  /// all registered reactions.
  void notifyCommandReactions(ICommand action);
}


========================================

=== commands/interfaces/i_source_of_past_reaction.dart ===

part of ednet_core;

/// Interface defining a source of past (undo/redo) reactions in the domain model.
///
/// This interface represents a component that can manage reactions to changes
/// in the undo/redo state of the command history. It allows other components
/// to register for and receive notifications about changes in the ability to
/// perform undo and redo operations.
///
/// Example usage:
/// ```dart
/// class UndoRedoManager implements ISourceOfPastReaction {
///   final List<IPastCommand> _reactions = [];
///
///   @override
///   void startPastReaction(IPastCommand reaction) {
///     _reactions.add(reaction);
///   }
///
///   @override
///   void cancelPastReaction(IPastCommand reaction) {
///     _reactions.remove(reaction);
///   }
///
///   @override
///   void notifyCannotUndo() {
///     for (final reaction in _reactions) {
///       reaction.reactCannotUndo();
///     }
///   }
///
///   @override
///   void notifyCanUndo() {
///     for (final reaction in _reactions) {
///       reaction.reactCanUndo();
///     }
///   }
///
///   @override
///   void notifyCanRedo() {
///     for (final reaction in _reactions) {
///       reaction.reactCanRedo();
///     }
///   }
///
///   @override
///   void notifyCannotRedo() {
///     for (final reaction in _reactions) {
///       reaction.reactCannotRedo();
///     }
///   }
/// }
/// ```
abstract class ISourceOfPastReaction {
  /// Registers a new past reaction to receive undo/redo state notifications.
  ///
  /// [reaction] is the component that should receive undo/redo state notifications.
  /// This method should be called when a component wants to start receiving
  /// notifications about changes in undo/redo capabilities.
  void startPastReaction(IPastCommand reaction);

  /// Unregisters a past reaction from receiving undo/redo state notifications.
  ///
  /// [reaction] is the component that should no longer receive undo/redo state
  /// notifications. This method should be called when a component wants to stop
  /// receiving notifications about changes in undo/redo capabilities.
  void cancelPastReaction(IPastCommand reaction);

  /// Notifies all registered reactions that undo operations are no longer possible.
  ///
  /// This method should be called when the command history reaches its beginning
  /// and undo operations become impossible.
  void notifyCannotUndo();

  /// Notifies all registered reactions that undo operations are now possible.
  ///
  /// This method should be called when undo operations become available after
  /// previously being unavailable.
  void notifyCanUndo();

  /// Notifies all registered reactions that redo operations are now possible.
  ///
  /// This method should be called when redo operations become available after
  /// previously being unavailable.
  void notifyCanRedo();

  /// Notifies all registered reactions that redo operations are no longer possible.
  ///
  /// This method should be called when the command history reaches its end
  /// and redo operations become impossible.
  void notifyCannotRedo();
}


========================================

=== commands/interfaces/i_transaction.dart ===

part of ednet_core;

abstract class ITransaction extends ICommand {
  void add(ICommand command);

  IPast get past;
}


========================================

=== commands/past.dart ===

part of ednet_core;

/// A concrete implementation of [IPast] that manages a history of commands.
///
/// This class provides functionality for executing, undoing, and redoing commands
/// while maintaining a cursor position in the command history. It also manages
/// reactions to changes in undo/redo capabilities.
///
/// Example usage:
/// ```dart
/// final past = Past(
///   commands: [command1, command2],
///   pastReactions: [reaction1, reaction2],
/// );
///
/// // Execute a command
/// past.add(newCommand);
/// past.doIt();
///
/// // Undo the last command
/// past.undo();
///
/// // Redo the undone command
/// past.redo();
/// ```
class Past implements IPast {
  /// The current position in the command history.
  int cursor = 0;

  /// The list of commands in the history.
  @override
  List<IBasicCommand> commands;

  /// The list of reactions to changes in undo/redo capabilities.
  List<IPastCommand> pastReactions;

  /// Creates a new [Past] instance.
  ///
  /// [commands] is an optional list of initial commands.
  /// [pastReactions] is an optional list of initial reactions.
  Past({
    commands,
    pastReactions,
  })  : commands = commands ?? [],
        pastReactions = pastReactions ?? [];

  /// Returns true if there are no commands in the history.
  @override
  bool get empty => commands.isEmpty;

  /// Returns true if undo operation is not possible (at the beginning of history).
  @override
  bool get undoLimit => empty || cursor == 0;

  /// Returns true if redo operation is not possible (at the end of history).
  @override
  bool get redoLimit => empty || cursor == commands.length;

  /// Adds a new command to the history.
  ///
  /// [action] is the command to be added. Any commands after the current cursor
  /// position will be removed before adding the new command.
  @override
  void add(ICommand action) {
    _removeRightOfCursor();
    commands.add(action as IBasicCommand);
    _moveCursorForward();
  }

  /// Removes all commands after the current cursor position.
  void _removeRightOfCursor() {
    for (int i = commands.length - 1; i >= cursor; i--) {
      commands.removeRange(i, i + 1);
    }
  }

  /// Notifies all registered reactions about changes in undo/redo capabilities.
  void _notifyUndoRedo() {
    if (undoLimit) {
      notifyCannotUndo();
    } else {
      notifyCanUndo();
    }
    if (redoLimit) {
      notifyCannotRedo();
    } else {
      notifyCanRedo();
    }
  }

  /// Moves the cursor forward and notifies reactions.
  void _moveCursorForward() {
    cursor++;
    _notifyUndoRedo();
  }

  /// Moves the cursor backward and notifies reactions.
  void _moveCursorBackward() {
    if (cursor > 0) {
      cursor--;
    }
    _notifyUndoRedo();
  }

  /// Clears all commands from the history and resets the cursor.
  @override
  void clear() {
    cursor = 0;
    commands.clear();
    _notifyUndoRedo();
  }

  /// Executes the command at the current cursor position.
  ///
  /// Returns true if the command was executed successfully, false otherwise.
  @override
  bool doIt() {
    bool done = false;
    if (!empty) {
      IBasicCommand action = commands[cursor];
      done = action.doIt();
      _moveCursorForward();
    }
    return done;
  }

  /// Undoes the command at the current cursor position.
  ///
  /// Returns true if the command was undone successfully, false otherwise.
  @override
  bool undo() {
    bool undone = false;
    if (!empty) {
      _moveCursorBackward();
      IBasicCommand action = commands[cursor];
      undone = action.undo();
    }
    return undone;
  }

  /// Redoes the command at the current cursor position.
  ///
  /// Returns true if the command was redone successfully, false otherwise.
  @override
  bool redo() {
    bool redone = false;
    if (!empty && !redoLimit) {
      IBasicCommand action = commands[cursor];
      redone = action.redo();
      _moveCursorForward();
    }
    return redone;
  }

  /// Executes all commands from the beginning of the history.
  ///
  /// Returns true if all commands were executed successfully, false otherwise.
  bool doAll() {
    bool allDone = true;
    cursor = 0;
    while (cursor < commands.length) {
      if (!doIt()) {
        allDone = false;
      }
    }
    return allDone;
  }

  /// Undoes all commands from the current position to the beginning.
  ///
  /// Returns true if all commands were undone successfully, false otherwise.
  bool undoAll() {
    bool allUndone = true;
    while (cursor > 0) {
      if (!undo()) {
        allUndone = false;
      }
    }
    return allUndone;
  }

  /// Redoes all commands from the current position to the end.
  ///
  /// Returns true if all commands were redone successfully, false otherwise.
  bool redoAll() {
    bool allRedone = true;
    cursor = 0;
    while (cursor < commands.length) {
      if (!redo()) {
        allRedone = false;
      }
    }
    return allRedone;
  }

  /// Registers a new past reaction to receive undo/redo state notifications.
  @override
  void startPastReaction(IPastCommand reaction) {
    pastReactions.add(reaction);
  }

  /// Unregisters a past reaction from receiving undo/redo state notifications.
  @override
  void cancelPastReaction(IPastCommand reaction) {
    pastReactions.remove(reaction);
  }

  /// Notifies all registered reactions that undo operations are no longer possible.
  @override
  void notifyCannotUndo() {
    for (IPastCommand reaction in pastReactions) {
      reaction.reactCannotUndo();
    }
  }

  /// Notifies all registered reactions that undo operations are now possible.
  @override
  void notifyCanUndo() {
    for (IPastCommand reaction in pastReactions) {
      reaction.reactCanUndo();
    }
  }

  /// Notifies all registered reactions that redo operations are now possible.
  @override
  void notifyCanRedo() {
    for (IPastCommand reaction in pastReactions) {
      reaction.reactCanRedo();
    }
  }

  /// Notifies all registered reactions that redo operations are no longer possible.
  @override
  void notifyCannotRedo() {
    for (IPastCommand reaction in pastReactions) {
      reaction.reactCannotRedo();
    }
  }

  /// Displays the current state of the command history.
  ///
  /// [title] is an optional title for the display output.
  void display([String title = 'Past Commands']) {
    print('');
    print('======================================');
    print('$title                                ');
    print('======================================');
    print('');
    print('cursor: $cursor');
    for (IBasicCommand command in commands) {
      command.display();
    }
    print('');
  }
}


========================================

=== commands/remove_command.dart ===

part of ednet_core;

class RemoveCommand extends IEntitiesCommand {
  RemoveCommand(DomainSession session, Entities entities, Entity entity)
      : super('remove', session, entities, entity) {
    category = 'entity';
  }
}


========================================

=== commands/set_attribute_command.dart ===

part of ednet_core;

class SetAttributeCommand extends IEntityCommand {
  SetAttributeCommand(
      DomainSession session, Entity entity, String property, Object after)
      : super(session, entity, property, after) {
    category = 'attribute';
  }
}


========================================

=== commands/set_child_command.dart ===

part of ednet_core;

class SetChildCommand extends IEntityCommand {
  SetChildCommand(
      DomainSession session, Entity entity, String property, Object after)
      : super(session, entity, property, after) {
    category = 'child';
  }
}


========================================

=== commands/set_parent_command.dart ===

part of ednet_core;

class SetParentCommand extends IEntityCommand {
  SetParentCommand(
      DomainSession session, Entity entity, String property, Object after)
      : super(session, entity, property, after) {
    category = 'parent';
  }
}


========================================

=== commands/transaction.dart ===

part of ednet_core;

class Transaction extends IBasicCommand implements ITransaction {
  final Past _commands;

  Transaction(String name, DomainSession session)
      : _commands = Past(),
        super(name, session);

  @override
  Past get past => _commands;

  @override
  void add(command) {
    _commands.add(command);
    (command as IBasicCommand).partOfTransaction = true;
  }

  @override
  bool doIt() {
    bool done = false;
    if (state == 'started') {
      done = _commands.doAll();
      if (done) {
        state = 'done';
        session.past.add(this);
        session.domainModels.notifyCommandReactions(this);
      } else {
        _commands.undoAll();
      }
    }
    return done;
  }

  @override
  bool undo() {
    bool undone = false;
    if (state == 'done' || state == 'redone') {
      undone = _commands.undoAll();
      if (undone) {
        state = 'undone';
        session.domainModels.notifyCommandReactions(this);
      } else {
        _commands.doAll();
      }
    }
    return undone;
  }

  @override
  bool redo() {
    bool redone = false;
    if (state == 'undone') {
      redone = _commands.redoAll();
      if (redone) {
        state = 'redone';
        session.domainModels.notifyCommandReactions(this);
      } else {
        _commands.undoAll();
      }
    }
    return redone;
  }
}


========================================

=== criteria/filter_criteria.dart ===

// part of ednet_core;
//
// /// Represents a filter criterion for querying domain entities.
// ///
// /// The [FilterCriteria] class provides a structured way to define filtering
// /// conditions for repositories and queries. It supports:
// /// - Attribute filtering based on comparison operators
// /// - Type-safe value comparisons
// /// - Extensible operator set
// /// - Integration with the repository and query system
// ///
// /// This class implements [model.ValueObject] for serialization compatibility
// /// and forms a foundation for the application layer's more sophisticated
// /// criteria system.
// ///
// /// Example usage:
// /// ```dart
// /// final criteria = FilterCriteria(
// ///   attribute: 'price',
// ///   operator: FilterOperator.lessThan,
// ///   value: 100.0,
// /// );
// ///
// /// repository.findByCriteria(criteria);
// /// ```
// class FilterCriteria implements model.ValueObject {
//   /// The attribute name to filter on.
//   final String attribute;
//
//   /// The comparison operator to use.
//   final String operator;
//
//   /// The value to compare against.
//   final dynamic value;
//
//   /// Creates a new filter criterion.
//   ///
//   /// [attribute] is the name of the attribute to filter on.
//   /// [operator] is the comparison operator to use.
//   /// [value] is the value to compare against.
//   FilterCriteria({
//     required this.attribute,
//     required this.operator,
//     required this.value,
//   });
//
//   /// Converts this filter criterion to a JSON representation.
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'attribute': attribute,
//       'operator': operator,
//       'value': value is model.ValueObject ? (value as model.ValueObject).toJson() : value,
//     };
//   }
//
//   /// Creates a filter criterion from its JSON representation.
//   static FilterCriteria fromJson(Map<String, dynamic> json) {
//     return FilterCriteria(
//       attribute: json['attribute'],
//       operator: json['operator'],
//       value: json['value'],
//     );
//   }
//
//   /// Applies this filter criterion to a collection of entities.
//   ///
//   /// This method filters a collection based on this criterion.
//   ///
//   /// [entities] is the collection to filter.
//   /// Returns a filtered collection of entities.
//   Iterable<Entity> apply(Iterable<Entity> entities) {
//     switch (operator) {
//       case FilterOperator.equals:
//         return entities.where((e) => e.getAttribute(attribute) == value);
//       case FilterOperator.notEquals:
//         return entities.where((e) => e.getAttribute(attribute) != value);
//       case FilterOperator.greaterThan:
//         return entities.where((e) {
//           var attrValue = e.getAttribute(attribute);
//           if (attrValue is Comparable && value is Comparable) {
//             return attrValue.compareTo(value) > 0;
//           }
//           return false;
//         });
//       case FilterOperator.lessThan:
//         return entities.where((e) {
//           var attrValue = e.getAttribute(attribute);
//           if (attrValue is Comparable && value is Comparable) {
//             return attrValue.compareTo(value) < 0;
//           }
//           return false;
//         });
//       case FilterOperator.contains:
//         return entities.where((e) {
//           var attrValue = e.getAttribute(attribute);
//           if (attrValue is String && value is String) {
//             return attrValue.contains(value);
//           }
//           return false;
//         });
//       default:
//         throw ArgumentError('Unsupported operator: $operator');
//     }
//   }
// }
//
// /// Defines standard filter operators for [FilterCriteria].
// ///
// /// This class provides constants for commonly used filter operators
// /// to ensure consistency across the framework.
// class FilterOperator {
//   /// Equals comparison (==)
//   static const String equals = 'equals';
//
//   /// Not equals comparison (!=)
//   static const String notEquals = 'notEquals';
//
//   /// Greater than comparison (>)
//   static const String greaterThan = 'greaterThan';
//
//   /// Less than comparison (<)
//   static const String lessThan = 'lessThan';
//
//   /// Contains comparison (String.contains)
//   static const String contains = 'contains';
//
//   /// Starts with comparison (String.startsWith)
//   static const String startsWith = 'startsWith';
//
//   /// Ends with comparison (String.endsWith)
//   static const String endsWith = 'endsWith';
// }
//
// /// Combines multiple [FilterCriteria] into a composite filter.
// ///
// /// The [CompositeCriteria] class allows combining multiple criteria
// /// using logical operators (AND, OR) to create complex filtering conditions.
// ///
// /// Example usage:
// /// ```dart
// /// final priceCriteria = FilterCriteria(
// ///   attribute: 'price',
// ///   operator: FilterOperator.lessThan,
// ///   value: 100.0,
// /// );
// ///
// /// final categoryCriteria = FilterCriteria(
// ///   attribute: 'category',
// ///   operator: FilterOperator.equals,
// ///   value: 'electronics',
// /// );
// ///
// /// final criteria = CompositeCriteria(
// ///   criteria: [priceCriteria, categoryCriteria],
// ///   operator: LogicalOperator.and,
// /// );
// /// ```
// class CompositeCriteria implements model.ValueObject {
//   /// The list of criteria to combine.
//   final List<FilterCriteria> criteria;
//
//   /// The logical operator to use for combining criteria.
//   final String operator;
//
//   /// Creates a new composite criteria.
//   ///
//   /// [criteria] is the list of criteria to combine.
//   /// [operator] is the logical operator to use.
//   CompositeCriteria({
//     required this.criteria,
//     required this.operator,
//   });
//
//   /// Converts this composite criteria to a JSON representation.
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'criteria': criteria.map((c) => c.toJson()).toList(),
//       'operator': operator,
//     };
//   }
//
//   /// Creates a composite criteria from its JSON representation.
//   static CompositeCriteria fromJson(Map<String, dynamic> json) {
//     return CompositeCriteria(
//       criteria: (json['criteria'] as List)
//           .map((c) => FilterCriteria.fromJson(c))
//           .toList(),
//       operator: json['operator'],
//     );
//   }
//
//   /// Applies this composite criteria to a collection of entities.
//   ///
//   /// This method filters a collection based on all criteria combined
//   /// using the specified logical operator.
//   ///
//   /// [entities] is the collection to filter.
//   /// Returns a filtered collection of entities.
//   Iterable<Entity> apply(Iterable<Entity> entities) {
//     if (criteria.isEmpty) {
//       return entities;
//     }
//
//     // Apply the first criterion
//     var result = criteria.first.apply(entities);
//
//     // Apply the rest of the criteria
//     for (var i = 1; i < criteria.length; i++) {
//       var nextResult = criteria[i].apply(entities);
//
//       if (operator == LogicalOperator.and) {
//         // Intersection
//         result = result.where((e) => nextResult.contains(e));
//       } else if (operator == LogicalOperator.or) {
//         // Union
//         result = {...result, ...nextResult};
//       }
//     }
//
//     return result;
//   }
// }
//
// /// Defines standard logical operators for [CompositeCriteria].
// ///
// /// This class provides constants for logical operators used to
// /// combine multiple filter criteria.
// class LogicalOperator {
//   /// Logical AND (&&)
//   static const String and = 'and';
//
//   /// Logical OR (||)
//   static const String or = 'or';
// }


========================================

=== entity/README.md ===

# **Entity Architecture in EDNet Core**

## **Overview**

The `Entity` class in EDNet Core serves as the cornerstone of the framework's **domain modeling capabilities**, enabling developers to define and interact with domain objects in a structured and reusable manner. This document provides a detailed explanation of the `Entity` class, its integration with `Concept`, and examples demonstrating how the architecture supports complex modeling requirements.

---

## **Key Features**

1. **Dynamic Attributes and Relationships**
    - Support for runtime attributes (`_attributeMap`) and structured relationships like **parents**, **children**, and **internal children**.

2. **Concept-Driven Behavior**
    - Tightly integrated with the `Concept` class, defining the schema, attributes, and relationships.

3. **Lifecycle Management**
    - Tracks key timestamps (`whenAdded`, `whenSet`, `whenRemoved`) for entity lifecycle events.

4. **Policy Evaluation**
    - Enforces business rules and validations using **pre-defined policies**.

5. **Serialization Support**
    - Includes methods for **JSON serialization**, graph representation, and deserialization.

6. **Undo/Redo and Transactions**
    - Integration with commands allows seamless undo/redo operations.

---

## **Internal Structure**

### **Attributes**

- Stored in `_attributeMap`.
- Managed dynamically based on the associated `Concept`.

```dart
Map<String, Object?> _attributeMap = <String, Object?>{};
```

### **Relationships**

- **Parents**: References to parent entities, managed through `_parentMap` and `_referenceMap`.
- **Children**: Collections of child entities, stored in `_childMap`.
- **Internal Children**: Subset of children managed internally.

```dart
Map<String, Object?> _parentMap = <String, Object?>{};
Map<String, Object?> _childMap = <String, Object?>{};
Map<String, Object?> _internalChildMap = <String, Object?>{};
```

### **Policy Enforcement**

The `PolicyEvaluator` ensures that entities adhere to rules defined at both entity and model levels.

```dart
PolicyEvaluationResult evaluatePolicies({String? policyKey}) {
  return _policyEvaluator.evaluate(this, policyKey: policyKey);
}
```

---

## **Integration with Concept**

Entities are **runtime instances** of a `Concept`. The `Concept` defines:
- **Attributes**: What properties an entity can have.
- **Relationships**: Parent-child and sibling structures.
- **Policies**: Validation rules.

### Example:

```dart
final concept = Concept(model, 'Citizen');
concept.attributes.add(Attribute(concept, 'name'));
concept.attributes.add(Attribute(concept, 'age'));

final citizen = Entity();
citizen.concept = concept;
citizen.setAttribute('name', 'John Doe');
citizen.setAttribute('age', 30);
```

---

## **Examples**

### **1. Basic Entity Creation**

Define and initialize an entity dynamically:

```dart
final concept = Concept(model, 'Product');
concept.attributes.add(Attribute(concept, 'name'));
concept.attributes.add(Attribute(concept, 'price'));

final product = Entity();
product.concept = concept;

product.setAttribute('name', 'Laptop');
product.setAttribute('price', 1200.00);

print(product.toString());
// Output: {Product: {oid: 12345, code: null, name: Laptop, price: 1200.00}}
```

---

### **2. Parent-Child Relationships**

Establish and manage hierarchical relationships.

```dart
final parentConcept = Concept(model, 'Category');
final childConcept = Concept(model, 'Item');

final category = Entity();
category.concept = parentConcept;
category.setAttribute('name', 'Electronics');

final item = Entity();
item.concept = childConcept;
item.setAttribute('name', 'Smartphone');

// Link child to parent
item.setParent('category', category);

print(item.getParent('category').toString());
// Output: {Category: {oid: 67890, code: null, name: Electronics}}
```

---

### **3. Policy Enforcement**

Ensure entities adhere to business rules.

```dart
final concept = Concept(model, 'User');
concept.attributes.add(Attribute(concept, 'email', type: 'String', required: true));

final user = Entity();
user.concept = concept;

try {
  user.setAttribute('email', null); // Will throw an exception
} catch (e) {
  print(e); // Output: User.email cannot be null.
}
```

---

### **4. Serialization and Deserialization**

Save and restore entity state using JSON.

#### Serialization:

```dart
final json = product.toJson();
print(json);
// Output: {"oid":"12345","code":null,"name":"Laptop","price":1200.00}
```

#### Deserialization:

```dart
final restoredProduct = Entity();
restoredProduct.concept = concept;
restoredProduct.fromJson(json);

print(restoredProduct.toString());
// Output: {Product: {oid: 12345, code: null, name: Laptop, price: 1200.00}}
```

---

### **5. Undo/Redo Operations**

Integrate with commands for undoable actions.

```dart
final session = DomainSession();
final addCommand = AddCommand(session, entities, product);

addCommand.doIt();  // Add the product
addCommand.undo();  // Undo the addition
addCommand.redo();  // Redo the addition
```

---

## **Advanced Modeling Scenarios**

### **Composite Relationships**

```dart
final departmentConcept = Concept(model, 'Department');
final employeeConcept = Concept(model, 'Employee');

// Define entities
final department = Entity();
department.concept = departmentConcept;
department.setAttribute('name', 'HR');

final employee = Entity();
employee.concept = employeeConcept;
employee.setAttribute('name', 'Alice');

// Link employee to department
employee.setParent('department', department);

// Serialize composite structure
print(department.toJson());
```

### **Entity Copying**

Deep copy entities with attributes and relationships.

```dart
final copiedProduct = product.copy();
print(copiedProduct.toString());
```

---

## **Conclusion**

The `Entity` class provides a versatile and extensible foundation for defining and managing domain models. Its integration with `Concept` enables a structured, policy-driven approach to entity management, making it ideal for complex domain-driven design (DDD) scenarios.

For further details on the framework's capabilities, refer to the [EDNet Core Documentation](https://github.com/ednet-dev).

========================================

=== entity/entities.dart ===

part of ednet_core;

/// A collection of domain entities that implements the [IEntities] interface.
///
/// The [Entities] class manages a collection of domain entities of type [E], where [E] extends [Entity<E>].
/// It provides functionality for:
/// - Adding, removing, and updating entities
/// - Validating entities against domain rules
/// - Managing entity relationships and references
/// - Serializing/deserializing entities to/from JSON
/// - Applying domain policies and validations
///
/// The class maintains several internal maps for efficient entity lookup:
/// - [_oidEntityMap]: Maps OID timestamps to entities
/// - [_codeEntityMap]: Maps entity codes to entities
/// - [_idEntityMap]: Maps entity IDs to entities
///
/// Example usage:
/// ```dart
/// final entities = Entities<Product>();
/// entities.concept = productConcept;
///
/// final product = Product();
/// product.name = 'Laptop';
/// entities.add(product);
/// ```
class Entities<E extends Entity<E>> implements IEntities<E> {
  /// The [Concept] that defines the metadata for this collection.
  /// If null, operations will throw [ConceptException].
  Concept? _concept;

  /// The underlying list of entities.
  var _entityList = <E>[];

  /// Maps OID timestamps to entities for fast lookup.
  final _oidEntityMap = <int, E>{};

  /// Maps entity codes to entities for fast lookup.
  final _codeEntityMap = <String, E>{};

  /// Maps entity IDs to entities for fast lookup.
  final _idEntityMap = <String, E>{};

  /// Creates a new empty collection of entities.
  Entities();

  /// Accumulates validation exceptions during entity operations.
  @override
  ValidationExceptions exceptions = ValidationExceptions();

  /// Reference to the source collection if this is a derived collection.
  @override
  Entities<E>? source;

  /// Minimum cardinality constraint (default: '0').
  String minC = '0';

  /// Maximum cardinality constraint (default: 'N' for unlimited).
  String maxC = 'N';

  /// Whether to perform pre-validation checks.
  bool pre = false;

  /// Whether to perform post-validation checks.
  bool post = false;

  /// Whether changes should propagate to the source collection.
  bool propagateToSource = false;

  /// Random number generator for entity selection.
  var randomGen = Random();

  /// Creates a new empty collection with the same concept as this one.
  Entities<E> newEntities() {
    var entities = Entities<E>();
    entities.concept = _concept!;
    return entities;
  }

  /// Sets the [concept] for this collection and initializes validation flags.
  set concept(Concept concept) {
    _concept = concept;
    pre = true;
    post = true;
    propagateToSource = true;
  }

  /// Creates a new entity instance with the same concept as this collection.
  Entity<E> newEntity() {
    var conceptEntity = Entity<E>();
    conceptEntity.concept = _concept!;
    return conceptEntity;
  }

  /// Gets the [concept] for this collection.
  /// Throws [ConceptException] if not set.
  @override
  Concept get concept {
    if (_concept == null) {
      throw ConceptException("Concept not set");
    }

    return _concept!;
  }

  /// Returns the first entity in the collection.
  @override
  E get first => _entityList.first;

  /// Whether the collection is empty.
  @override
  bool get isEmpty => _entityList.isEmpty;

  /// Whether the collection has at least one entity.
  @override
  bool get isNotEmpty => _entityList.isNotEmpty;

  /// Returns an iterator over the entities.
  @override
  Iterator<E> get iterator => _entityList.iterator;

  /// Returns the last entity in the collection.
  @override
  E get last => _entityList.last;

  /// Returns the number of entities in the collection.
  @override
  int get length => _entityList.length;

  /// Alias for [length] for convenience.
  int get count => length;

  /// Returns the single entity in the collection.
  /// Throws [StateError] if collection is empty or has multiple entities.
  @override
  E get single => _entityList.single;

  /// Returns the entity at the given [index].
  ///
  /// This operator enables array-like access to entities:
  /// ```dart
  /// domain = domains[0];
  /// model = domain.models[1];
  /// concept = model.concepts[2];
  /// ```
  E operator [](int index) => _entityList[index];

  /// Returns true if any entity satisfies the predicate [f].
  @override
  bool any(bool Function(E entity) f) => _entityList.any(f);

  /// Checks if the collection contains the given entity.
  /// Compares entities by their OID.
  @override
  bool contains(Object? entity) {
    if (entity == null || !(entity is E) || _oidEntityMap.isEmpty) {
      return false;
    }

    E? element = _oidEntityMap[(entity as E).oid.timeStamp];
    if (element == null) {
      return false;
    }

    return entity == element;
  }

  /// Returns the entity at the given [index].
  @override
  E elementAt(int index) => _entityList.elementAt(index);

  /// Alias for [elementAt].
  E at(int index) => elementAt(index);

  /// Returns true if all entities satisfy the predicate [f].
  @override
  bool every(bool Function(E entity) f) => _entityList.every(f);

  /// Expands each entity into multiple elements using [toElements].
  @override
  Iterable<T> expand<T>(Iterable<T> Function(E element) toElements) =>
      _entityList.expand(toElements);

  /// Returns the first entity that satisfies the predicate [f].
  /// If no entity satisfies [f], returns the result of [orElse] if provided.
  @override
  E firstWhere(bool Function(E entity) f, {E Function()? orElse}) =>
      _entityList.firstWhere(f);

  /// Reduces the collection to a single value using [combine].
  @override
  T fold<T>(T initialValue, T Function(T previousValue, E element) combine) =>
      _entityList.fold(initialValue, combine);

  /// Applies [action] to each entity.
  @override
  void forEach(void Function(E element) action) => _entityList.forEach(action);

  /// Joins the string representations of entities with [separator].
  @override
  String join([String separator = '']) => _entityList.join(separator);

  /// Returns the last entity that satisfies the predicate [f].
  /// If no entity satisfies [f], returns the result of [orElse] if provided.
  @override
  E lastWhere(bool Function(E entity) f, {E Function()? orElse}) =>
      _entityList.lastWhere(f);

  /// Maps each entity to a new value using [f].
  @override
  Iterable<T> map<T>(T Function(E) f) => _entityList.map(f);

  /// Reduces the collection to a single entity using [combine].
  @override
  E reduce(E Function(E value, E entity) combine) =>
      _entityList.reduce(combine);

  /// Returns the single entity that satisfies the predicate [f].
  /// If no entity or multiple entities satisfy [f], returns the result of [orElse] if provided.
  @override
  E singleWhere(bool Function(E entity) f, {E Function()? orElse}) =>
      _entityList.singleWhere(f);

  /// Returns all entities except the first [n].
  @override
  Iterable<E> skip(int n) => _entityList.skip(n);

  /// Returns all entities after the first one that doesn't satisfy [f].
  @override
  Iterable<E> skipWhile(bool Function(E entity) f) => _entityList.skipWhile(f);

  /// Returns the first [n] entities.
  @override
  Iterable<E> take(int n) => _entityList.take(n);

  /// Returns all entities up to but not including the first one that doesn't satisfy [f].
  @override
  Iterable<E> takeWhile(bool Function(E entity) f) => _entityList.takeWhile(f);

  /// Returns a list containing all entities.
  @override
  List<E> toList({bool growable = true}) => _entityList.toList(growable: true);

  /// Returns a set containing all entities.
  @override
  Set<E> toSet() => _entityList.toSet();

  /// Returns all entities that satisfy the predicate [f].
  @override
  Iterable<E> where(bool Function(E entity) f) => _entityList.where(f);

  /// Sets the internal list of entities.
  /// Used for Polymer compatibility.
  set internalList(List<E> observableList) {
    _entityList = observableList;
  }

  /// Returns the first entity that has the given attribute value.
  @override
  E firstWhereAttribute(String code, Object attribute) {
    var selectionEntities = selectWhereAttribute(code, attribute);
    if (selectionEntities.isNotEmpty) {
      return selectionEntities.first;
    }
    throw EDNetException(
      'E firstWhereAttribute(String code, Object attribute): code = $code, attribute = $attribute',
    );
  }

  /// Returns a random entity from the collection.
  @override
  E random() {
    if (!isEmpty) {
      return _entityList[randomGen.nextInt(length)];
    }
    throw EDNetException('E random(): length = $length');
  }

  /// Returns the entity with the given [oid], or null if not found.
  @override
  E? singleWhereOid(Oid oid) {
    if (_oidEntityMap[oid.timeStamp] != null) {
      return _oidEntityMap[oid.timeStamp];
    }

    return null;
  }

  /// Returns the entity with the given [oid] from this collection or its internal children.
  @override
  Entity? internalSingle(Oid oid) {
    if (isEmpty) {
      return null;
    }
    Entity? foundEntity = singleWhereOid(oid);
    if (foundEntity != null) {
      return foundEntity;
    }

    if (_concept?.children.isNotEmpty ?? false) {
      for (Entity entity in _entityList) {
        for (Child child in _concept!.children.whereType<Child>()) {
          if (child.internal) {
            Entities? childEntities = entity.getChild(child.code) as Entities?;
            Entity? childEntity = childEntities?.internalSingle(oid);
            if (childEntity != null) {
              return childEntity;
            }
          }
        }
      }
    }
    return null;
  }

  /// Returns the collection containing the entity with the given [oid].
  @override
  Entities? internalChild(Oid oid) {
    if (isEmpty) {
      return null;
    }
    Entity? foundEntity = singleWhereOid(oid);
    if (foundEntity != null) {
      return this;
    }
    if (_concept?.children.isNotEmpty ?? false) {
      for (Entity entity in _entityList) {
        for (Child child in _concept!.children.whereType<Child>()) {
          if (child.internal) {
            Entities? childEntities = entity.getChild(child.code) as Entities?;
            Entity? childEntity = childEntities?.internalSingle(oid);
            if (childEntity != null) {
              return childEntities;
            }
          }
        }
      }
    }
    return null;
  }

  /// Returns the entity with the given [code], or null if not found.
  @override
  E? singleWhereCode(String? code) {
    return _codeEntityMap[code];
  }

  /// Returns the entity with the given [id], or null if not found.
  @override
  E? singleWhereId(Id id) {
    var entity = _idEntityMap[id.toString()];
    if (entity != null) {
      return entity;
    }

    return null;
  }

  /// Returns the entity with the given attribute value.
  @override
  E? singleWhereAttributeId(String code, Object attribute) {
    return singleWhereId((Id(_concept!))..setAttribute(code, attribute));
  }

  /// Creates a shallow copy of this collection.
  /// The copy shares the same concept but has its own entity list.
  @override
  Entities<E> copy() {
    if (_concept == null) {
      throw new ConceptException('Entities.copy: concept is not defined.');
    }

    Entities<E> copiedEntities = newEntities();
    copiedEntities.pre = false;
    copiedEntities.post = false;
    copiedEntities.propagateToSource = false;
    for (Entity<E> entity in this) {
      copiedEntities.add(entity.copy());
    }
    copiedEntities.pre = true;
    copiedEntities.post = true;
    copiedEntities.propagateToSource = true;
    return copiedEntities;
  }

  /// Orders the entities using the given [compare] function.
  /// If [compare] is not provided, uses the entity's [compareTo] method.
  @override
  Entities<E> order([int Function(E a, E b)? compare]) {
    if (_concept == null) {
      throw new ConceptException('Entities.order: concept is not defined.');
    }

    Entities<E> orderedEntities = newEntities();
    orderedEntities.pre = false;
    orderedEntities.post = false;
    orderedEntities.propagateToSource = false;
    List<E> sortedList = toList();
    sortedList.sort(compare);
    for (var entity in sortedList) {
      orderedEntities.add(entity);
    }
    orderedEntities.pre = true;
    orderedEntities.post = true;
    orderedEntities.propagateToSource = false;
    orderedEntities.source = this;
    return orderedEntities;
  }

  /// Returns entities that satisfy the predicate [f].
  @override
  Entities<E> selectWhere(bool Function(E) f) {
    if (_concept == null) {
      throw new ConceptException(
        'Entities.selectWhere: concept is not defined.',
      );
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    var selectedElements = _entityList.where(f);
    for (var entity in selectedElements) {
      selectedEntities.add(entity);
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns entities that have the given attribute value.
  @override
  Entities<E> selectWhereAttribute(String code, Object attribute) {
    if (_concept == null) {
      throw new ConceptException(
        'Entities.selectWhereAttribute($code, $attribute): concept is not defined.',
      );
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    for (E entity in _entityList) {
      for (Attribute a in _concept!.attributes.whereType<Attribute>()) {
        if (a.code == code) {
          if (entity.getAttribute(a.code) == attribute) {
            selectedEntities.add(entity);
          }
        }
      }
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns entities that have the given parent.
  @override
  Entities<E> selectWhereParent(String code, IEntity parent) {
    if (_concept == null) {
      throw new ConceptException(
        'Entities.selectWhereParent($code, $parent): concept is not defined.',
      );
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    for (E entity in _entityList) {
      for (Parent p in _concept!.parents.whereType<Parent>()) {
        if (p.code == code) {
          if (entity.getParent(p.code) == parent) {
            selectedEntities.add(entity);
          }
        }
      }
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns all entities except the first [n].
  @override
  Entities<E> skipFirst(int n) {
    if (_concept == null) {
      throw new ConceptException('Entities.skipFirst: concept is not defined.');
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    var selectedElements = _entityList.skip(n);
    for (var entity in selectedElements) {
      selectedEntities.add(entity);
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns all entities after the first one that doesn't satisfy [f].
  @override
  Entities<E> skipFirstWhile(bool Function(E entity) f) {
    if (_concept == null) {
      throw new ConceptException(
        'Entities.skipFirstWhile: concept is not defined.',
      );
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    var selectedElements = _entityList.skipWhile(f);
    for (var entity in selectedElements) {
      selectedEntities.add(entity);
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns the first [n] entities.
  @override
  Entities<E> takeFirst(int n) {
    if (_concept == null) {
      throw new ConceptException('Entities.takeFirst: concept is not defined.');
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    var selectedElements = _entityList.take(n);
    for (var entity in selectedElements) {
      selectedEntities.add(entity);
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Returns all entities up to but not including the first one that doesn't satisfy [f].
  @override
  Entities<E> takeFirstWhile(bool Function(E entity) f) {
    if (_concept == null) {
      throw new ConceptException(
        'Entities.takeFirstWhile: concept is not defined.',
      );
    }

    Entities<E> selectedEntities = newEntities();
    selectedEntities.pre = false;
    selectedEntities.post = false;
    selectedEntities.propagateToSource = false;
    var selectedElements = _entityList.takeWhile(f);
    for (var entity in selectedElements) {
      selectedEntities.add(entity);
    }
    selectedEntities.pre = true;
    selectedEntities.post = true;
    selectedEntities.propagateToSource = true;
    selectedEntities.source = this;
    return selectedEntities;
  }

  /// Converts the collection to a JSON string.
  @override
  String toJson() => jsonEncode(toJsonList());

  /// Converts the collection to a list of JSON maps.
  List<Map<String, dynamic>> toJsonList() {
    List<Map<String, dynamic>> entityList = <Map<String, dynamic>>[];
    for (E entity in _entityList) {
      entityList.add(entity.toJsonMap() as Map<String, dynamic>);
    }
    return entityList;
  }

  /// Loads entities from a JSON string.
  @override
  void fromJson(String entitiesJson) {
    List<Map<String, dynamic>> entitiesList = jsonDecode(entitiesJson);
    fromJsonList(entitiesList);
  }

  /// Loads entities from a list of JSON maps.
  /// The collection must be empty before loading.
  void fromJsonList(entitiesList, [Entity? internalParent]) {
    if (_concept == null) {
      throw new ConceptException('entities concept does not exist.');
    }

    if (length > 0) {
      throw JsonException('entities are not empty');
    }
    var beforePre = pre;
    var beforePost = post;
    pre = false;
    post = false;
    for (var entityMap in entitiesList) {
      var entity = newEntity();
      entity.fromJsonMap(entityMap);
      add(entity as E);
    }
    pre = beforePre;
    post = beforePost;
  }

  /// Returns a string representation of this collection.
  @override
  String toString() {
    if (_concept == null) {
      throw new ConceptException('Entities.toString: concept is not defined.');
    }

    return '${_concept!.code}: entities:$length';
  }

  /// Removes all entities from the collection.
  @override
  void clear() {
    _entityList.clear();
    _oidEntityMap.clear();
    _codeEntityMap.clear();
    _idEntityMap.clear();
    exceptions.clear();
  }

  /// Sorts the entities using the given [compare] function.
  /// If [compare] is not provided, uses the entity's [compareTo] method.
  @override
  void sort([int Function(E a, E b)? compare]) {
    _entityList.sort(compare);
  }

  /// Validates an entity before adding it to the collection.
  @override
  bool isValid(E entity) {
    if (!pre) {
      return true;
    }

    if (entity._concept == null) {
      throw new ConceptException(
        'Entity(oid: ${entity.oid}) concept is not defined.',
      );
    }
    if (_concept == null) {
      throw new ConceptException('Entities.add: concept is not defined.');
    }
    if (!_concept!.canAdd) {
      throw new AddException('An entity cannot be added to ${_concept!.code}.');
    }

    // Clear any existing exceptions before validation
    exceptions.clear();

    bool isValid = true;

    // max validation
    isValid = validateCardinality(isValid);

    // increment and required validation
    isValid = validateIncrementAndRequired(entity, isValid);

    // uniqueness validation
    isValid = validateUnique(entity, isValid);

    return isValid;
  }

  /// Validates uniqueness constraints for an entity.
  bool validateUnique(entity, bool isValid) {
    if (entity.id != null && singleWhereId(entity.id) != null) {
      ValidationException exception = new ValidationException(
        'unique',
        '${entity.concept.code}.id ${entity.id.toString()} is not unique.',
      );
      exceptions.add(exception as IValidationExceptions);
      return false;
    }

    return isValid;
  }

  /// Validates increment and required constraints for an entity.
  bool validateIncrementAndRequired(entity, bool isValid) {
    bool result = isValid;

    for (Attribute a in _concept!.attributes.whereType<Attribute>()) {
      var shouldIncrement = a.increment != null;
      var exists = entity.getAttribute(a.code) != null;
      var isRequired = a.required;
      var isDerived = a.derive;

      if (shouldIncrement) {
        if (length == 0) {
          entity.setAttribute(a.code, a.increment!);
        } else if (a.type?.code == 'int') {
          var lastEntity = last;
          int incrementAttribute = lastEntity.getAttribute(a.code) as int;
          var attributeUpdate = a.update;
          a.update = true;

          // Calculate the next sequence value
          int expectedValue = incrementAttribute + a.increment!;

          // Set the value directly rather than checking first
          entity.setAttribute(a.code, expectedValue);

          a.update = attributeUpdate;
        } else {
          throw TypeException(
            '${a.code} attribute value cannot be incremented.',
          );
        }
      } else if (isRequired && !exists) {
        const category = 'required';
        final message =
            '${entity.concept.code}.${a.code} attribute is required.';
        final exception = ValidationException(category, message);

        exceptions.add(exception);
        result = false;
      } else if (isDerived && exists) {
        // Derived attributes should not be updated by the user
        const category = 'update';
        final message =
            '${entity.concept.code}.${a.code} is a derived attribute and cannot be updated directly.';
        final exception = ValidationException(category, message);

        exceptions.add(exception);
        result = false;
      } else if (exists) {
        var value = entity.getAttribute(a.code);

        // Type validation
        if (!a.type!.validateValue(value)) {
          const category = 'type';
          final message =
              '${entity.concept.code}.${a.code} attribute value is not of type ${a.type!.code}.';
          final exception = ValidationException(category, message);

          exceptions.add(exception);
          result = false;
        }
        // String length validation
        else if (a.type!.base == 'String' &&
            value is String &&
            a.length != null &&
            value.length > a.length!) {
          const category = 'length';
          final message =
              '${entity.concept.code}.${a.code} attribute value exceeds maximum length of ${a.length}.';
          final exception = ValidationException(category, message);

          exceptions.add(exception);
          result = false;
        }
        // Email format validation
        else if (a.type!.code == 'Email' &&
            value is String &&
            !a.type!.isEmail(value)) {
          const category = 'format';
          final message =
              '${entity.concept.code}.${a.code} attribute value is not a valid email format.';
          final exception = ValidationException(category, message);

          exceptions.add(exception);
          result = false;
        }
      }
    }

    for (Parent p in _concept!.parents.whereType<Parent>()) {
      if (p.required && entity.getParent(p.code) == null) {
        const category = 'required';
        final message = '${entity.concept.code}.${p.code} parent is required.';
        final exception = ValidationException(category, message);

        exceptions.add(exception);
        result = false;
      }
    }

    return result;
  }

  /// Validates cardinality constraints.
  bool validateCardinality(bool isValid) {
    if (maxC != 'N') {
      int maxInt;
      try {
        maxInt = int.parse(maxC);
        if (length == maxInt) {
          const category = 'max cardinality';
          final message = '${_concept!.code}.max is $maxC.';
          var exception = ValidationException(category, message);

          exceptions.add(exception);
          return false;
        }
      } on FormatException catch (e) {
        throw AddException(
          'Entities max is neither N nor a positive integer string: $e',
        );
      }
    }
    return isValid;
  }

  /// Adds an entity to the collection if it passes validation.
  @override
  bool add(dynamic entity) {
    bool added = false;
    if (isValid(entity)) {
      var propagated = true;
      if (source != null && propagateToSource) {
        propagated = source!.add(entity);
      }
      if (propagated) {
        _entityList.add(entity);
        _oidEntityMap[entity.oid.timeStamp] = entity;
        _codeEntityMap[entity.code] = entity;
        if (entity.id != null) {
          _idEntityMap[entity.id.toString()] = entity;
        }
        if (postAdd(entity)) {
          added = true;
          entity._whenAdded = DateTime.now();
        } else {
          var beforePre = pre;
          var beforePost = post;
          pre = false;
          post = false;
          if (!remove(entity)) {
            var msg =
                '${entity.concept.code} entity (${entity.oid}) '
                'was added, post was not successful, remove was not successful';
            throw RemoveException(msg);
          } else {
            entity._whenAdded = null;
          }
          pre = beforePre;
          post = beforePost;
        }
      } else {
        var msg =
            '${entity.concept.code} entity (${entity.oid}) '
            'was not added - propagation to the source ${source?.concept.code} '
            'entities was not successful';
        throw AddException(msg);
      }
    }
    return added;
  }

  /// Validates an entity after adding it to the collection.
  @override
  bool postAdd(E entity) {
    if (!post) {
      return true;
    }

    if (entity._concept == null) {
      throw new ConceptException(
        'Entity(oid: ${entity.oid}) concept is not defined.',
      );
    }
    if (_concept == null) {
      throw new ConceptException('Entities.add: concept is not defined.');
    }

    bool result = true;

    return result;
  }

  /// Validates an entity before removing it from the collection.
  @override
  bool preRemove(E entity) {
    if (!pre) {
      return true;
    }

    if (entity._concept == null) {
      throw new ConceptException(
        'Entity(oid: ${entity.oid}) concept is not defined.',
      );
    }
    if (_concept == null) {
      throw new ConceptException('Entities.remove: concept is not defined.');
    }
    if (!_concept!.remove) {
      throw new RemoveException(
        'An entity cannot be removed from ${_concept!.code}.',
      );
    }

    bool result = true;

    // min validation
    if (minC != '0') {
      int minInt;
      try {
        minInt = int.parse(minC);
        if (length == minInt) {
          const category = 'min';
          final message = '${_concept!.code}.min is $minC.';
          ValidationException exception = ValidationException(
            category,
            message,
          );

          exceptions.add(exception);
          result = false;
        }
      } on FormatException catch (e) {
        throw RemoveException(
          'Entities min is not a positive integer string: $e',
        );
      }
    }

    return result;
  }

  /// Removes an entity from the collection if it passes validation.
  @override
  bool remove(E entity) {
    bool removed = false;
    if (preRemove(entity)) {
      var propagated = true;
      if (source != null && propagateToSource) {
        propagated = source!.remove(entity);
      }
      if (propagated) {
        if (_entityList.remove(entity)) {
          _oidEntityMap.remove(entity.oid.timeStamp);
          _codeEntityMap.remove(entity.code);
          if (entity._concept != null && entity.id != null) {
            _idEntityMap.remove(entity.id.toString());
          }
          if (postRemove(entity)) {
            removed = true;
            entity._whenRemoved = DateTime.now();
          } else {
            var beforePre = pre;
            var beforePost = post;
            pre = false;
            post = false;
            if (!add(entity)) {
              var msg =
                  '${entity.concept.code} entity (${entity.oid}) '
                  'was removed, post was not successful, add was not successful';
              throw AddException(msg);
            } else {
              entity._whenRemoved = null;
            }
            pre = beforePre;
            post = beforePost;
          }
        }
      } else {
        var msg =
            '${entity.concept.code} entity (${entity.oid}) '
            'was not removed - propagation to the source ${source!.concept.code} '
            'entities was not successful';
        throw RemoveException(msg);
      }
    }
    return removed;
  }

  /// Validates an entity after removing it from the collection.
  @override
  bool postRemove(E entity) {
    if (!post) {
      return true;
    }

    if (entity._concept == null) {
      throw new ConceptException(
        'Entity(oid: ${entity.oid}) concept is not defined.',
      );
    }
    if (_concept == null) {
      throw new ConceptException('Entities.add: concept is not defined.');
    }
    bool result = true;

    return result;
  }

  /// Updates an entity by removing the old version and adding the new version.
  /// Only works if oid, code, or id are changed.
  bool update(E beforeEntity, E afterEntity) {
    if (_concept == null) {
      throw new ConceptException('Entities.update: concept is not defined.');
    }
    if (beforeEntity.oid == afterEntity.oid &&
        beforeEntity.code == afterEntity.code &&
        beforeEntity.id == afterEntity.id) {
      throw UpdateException(
        '${_concept!.code}.update can only be used if oid, code or id set.',
      );
    }
    if (remove(beforeEntity)) {
      if (add(afterEntity)) {
        return true;
      } else {
        print('entities.update: ${exceptions.toList()}');
        if (add(beforeEntity)) {
          const category = 'update';
          final message =
              '${_concept!.code}.update fails to add after update entity.';
          var exception = ValidationException(category, message);
          exceptions.add(exception);
        } else {
          throw UpdateException(
            '${_concept!.code}.update fails to add back before update entity.',
          );
        }
      }
    } else {
      const category = 'update';
      final message =
          '${_concept!.code}.update fails to remove before update entity.';
      var exception = ValidationException(category, message);

      exceptions.add(exception);
    }
    return false;
  }

  /// Adds all entities from another collection.
  bool addFrom(Entities<E> entities) {
    bool allAdded = true;
    if (_concept == entities.concept) {
      for (var entity in entities) {
        add(entity) ? true : allAdded = false;
      }
    } else {
      throw ConceptException('The concept of the argument is different.');
    }
    return allAdded;
  }

  /// Removes all entities from another collection.
  bool removeFrom(Entities<E> entities) {
    bool allRemoved = true;
    if (_concept == entities.concept) {
      for (var entity in entities) {
        remove(entity) ? true : allRemoved = false;
      }
    } else {
      throw ConceptException('The concept of the argument is different.');
    }
    return allRemoved;
  }

  /// Updates attributes of entities from another collection.
  bool setAttributesFrom(Entities<E> entities) {
    bool allSet = true;
    if (_concept == entities.concept) {
      for (var entity in entities) {
        var baseEntity = singleWhereOid(entity.oid);
        if (baseEntity != null) {
          var baseEntitySet = baseEntity.setAttributesFrom(entity);
          if (!baseEntitySet) {
            allSet = false;
          }
        } else {
          allSet = false;
        }
      }
    } else {
      throw ConceptException('The concept of the argument is different.');
    }
    return allSet;
  }

  /// Displays the entities in a formatted way.
  void display({
    String title = 'Entities',
    String prefix = '',
    bool withOid = true,
    bool withChildren = true,
    bool withInternalChildren = true,
  }) {
    if (_concept == null) {
      throw new ConceptException('Entities.display: concept is not defined.');
    }

    var s = prefix;

    bool thereIsNoEntry = !(_concept!.entry);
    bool thereIsEntry = _concept!.entry;
    bool thereIsParent = _concept!.parents.isNotEmpty;

    if (thereIsNoEntry || (thereIsEntry && thereIsParent)) {
      s = '$prefix  ';
    }
    if (title != '') {
      print('$s======================================');
      print('$s$title                                ');
      print('$s======================================');
    }
    for (E e in _entityList) {
      e.display(
        prefix: s,
        withOid: withOid,
        withChildren: withChildren,
        withInternalChildren: withInternalChildren,
      );
    }
  }

  /// Displays the OID map.
  void displayOidMap() {
    _oidEntityMap.forEach((k, v) {
      print('oid $k: $v');
    });
  }

  /// Displays the code map.
  void displayCodeMap() {
    _codeEntityMap.forEach((k, v) {
      print('code $k: $v');
    });
  }

  /// Displays the ID map.
  void displayIdMap() {
    _idEntityMap.forEach((k, v) {
      print('id $k: $v');
    });
  }

  /// Returns an iterable that yields all entities from this collection followed by [other].
  @override
  Iterable<E> followedBy(Iterable<E> other) {
    return _entityList.followedBy(other);
  }

  /// Returns an iterable that yields all entities of type [T].
  @override
  Iterable<T> whereType<T>() {
    return _entityList.whereType<T>();
  }

  /// Integrates entities from another collection.
  @override
  void integrate(IEntities<E> fromEntities) {
    for (var entity in toList()) {
      var fromEntity = fromEntities.singleWhereOid(entity.oid);
      if (fromEntity == null) {
        remove(entity);
      }
    }
    for (var fromEntity in fromEntities) {
      var entity = singleWhereOid(fromEntity.oid);
      if (entity != null && entity.whenSet != null) {
        if (entity.whenSet!.millisecondsSinceEpoch <
            fromEntity.whenSet!.millisecondsSinceEpoch) {
          entity.setAttributesFrom(fromEntity);
        }
      } else {
        add(fromEntity);
      }
    }
  }

  /// Integrates entities to add from another collection.
  @override
  void integrateAdd(IEntities<E> addEntities) {
    for (var addEntity in addEntities) {
      var entity = singleWhereOid(addEntity.oid);
      if (entity == null) {
        add(addEntity);
      }
    }
  }

  /// Integrates entities to remove from another collection.
  @override
  void integrateRemove(IEntities<E> removeEntities) {
    for (var removeEntity in removeEntities) {
      var entity = singleWhereOid(removeEntity.oid);
      if (entity != null) {
        remove(entity);
      }
    }
  }

  /// Integrates entities to set from another collection.
  @override
  void integrateSet(IEntities<E> setEntities) {
    for (var setEntity in setEntities) {
      var entity = singleWhereOid(setEntity.oid);
      if (entity != null && entity.whenSet != null) {
        if (entity.whenSet!.millisecondsSinceEpoch <
            setEntity.whenSet!.millisecondsSinceEpoch) {
          entity.setAttributesFrom(setEntity);
        }
      }
    }
  }

  /// Returns an iterable that yields all entities cast to type [T].
  @override
  Iterable<T> cast<T>() {
    final it = () sync* {
      for (var e in this) {
        yield e;
      }
    }();
    try {
      it.elementAt(0);
    } on TypeError catch (_) {
      throw TypeError();
    }
    return it as Iterable<T>;
  }

  /// Converts the collection to a graph structure.
  Map<String, dynamic> toGraph() {
    return {
      'type': runtimeType.toString(),
      'entities': _entityList.map((entity) => entity.toGraph()).toList(),
    };
  }
}


========================================

=== entity/entity.dart ===

part of ednet_core;

/// Represents a generic, domain-driven entity in the EDNet Core framework.
///
/// An Entity holds:
/// - A [concept], which describes the domain's metadata (attributes, parents, children, etc.).
/// - An [oid] (unique object identifier).
/// - A [code] string (human-readable identifier).
/// - Lifecycle timestamps ([whenAdded], [whenSet], [whenRemoved]) for auditing.
/// - Collection mappings for attributes, parent references, and child collections.
///
/// In practice, you subclass [Entity<E>] to define your specific domain entity.
/// The type parameter [E] should be the same subclass type to enable self-referential behaviors.
///
/// This class also enforces domain and model policies, handling attribute/parent/child updates
/// with automatic policy checks.
///
/// Example usage:
/// ```dart
/// class Product extends Entity<Product> {
///   late String name;
///   late double price;
///   // Additional domain-specific fields...
/// }
///
/// final product = Product();
/// product.name = 'Laptop';
/// product.price = 1299.99;
/// ```
class Entity<E extends Entity<E>> implements IEntity<E> {
  /// The [Concept] that defines the metadata for this entity.
  /// It includes the attributes, parents, and child relationships.
  /// If null, the [concept] getter throws an [EDNetException].
  Concept? _concept;

  /// Unique object identifier used to distinguish this entity.
  /// Typically set once, but can be updated if [concept.updateOid] is true.
  var _oid = Oid();

  /// A short string code to identify the entity.
  /// If [_code] is null, defaults to the literal `'code'`.
  String? _code;

  /// Timestamp recorded upon initial insertion or creation.
  /// Can be updated only if [concept.updateWhen] is true.
  DateTime? _whenAdded;

  /// Timestamp recorded whenever an attribute or relationship is updated.
  /// Automatically set to [DateTime.now()] if [concept.updateWhen] is true.
  DateTime? _whenSet;

  /// Timestamp recorded when the entity is logically removed.
  /// Can be updated only if [concept.updateWhen] is true.
  DateTime? _whenRemoved;

  /// Accumulates validation or policy violation exceptions.
  /// Each time entity updates happen, [exceptions] may record domain errors.
  @override
  var exceptions = ValidationExceptions();

  /// Internal policy evaluator used to apply entity-level or model-level policies.
  PolicyEvaluator _policyEvaluator = PolicyEvaluator(PolicyRegistry());

  /// Allows external configuration of the [PolicyEvaluator].
  set policyEvaluator(PolicyEvaluator newPolicyEvaluator) {
    _policyEvaluator = newPolicyEvaluator;
  }

  /// Stores attribute data for this entity.
  /// Key: attribute code; Value: attribute's current value.
  Map<String, Object?> _attributeMap = <String, Object?>{};

  /// Stores references to parents identified by code.
  /// Each parent is represented by a [Reference] linking OID and concept info.
  Map<String, Reference> _referenceMap = <String, Reference>{};

  /// Maps each parent code to the actual parent entity instance.
  Map<String, Object?> _parentMap = <String, Object?>{};

  /// Maps each child code to a collection of child entities ([Entities])
  /// that can be manipulated.
  Map<String, Object?> _childMap = <String, Object?>{};

  /// Similar to [_childMap], but used for internal children (where `child.internal == true`).
  Map<String, Object?> _internalChildMap = <String, Object?>{};

  /// Hooks to control pre/post conditions on attribute/relationship changes.
  /// [pre] indicates if we do pre-validation logic, [post] for post-validation.
  bool pre = false;
  bool post = false;

  /// Creates a new empty instance of this entity type.
  /// The returned entity has the same [Concept] as the original.
  Entity<E> newEntity() {
    var entity = Entity<E>();
    entity.concept = _concept!;
    return entity;
  }

  /// Creates a new [Entities<E>] collection that can hold instances of this entity.
  /// The new collection references the same [Concept].
  Entities<E> newEntities() {
    var entities = Entities<E>();
    entities.concept = _concept!;
    return entities;
  }

  /// The [Concept] describing the domain structure for this entity.
  /// If `_concept` is null, throws [EDNetException].
  @override
  Concept get concept {
    if (_concept == null) {
      throw EDNetException("concept is not set");
    }
    return _concept!;
  }

  /// Assign a [Concept] to this entity.
  /// This re-initializes all attribute/parent/child maps, sets pre/post to true,
  /// and applies any attribute defaults defined in the concept.
  set concept(Concept concept) {
    _concept = concept;
    _attributeMap = <String, Object?>{};
    _referenceMap = <String, Reference>{};
    _parentMap = <String, Object?>{};
    _childMap = <String, Object?>{};
    _internalChildMap = <String, Object?>{};

    pre = true;
    post = true;

    // Initialize all attributes with default or init values.
    for (Attribute a in _concept!.attributes.whereType<Attribute>()) {
      if (a.init == null) {
        // no default assigned
      } else if (a.type?.code == 'DateTime' && a.init == 'now') {
        _attributeMap[a.code] = DateTime.now();
      } else if (a.type?.code == 'bool' && a.init == 'true') {
        _attributeMap[a.code] = true;
      } else if (a.type?.code == 'bool' && a.init == 'false') {
        _attributeMap[a.code] = false;
      } else if (a.type?.code == 'int') {
        try {
          _attributeMap[a.code] = int.parse(a.init);
        } on FormatException catch (e) {
          throw TypeException(
            '${a.code} attribute init (default) value is not int: $e',
          );
        }
      } else if (a.type?.code == 'double') {
        try {
          _attributeMap[a.code] = double.parse(a.init);
        } on FormatException catch (e) {
          throw TypeException(
            '${a.code} attribute init (default) value is not double: $e',
          );
        }
      } else if (a.type?.code == 'num') {
        try {
          _attributeMap[a.code] = int.parse(a.init);
        } on FormatException catch (e1) {
          try {
            _attributeMap[a.code] = double.parse(a.init);
          } on FormatException catch (e2) {
            throw TypeException(
              '${a.code} attribute init (default) value is not num: $e1; $e2',
            );
          }
        }
      } else if (a.type?.code == 'Uri') {
        try {
          _attributeMap[a.code] = Uri.parse(a.init);
        } on ArgumentError catch (e) {
          throw TypeException(
            '${a.code} attribute init (default) value is not Uri: $e',
          );
        }
      } else {
        // For other types, store raw init.
        _attributeMap[a.code] = a.init;
      }
    }

    // Initialize references for each parent.
    for (Parent parent in _concept!.parents.whereType<Parent>()) {
      _referenceMap.remove(parent.code);
      _parentMap.remove(parent.code);
    }

    // Initialize child collections.
    for (Child child in _concept!.children.whereType<Child>()) {
      var childEntities = Entities<E>();
      childEntities.concept = child.destinationConcept;
      _childMap[child.code] = childEntities;
      if (child.internal) {
        _internalChildMap[child.code] = childEntities;
      }
    }
  }

  /// Evaluates entity-level and model-level policies for this entity.
  /// If a [policyKey] is provided, only that specific policy is evaluated.
  PolicyEvaluationResult evaluatePolicies({String? policyKey}) {
    return _policyEvaluator.evaluate(this, policyKey: policyKey);
  }

  /// Unique object identifier (OID) for the entity.
  /// By default, this is assigned on creation, but can be changed if [concept.updateOid] is true.
  @override
  Oid get oid => _oid;

  /// Updates the [oid] if [concept.updateOid] is true, otherwise throws.
  set oid(Oid oid) {
    if (_concept?.updateOid == true) {
      _oid = oid;
    } else {
      throw OidException('Entity.oid cannot be updated.');
    }
  }

  /// The [Id] aggregates all identifier attributes or parent references.
  /// If the concept has none, returns null.
  @override
  Id? get id {
    if (_concept == null) {
      return null;
      // throw new ConceptException('Entity concept is not defined.');
    }
    Id id = Id(_concept!);
    for (Parent p in _concept!.parents.whereType<Parent>()) {
      if (p.identifier) {
        id.setReference(p.code, _referenceMap[p.code]);
      }
    }
    for (Attribute a in _concept!.attributes.whereType<Attribute>()) {
      if (a.identifier) {
        id.setAttribute(a.code, _attributeMap[a.code]);
      }
    }
    if (id.length == 0) {
      return null;
    }
    return id;
  }

  /// An optional human-readable string code identifying the entity.
  /// If null, defaults to `'code'`. If concept says [updateCode] is false, cannot update.
  @override
  String get code => _code ?? 'code';

  set code(String? code) {
    if (_code == null || _concept?.updateCode == true) {
      _code = code;
    } else {
      throw CodeException('Entity.code cannot be updated.');
    }
  }

  /// Timestamp of when the entity was first created or added.
  /// Only updatable if [concept.updateWhen] is true.
  @override
  DateTime? get whenAdded => _whenAdded;

  @override
  set whenAdded(DateTime? whenAdded) {
    if (_concept?.updateWhen == true) {
      _whenAdded = whenAdded;
    } else {
      throw UpdateException('Entity.whenAdded cannot be updated.');
    }
  }

  /// Timestamp of the latest attribute or relationship update.
  /// Used for partial concurrency or auditing.
  @override
  DateTime? get whenSet => _whenSet;

  @override
  set whenSet(DateTime? whenSet) {
    if (_concept?.updateWhen == true) {
      _whenSet = whenSet;
    } else {
      throw UpdateException('Entity.whenSet cannot be updated.');
    }
  }

  /// Timestamp of when the entity was logically removed.
  /// Only updatable if [concept.updateWhen] is true.
  @override
  DateTime? get whenRemoved => _whenRemoved;

  @override
  set whenRemoved(DateTime? whenRemoved) {
    if (_concept?.updateWhen == true) {
      _whenRemoved = whenRemoved;
    } else {
      throw UpdateException('Entity.whenRemoved cannot be updated.');
    }
  }

  /// Utility property returning the code's first letter in lowercase.
  String get codeFirstLetterLower => firstLetterLower(code);

  /// Utility property returning the code's first letter in uppercase.
  String get codeFirstLetterUpper => firstLetterUpper(code);

  /// Utility property returning the code in lower_snake_case form.
  String get codeLowerUnderscore => camelCaseLowerSeparator(code, '_');

  /// Utility property returning the code in lower space-separated form.
  String get codeLowerSpace => camelCaseLowerSeparator(code, ' ');

  /// Utility property returning the code in plural form.
  String get codePlural => plural(code);

  /// Utility property returning the plural code, first letter lowercased.
  String get codePluralFirstLetterLower => firstLetterLower(codePlural);

  /// Utility property returning the plural code, first letter uppercased.
  String get codePluralFirstLetterUpper => firstLetterUpper(codePlural);

  /// Utility property returning the plural code in lower_snake_case.
  String get codePluralLowerUnderscore =>
      camelCaseLowerSeparator(codePlural, '_');

  /// Utility property returning the plural code in a spaced form with uppercase first letter.
  String get codePluralFirstLetterUpperSpace =>
      camelCaseFirstLetterUpperSeparator(codePlural, ' ');

  /// Called before setting an attribute. If [pre] is true, can run additional checks.
  /// If returns false, attribute set operation is not performed.
  @override
  bool preSetAttribute(String name, Object? value) {
    if (!pre) {
      return true;
    }

    if (_concept == null) {
      throw ConceptException('Entity(oid: ${oid}) concept is not defined.');
    }
    return true;
  }

  /// Retrieves the attribute value for [attributeCode] as type [K].
  /// Returns null if not set.
  @override
  K? getAttribute<K>(String attributeCode) =>
      _attributeMap[attributeCode] as K?;

  /// Sets an attribute by [name] to [value], respecting update rules and calling policy checks.
  /// Returns true if the attribute was successfully updated.
  /// Throws [UpdateException] if the attribute is not updatable or absent.
  /// Also handles policy checks, reverting changes if policies fail.
  @override
  bool setAttribute(String name, Object? value) {
    bool updated = false;

    if (preSetAttribute(name, value)) {
      if (_concept == null) {
        throw ConceptException('Entity concept is not defined.');
      }

      var attribute = _concept?.attributes.singleWhereCode(name);
      if (attribute == null) {
        String msg = '${_concept?.code}.$name is not correct attribute name.';
        throw UpdateException(msg);
      }
      /*
       * validation done in Entities.preAdd
      if (value == null && attribute.minc != '0') {
        String msg = '${_concept?.code}.$name cannot be null.';
        throw new UpdateException(msg);
      }
      */
      Object? beforeValue = _attributeMap[name];
      // If attribute not yet set, or if it is updatable
      if (getAttribute(name) == null) {
        _attributeMap[name] = value;
        updated = true;
        //} else if (!attribute.derive && attribute.update) {
      } else if (attribute.update) {
        _attributeMap[name] = value;
        updated = true;
        _whenSet = DateTime.now();
      } else {
        String msg = '${_concept?.code}.${attribute.code} is not updatable.';
        throw UpdateException(msg);
      }

      // Now handle post-set logic.
      if (postSetAttribute(name, value)) {
        updated = true;
      } else {
        // If postSet fails, revert changes.
        var beforePre = pre;
        var beforePost = post;
        pre = false;
        post = false;
        if (beforeValue == null || !setAttribute(name, beforeValue)) {
          var msg =
              '${_concept?.code}.${attribute.code} '
              'was set to a new value, post was not successful, '
              'set to the before value was not successful';
          throw RemoveException(msg);
        } else {
          _whenSet = null;
        }
        pre = beforePre;
        post = beforePost;
      }

      // If updated, run policy checks.
      if (updated) {
        var policyResult = evaluatePolicies();
        if (!policyResult.success) {
          // revert change
          _attributeMap[name] = beforeValue;
          updated = false;
          throw PolicyViolationException(policyResult.violations);
        }

        var modelPolicyResult = concept.model.evaluateModelPolicies(this);
        if (!modelPolicyResult) {
          _attributeMap[name] = beforeValue;
          updated = false;
          throw PolicyViolationException(modelPolicyResult.violations);
        }
      }
    }
    return updated;
  }

  /// Called after setting an attribute. If [post] is true, can run additional checks.
  /// Return false if you want to revert the update.
  @override
  bool postSetAttribute(String name, Object? value) {
    if (!post) {
      return true;
    }

    if (_concept == null) {
      throw ConceptException('Entity(oid: ${oid}) concept is not defined.');
    }
    return true;
  }

  /// Returns the attribute value as a string. If the value is null, returns `'null'`.
  @override
  String? getStringFromAttribute(String name) => _attributeMap[name].toString();

  /// Returns the attribute value as a nullable string, or null if no value.
  @override
  String? getStringOrNullFromAttribute(String name) =>
      _attributeMap[name]?.toString();

  /// Helper to parse a [string] and update the attribute [name] accordingly.
  /// If the attribute type is recognized (e.g., int, bool), we parse the string.
  /// Otherwise, store the string as-is.
  @override
  bool setStringToAttribute(String name, String string) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    Attribute? attribute =
        _concept?.attributes.singleWhereCode(name) as Attribute?;
    if (attribute == null) {
      String msg = '${_concept?.code}.$name is not correct attribute name.';
      throw UpdateException(msg);
    }

    // If literal 'null', we interpret that as no value.
    if (string == 'null') {
      return setAttribute(name, null);
    }

    // Attempt to parse based on declared attribute type.
    if (attribute.type?.code == 'DateTime') {
      try {
        return setAttribute(name, DateTime.parse(string));
      } on ArgumentError catch (e) {
        throw TypeException(
          '${_concept?.code}.${attribute.code} '
          'attribute value is not DateTime: $e',
        );
      }
    } else if (attribute.type?.code == 'bool') {
      if (string == 'true') {
        return setAttribute(name, true);
      } else if (string == 'false') {
        return setAttribute(name, false);
      } else {
        throw TypeException('${attribute.code} attribute value is not bool.');
      }
    } else if (attribute.type?.code == 'int') {
      try {
        return setAttribute(name, int.parse(string));
      } on FormatException catch (e) {
        throw TypeException(
          '${attribute.code} '
          'attribute value is not int: $e',
        );
      }
    } else if (attribute.type?.code == 'double') {
      try {
        return setAttribute(name, double.parse(string));
      } on FormatException catch (e) {
        throw TypeException(
          '${attribute.code} '
          'attribute value is not double: $e',
        );
      }
    } else if (attribute.type?.code == 'num') {
      try {
        return setAttribute(name, int.parse(string));
      } on FormatException catch (e1) {
        try {
          return setAttribute(name, double.parse(string));
        } on FormatException catch (e2) {
          throw TypeException(
            '${attribute.code} attribute value is not num: $e1; $e2',
          );
        }
      }
    } else if (attribute.type?.code == 'Uri') {
      try {
        return setAttribute(name, Uri.parse(string));
      } on ArgumentError catch (e) {
        throw TypeException('${attribute.code} attribute value is not Uri: $e');
      }
    } else {
      // For any other or custom type, store string as-is.
      return setAttribute(name, string);
    }
  }

  /// Returns the [Reference] to a parent by [name], if any.
  Reference? getReference(String name) => _referenceMap[name];

  /// Sets a [Reference] for a parent [name], but only if that parent slot is empty.
  void setReference(String name, Reference reference) {
    if (getParent(name) == null) {
      _referenceMap[name] = reference;
    }
  }

  /// Gets the parent entity by [name], or null if none.
  @override
  Object? getParent(String name) => _parentMap[name];

  /// Gets the internal child collection reference by [name].
  Object? getInternalChild(String name) => _internalChildMap[name];

  /// Retrieves the child collection matching [name].
  /// Or null if no such child is defined.
  @override
  Object? getChild(String? name) {
    return _childMap[name];
  }

  /// Bulk-updates this entity's attributes from another entity if [whenSet] is older.
  /// Only non-identifier attributes are considered. Returns true if all updated.
  bool setAttributesFrom(Entity entity) {
    bool allSet = true;
    if (entity.whenSet?.millisecondsSinceEpoch != null &&
        whenSet?.millisecondsSinceEpoch != null &&
        (whenSet!.millisecondsSinceEpoch <
            entity.whenSet!.millisecondsSinceEpoch)) {
      for (Attribute attribute in _concept!.nonIdentifierAttributes) {
        var newValue = entity.getAttribute(attribute.code);
        var attributeSet = setAttribute(attribute.code, newValue);
        if (!attributeSet) {
          allSet = false;
        }
      }
    } else {
      allSet = false;
    }
    return allSet;
  }

  /// Creates a shallow copy of this entity.
  /// OID, code, attributes, and references are duplicated.
  /// Child/parent references are not deeply cloned but re-linked.
  @override
  E copy() {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    Entity<E> entity = newEntity();

    // Oid updates.
    var beforeUpdateOid = entity.concept.updateOid;
    entity.concept.updateOid = true;
    entity.oid = _oid;
    entity.concept.updateOid = beforeUpdateOid;

    // Code updates.
    if (_code != null) {
      var beforeUpdateCode = entity.concept.updateCode;
      entity.concept.updateCode = true;
      entity.code = _code;
      entity.concept.updateCode = beforeUpdateCode;
    }

    // Lifecycle timestamps.
    var beforeUpdateWhen = concept.updateWhen;
    concept.updateWhen = true;
    if (_whenAdded != null) {
      entity.whenAdded = _whenAdded;
    }
    if (_whenSet != null) {
      entity.whenSet = _whenSet;
    }
    if (_whenRemoved != null) {
      entity.whenRemoved = _whenRemoved;
    }
    concept.updateWhen = beforeUpdateWhen;

    // Copy attributes.
    for (Attribute attribute in _concept!.attributes.whereType<Attribute>()) {
      if (attribute.identifier) {
        var beforeUpdate = attribute.update;
        attribute.update = true;
        entity.setAttribute(attribute.code, _attributeMap[attribute.code]);
        attribute.update = beforeUpdate;
      } else {
        entity.setAttribute(attribute.code, _attributeMap[attribute.code]);
      }
    }

    // Copy parent references.
    for (Parent parent in _concept!.parents.whereType<Parent>()) {
      if (parent.identifier) {
        var beforeUpdate = parent.update;
        parent.update = true;
        entity.setParent(parent.code, _parentMap[parent.code]);
        parent.update = beforeUpdate;
      } else if (_parentMap[parent.code] != null) {
        entity.setParent(parent.code, _parentMap[parent.code]);
      }
    }

    // Copy child references.
    for (Child child in _concept!.children.whereType<Child>()) {
      entity.setChild(child.code, _childMap[child.code]!);
    }

    return entity as E;
  }

  /// Hashes the entity by its [oid].
  @override
  int get hashCode => _oid.hashCode;

  /// Equality is based on [oid]. If their OIDs match, they are considered the same entity.
  bool equals(E entity) {
    if (_oid.equals(entity.oid)) {
      return true;
    }
    return false;
  }

  /// The `==` operator delegates to [equals].
  /// If [other] is not an Entity, returns false.
  @override
  bool operator ==(Object other) {
    if (other is Entity) {
      Entity entity = other;
      if (identical(this, entity)) {
        return true;
      } else {
        return equals(entity as E);
      }
    } else {
      return false;
    }
  }

  /// Checks if the content (attributes, code, parents, children) matches another entity.
  /// Ignores [oid], [whenAdded], [whenSet], [whenRemoved].
  bool equalContent(E entity) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    if (_code != entity.code) {
      return false;
    }
    // Compare each attribute.
    for (Attribute a in _concept!.attributes.whereType<Attribute>()) {
      if (_attributeMap[a.code] != entity.getAttribute(a.code)) {
        return false;
      }
    }
    // Compare each parent.
    for (Parent parent in _concept!.parents.whereType<Parent>()) {
      if (_parentMap[parent.code] != entity.getParent(parent.code)) {
        return false;
      }
    }
    // Compare each child.
    for (Child child in _concept!.children.whereType<Child>()) {
      if (_childMap[child.code] != entity.getChild(child.code)) {
        return false;
      }
    }
    return true;
  }

  /// Compare two entities, primarily using [code], otherwise [id], otherwise attribute comparisons.
  /// If negative, this < that; zero => equal; positive => this > that.
  @override
  int compareTo(entity) {
    if (code.isNotEmpty && _code != null) {
      return _code!.compareTo(entity.code);
    } else if (entity.id != null && id != null) {
      return id!.compareTo(entity.id);
    } else if (concept.attributes.isNotEmpty) {
      return compareAttributes(entity);
    } else {
      var msg = '${_concept?.code} concept does not have attributes.';
      throw IdException(msg);
    }
  }

  /// Compare attributes one by one until a difference is found.
  /// Return negative if this < that; zero if same; positive if this > that.
  int compareAttributes(E entity) {
    var compare = 0;
    for (Attribute a in concept.attributes.whereType<Attribute>()) {
      var value1 = _attributeMap[a.code];
      var value2 = entity.getAttribute(a.code);

      compare = a.type?.compare(value1, value2) ?? 0;
      if (compare != 0) {
        break;
      }
    }
    return compare;
  }

  /// Returns a concise string representation using the entity's [oid] and [code].
  @override
  String toString() {
    if (_code == null) {
      return '{${_concept?.code}: {oid:${_oid.toString()}}}';
    } else {
      return '{${_concept?.code}: {oid:${_oid.toString()}, code:$_code}}';
    }
  }

  /// Prints [toString()].
  void displayToString() {
    print(toString());
  }

  /// Displays this entity's details, including attributes, parents, children.
  ///
  /// Parameters:
  /// - [prefix]: indentation or formatting prefix.
  /// - [withOid]: whether to show the OID in output.
  /// - [withChildren]: whether to recursively display child collections.
  /// - [withInternalChildren]: whether to display internal child sets.
  void display({
    String prefix = '',
    bool withOid = true,
    bool withChildren = true,
    bool withInternalChildren = true,
  }) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    var s = prefix;
    if (!(_concept?.entry == true) ||
        ((_concept?.entry == true) && _concept?.parents.isNotEmpty == true)) {
      s = '$prefix  ';
    }
    print('$s------------------------------------');
    print('$s${toString()}                       ');
    print('$s------------------------------------');
    s = '$s  ';
    if (withOid) {
      print('${s}oid: $_oid');
    }
    print('${s}code: $_code');
    print('${s}id: $id');
    print('${s}whenAdded: $_whenAdded');
    print('${s}whenSet: $_whenSet');
    print('${s}whenRemoved: $_whenRemoved');

    // Display all attributes.
    _attributeMap.forEach((k, v) {
      if (_concept?.isAttributeSensitive(k) == true) {
        print('$s$k: **********');
      } else {
        print('$s$k: $v');
      }
    });

    // Display parents.
    _parentMap.forEach((k, v) {
      if (_concept?.isParentSensitive(k) == true) {
        print('$s$k: **********');
      } else {
        print('$s$k: ${v.toString()}');
      }
    });

    // Optionally display children.
    if (withChildren) {
      if (withInternalChildren) {
        _internalChildMap.forEach((k, v) {
          print('$s$k:');
          if (_concept?.isChildSensitive(k) == true) {
            print('**********');
          } else {
            (v as Entities).display(
              title: '$s$k',
              prefix: '$s  ',
              withOid: withOid,
              withChildren: withChildren,
              withInternalChildren: withInternalChildren,
            );
          }
        });
      } else {
        _childMap.forEach((k, v) {
          print('$s$k:');
          if (_concept?.isChildSensitive(k) == true) {
            print('**********');
          } else {
            (v as Entities).display(
              title: '$s$k',
              prefix: '$s  ',
              withOid: withOid,
              withChildren: withChildren,
              withInternalChildren: withInternalChildren,
            );
          }
        });
      }
    }
    print('');
  }

  /// Converts this entity to a JSON string.
  String toJson() => jsonEncode(toJsonMap());

  /// Converts this entity to a JSON object.
  Map<String, dynamic> toJsonMap() {
    Map<String, dynamic> entityMap = <String, dynamic>{};
    entityMap['oid'] = _oid.toString();
    if (_code != null) {
      entityMap['code'] = _code;
    }
    if (_whenAdded != null) {
      entityMap['whenAdded'] = _whenAdded!.millisecondsSinceEpoch;
    }
    if (_whenSet != null) {
      entityMap['whenSet'] = _whenSet!.millisecondsSinceEpoch;
    }
    if (_whenRemoved != null) {
      entityMap['whenRemoved'] = _whenRemoved!.millisecondsSinceEpoch;
    }
    entityMap['concept'] = _concept!.code;

    // Add attributes
    Map<String, dynamic> attributeMap = <String, dynamic>{};
    for (Attribute attribute in _concept!.attributes.whereType<Attribute>()) {
      final value = _attributeMap[attribute.code];
      if (value != null) {
        // Convert DateTime to millisecondsSinceEpoch for JSON serialization
        if (value is DateTime) {
          attributeMap[attribute.code] = value.millisecondsSinceEpoch;
        }
        // Convert Uri to string for JSON serialization
        else if (value is Uri) {
          attributeMap[attribute.code] = value.toString();
        } else {
          attributeMap[attribute.code] = value;
        }
      }
    }
    if (attributeMap.isNotEmpty) {
      entityMap['attributes'] = attributeMap;
    }

    // Add parents
    Map<String, dynamic> parentMap = <String, dynamic>{};
    for (Parent parent in _concept!.parents.whereType<Parent>()) {
      final ref = _referenceMap[parent.code];
      if (ref != null) {
        parentMap[parent.code] = ref.toJson();
      }
    }
    if (parentMap.isNotEmpty) {
      entityMap['parents'] = parentMap;
    }

    // Add children
    Map<String, dynamic> childMap = <String, dynamic>{};
    for (Child child in _concept!.children.whereType<Child>()) {
      final childEntities = getChild(child.code);
      final internalChildEntities = getInternalChild(child.code);
      if (childEntities != null && internalChildEntities != null) {
        childMap[child.code] = (internalChildEntities as Entities).toJsonList();
      } else if (childEntities != null) {
        childMap[child.code] = (childEntities as Entities).toJsonList();
      }
    }
    if (childMap.isNotEmpty) {
      entityMap['children'] = childMap;
    }

    return entityMap;
  }

  /// Loads this entity from a JSON string.
  @override
  void fromJson<K extends Entity<K>>(String entityJson) {
    try {
      Map<String, dynamic> entityMap = jsonDecode(entityJson);
      fromJsonMap(entityMap);
    } catch (e) {
      throw TypeException('${entityJson} oid is not int: $e');
    }
  }

  /// Loads this entity from a JSON object.
  void fromJsonMap(Map<String, dynamic> entityMap) {
    // Load basic properties
    var oidStr = entityMap['oid'];
    try {
      int timeStamp = int.parse(oidStr);
      // Temporarily allow OID update
      bool originalUpdateOid = _concept?.updateOid ?? false;
      if (_concept != null) {
        _concept!.updateOid = true;
      }
      oid = Oid.ts(timeStamp);
      // Restore original setting
      if (_concept != null) {
        _concept!.updateOid = originalUpdateOid;
      }
    } catch (e) {
      throw TypeException('${entityMap['oid']} oid is not int: $e');
    }

    // Set code if present
    if (entityMap.containsKey('code')) {
      code = entityMap['code'] as String?;
    }

    // Set timestamps if present
    if (entityMap.containsKey('whenAdded')) {
      try {
        int timeStamp = entityMap['whenAdded'] as int;
        _whenAdded = DateTime.fromMillisecondsSinceEpoch(timeStamp);
      } catch (e) {
        throw TypeException(
          'whenAdded is not valid timestamp: ${entityMap['whenAdded']} - $e',
        );
      }
    }

    if (entityMap.containsKey('whenSet')) {
      try {
        int timeStamp = entityMap['whenSet'] as int;
        _whenSet = DateTime.fromMillisecondsSinceEpoch(timeStamp);
      } catch (e) {
        throw TypeException(
          'whenSet is not valid timestamp: ${entityMap['whenSet']} - $e',
        );
      }
    }

    if (entityMap.containsKey('whenRemoved')) {
      try {
        int timeStamp = entityMap['whenRemoved'] as int;
        _whenRemoved = DateTime.fromMillisecondsSinceEpoch(timeStamp);
      } catch (e) {
        throw ('whenRemoved is not valid timestamp: ${entityMap['whenRemoved']} - $e');
      }
    }

    // Load attributes
    if (entityMap.containsKey('attributes')) {
      Map<String, dynamic> attributeMap =
          entityMap['attributes'] as Map<String, dynamic>;
      for (Attribute attribute in _concept!.attributes.whereType<Attribute>()) {
        if (attributeMap.containsKey(attribute.code)) {
          var attributeValue = attributeMap[attribute.code];
          // Convert timestamp to DateTime if the attribute type is DateTime
          if (attribute.type?.code == 'DateTime' && attributeValue is int) {
            attributeValue = DateTime.fromMillisecondsSinceEpoch(
              attributeValue,
            );
          }
          setAttribute(attribute.code, attributeValue);
        }
      }
    }

    // Load parents (references)
    if (entityMap.containsKey('parents')) {
      Map<String, dynamic> parentMap =
          entityMap['parents'] as Map<String, dynamic>;
      for (Parent parent in _concept!.parents.whereType<Parent>()) {
        if (parentMap.containsKey(parent.code)) {
          var parentOidString = parentMap[parent.code]['oid']?.toString() ?? '';
          var parentConceptCode =
              parentMap[parent.code]['concept']?.toString() ?? '';
          // The entryConcept field might be missing in some serialized data
          var parentEntryConceptCode =
              parentMap[parent.code]['entryConcept']?.toString() ??
              parentMap[parent.code]['entry']?.toString() ??
              parentConceptCode;

          Reference reference = Reference(
            parentOidString,
            parentConceptCode,
            parentEntryConceptCode,
          );

          _referenceMap[parent.code] = reference;
        }
      }
    }

    // Load children
    if (entityMap.containsKey('children')) {
      Map<String, dynamic> childMap =
          entityMap['children'] as Map<String, dynamic>;
      for (Child child in concept.children.whereType<Child>()) {
        if (childMap.containsKey(child.code)) {
          List<dynamic> childrenJson = childMap[child.code] as List<dynamic>;
          var childEntities = getChild(child.code) as Entities?;
          if (childEntities != null) {
            childEntities.fromJsonList(childrenJson, this);
          }
        }
      }
    }
  }

  /// Updates a child relationship [name] with [entities].
  /// If child.update is false, we throw an [UpdateException].
  /// If policies fail, we revert.
  @override
  bool setChild(String name, Object entities) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    Child? child = _concept?.children.singleWhereCode(name) as Child?;
    if (child == null) {
      String msg =
          '${_concept?.code}.$name is not correct child entities name.';
      throw UpdateException(msg);
    }

    if (child.update) {
      _childMap.update(name, (value) => entities);
      if (child.internal) {
        _internalChildMap[name] = entities;
      }

      // Evaluate policies after child change.
      var policyResult = evaluatePolicies();
      if (!policyResult.success) {
        _childMap.remove(name);
        if (_internalChildMap.containsKey(name)) {
          _internalChildMap.remove(name);
        }
        throw PolicyViolationException(policyResult.violations);
      }

      // Then model policies.
      var modelPolicyResult = concept.model.evaluateModelPolicies(this);
      if (!modelPolicyResult) {
        _childMap.remove(name);
        if (_internalChildMap.containsKey(name)) {
          _internalChildMap.remove(name);
        }
        throw PolicyViolationException(modelPolicyResult.violations);
      }

      return true;
    } else {
      return false;
      // or throw new UpdateException
    }
  }

  /// Sets or updates a parent relationship named [name] with the given [entity].
  /// If parent is uninitialized or updatable, we store a reference.
  /// If policies fail, we revert.
  @override
  bool setParent(String name, entity) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    Parent? parent = _concept?.parents.singleWhereCode(name) as Parent?;
    if (parent == null) {
      String msg = '${_concept?.code}.$name is not correct parent entity name.';
      throw UpdateException(msg);
    }

    if (entity != null && getParent(name) == null) {
      var reference = Reference(
        entity.oid.toString(),
        entity.concept.code,
        entity.concept.entryConcept.code,
      );
      _parentMap[name] = entity;
      _referenceMap[name] = reference;

      var policyResult = evaluatePolicies();
      if (!policyResult.success) {
        _parentMap.remove(name);
        _referenceMap.remove(name);
        throw PolicyViolationException(policyResult.violations);
      }
      return true;
    } else if (entity != null && parent.update) {
      var reference = Reference(
        entity.oid.toString(),
        entity.concept.code,
        entity.concept.entryConcept.code,
      );
      _parentMap[name] = entity;
      _referenceMap[name] = reference;

      var policyResult = evaluatePolicies();
      if (!policyResult.success) {
        _parentMap.remove(name);
        _referenceMap.remove(name);
        throw PolicyViolationException(policyResult.violations);
      }

      var modelPolicyResult = concept.model.evaluateModelPolicies(this);
      if (!modelPolicyResult.success) {
        _parentMap.remove(name);
        _referenceMap.remove(name);
        throw PolicyViolationException(modelPolicyResult.violations);
      }
      return true;
    } else {
      String msg = '${_concept?.code}.${parent.code} is not updatable.';
      throw UpdateException(msg);
    }
  }

  /// Removes a parent reference by [name], if [parent.update] is true.
  /// Reverts if policies are violated.
  @override
  removeParent(String name) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    Parent? parent = _concept?.parents.singleWhereCode(name) as Parent?;
    Reference? reference = _referenceMap[name];
    if (parent == null) {
      String msg = '${_concept?.code}.$name is not correct parent entity name.';
      throw UpdateException(msg);
    }

    if (parent.update) {
      _parentMap.remove(name);
      _referenceMap.remove(name);

      var policyResult = evaluatePolicies();
      if (!policyResult.success) {
        _parentMap[name] = parent;
        _referenceMap[name] = reference!;
        throw PolicyViolationException(policyResult.violations);
      }
    } else {
      String msg = '${_concept?.code}.${parent.code} is not updatable.';
      throw UpdateException(msg);
    }
  }

  /// Converts this entity to a graph-like structure, including references to parents.
  @override
  Map<String, dynamic> toGraph() {
    var graph = <String, dynamic>{};
    graph['oid'] = oid.toString();
    graph['code'] = code;
    graph['whenAdded'] = whenAdded.toString();
    graph['whenSet'] = whenSet.toString();
    graph['whenRemoved'] = whenRemoved.toString();

    // Add attributes.
    for (var k in _attributeMap.keys) {
      graph[k] = getStringFromAttribute(k);
    }

    // Add internal child graphs.
    for (var k in _internalChildMap.keys) {
      graph[k] = (getInternalChild(k) as Entities).toGraph();
    }

    // Parent references.
    for (var k in _parentMap.keys) {
      var parent = getParent(k) as Entity;
      var reference = Reference(
        parent.oid.toString(),
        parent.concept.code,
        parent.concept.entryConcept.code,
      );
      graph[k] = reference.toGraph();
    }

    return graph;
  }

  /// Retrieves either a parent or child relationship by name.
  /// Returns null if neither is found.
  getRelationship(String relationshipName) {
    if (_concept == null) {
      throw ConceptException('Entity concept is not defined.');
    }

    if (_concept?.isParent(relationshipName) == true) {
      return getParent(relationshipName);
    } else if (_concept?.isChild(relationshipName) == true) {
      return getChild(relationshipName);
    } else {
      return null;
    }
  }
}


========================================

=== entity/id.dart ===

part of ednet_core;

/// A unique identifier for a domain entity that implements the [IId] interface.
///
/// The [Id] class represents a composite identifier that can be composed of:
/// - References to parent entities (through [Reference] objects)
/// - Attribute values that form part of the identifier
///
/// The class maintains two internal maps:
/// - [_referenceMap]: Maps parent codes to their references
/// - [_attributeMap]: Maps attribute codes to their values
///
/// Example usage:
/// ```dart
/// final id = Id(productConcept);
/// id.setAttribute('code', 'PROD-001');
/// id.setParent('category', categoryEntity);
/// ```
class Id implements IId<Id> {
  /// The [Concept] that defines the metadata for this identifier.
  final Concept _concept;

  /// Maps parent codes to their references.
  final Map<String, Reference?> _referenceMap;

  /// Maps attribute codes to their values.
  final Map<String, Object?> _attributeMap;

  /// Creates a new identifier for the given [concept].
  /// Initializes empty maps for references and attributes.
  /// Removes any identifier parents or attributes from the maps.
  Id(this._concept)
      : _referenceMap = <String, Reference?>{},
        _attributeMap = <String, Object?>{} {
    for (Parent p in _concept.parents.whereType<Parent>()) {
      if (p.identifier) {
        _referenceMap.remove(p.code);
      }
    }
    for (Attribute a in concept.attributes.whereType<Attribute>()) {
      if (a.identifier) {
        _attributeMap.remove(a.code);
      }
    }
  }

  /// Gets the [concept] for this identifier.
  @override
  Concept get concept => _concept;

  /// Gets the number of parent references in this identifier.
  @override
  int get referenceLength => _referenceMap.length;

  /// Gets the number of attributes in this identifier.
  @override
  int get attributeLength => _attributeMap.length;

  /// Gets the total number of components (references + attributes) in this identifier.
  @override
  int get length => referenceLength + attributeLength;

  /// Gets the reference for the given parent [code].
  @override
  Reference? getReference(String code) => _referenceMap[code];

  /// Sets the reference for the given parent [code].
  @override
  void setReference(String code, Reference? reference) {
    _referenceMap[code] = reference;
  }

  /// Sets a parent entity reference for the given parent [code].
  /// Creates a new [Reference] from the entity's OID and concept information.
  void setParent(String code, Entity entity) {
    Reference reference = Reference(entity.oid.toString(), entity.concept.code,
        entity.concept.entryConcept.code);
    setReference(code, reference);
  }

  /// Gets the attribute value for the given attribute [code].
  @override
  Object? getAttribute(String code) => _attributeMap[code];

  /// Sets the attribute value for the given attribute [code].
  @override
  void setAttribute(String code, Object? attribute) {
    _attributeMap[code] = attribute;
  }

  /// Computes the hash code for this identifier based on its concept,
  /// references, and attributes.
  @override
  int get hashCode =>
      (_concept.hashCode + _referenceMap.hashCode + _attributeMap.hashCode)
          .hashCode;

  /// Checks if the parent references of this identifier are equal to those of [id].
  /// Only compares identifier parents (those marked with [Parent.identifier]).
  bool equalParents(Id id) {
    for (Parent p in _concept.parents.whereType<Parent>()) {
      if (p.identifier) {
        final refA = _referenceMap[p.code];
        final refB = id.getReference(p.code);
        if (refA != refB) {
          return false;
        }
      }
    }
    return true;
  }

  /// Checks if the attributes of this identifier are equal to those of [id].
  /// Only compares identifier attributes (those marked with [Attribute.identifier]).
  bool equalAttributes(Id id) {
    for (Attribute a in concept.attributes.whereType<Attribute>()) {
      if (a.identifier) {
        if (_attributeMap[a.code] != id.getAttribute(a.code)) {
          return false;
        }
      }
    }
    return true;
  }

  /// Checks if this identifier is equal in content to the given [id].
  /// Two identifiers are equal if they have:
  /// - The same concept
  /// - Equal parent references
  /// - Equal attributes
  bool equals(Id id) {
    if (_concept != id.concept) {
      return false;
    }
    if (!equalParents(id)) {
      return false;
    }
    if (!equalAttributes(id)) {
      return false;
    }
    return true;
  }

  /// Implements the equality operator (==) for comparing identifiers.
  /// 
  /// Two identifiers are considered equal if:
  /// - They are the same object (identical)
  /// - They are both null
  /// - They have equal content (same concept, references, and attributes)
  @override
  bool operator ==(Object other) {
    if (other is Id) {
      Id id = other;
      if (identical(this, id)) {
        return true;
      } else {
        if ((this as dynamic) == null || (id as dynamic) == null) {
          return false;
        } else {
          return equals(id);
        }
      }
    } else {
      return false;
    }
  }

  /// Compares the parent references of this identifier with those of [id].
  /// 
  /// Returns:
  /// - A negative number if this identifier's parents are less than [id]'s
  /// - Zero if they are equal
  /// - A positive number if this identifier's parents are greater than [id]'s
  /// 
  /// Throws [IdException] if the identifier has no parents.
  int compareParents(Id id) {
    if (id.referenceLength > 0) {
      var compare = 0;
      for (Parent p in _concept.parents.whereType<Parent>()) {
        if (p.identifier) {
          final ref = _referenceMap[p.code];
          final ref2 = id.getReference(p.code);
          if (ref != null && ref2 != null) {
            compare = ref.oid.compareTo(ref2.oid);

            if (compare != 0) {
              break;
            }
          }
        }
      }
      return compare;
    }
    throw IdException('${_concept.code}.id does not have parents.');
  }

  /// Compares the attributes of this identifier with those of [id].
  /// 
  /// Returns:
  /// - A negative number if this identifier's attributes are less than [id]'s
  /// - Zero if they are equal
  /// - A positive number if this identifier's attributes are greater than [id]'s
  /// 
  /// Throws [IdException] if the identifier has no attributes.
  int compareAttributes(Id id) {
    if (id.attributeLength > 0) {
      var compare = 0;
      for (Attribute a in concept.attributes.whereType<Attribute>()) {
        var value1 = _attributeMap[a.code];
        var value2 = id.getAttribute(a.code);
        if (value1 != null && value2 != null) {
          compare = a.type!.compare(value1, value2);
          if (compare != 0) {
            break;
          }
        }
      } // for
      return compare;
    }
    throw IdException('${_concept.code}.id does not have attributes.');
  }

  /// Compares this identifier with [id] based on parent references and attributes.
  /// 
  /// Returns:
  /// - A negative number if this identifier is less than [id]
  /// - Zero if they are equal
  /// - A positive number if this identifier is greater than [id]
  /// 
  /// Throws [IdException] if the identifier is not defined.
  @override
  int compareTo(Id id) {
    if (id.length > 0) {
      var compare = 0;
      if (id.referenceLength > 0) {
        compare = compareParents(id);
      }
      if (compare == 0) {
        compare = compareAttributes(id);
      }
      return compare;
    }
    throw IdException('${_concept.code}.id is not defined.');
  }

  /// Removes the given [end] string from the end of [text] if present.
  String _dropEnd(String text, String end) {
    String withoutEnd = text;
    int endPosition = text.lastIndexOf(end);
    if (endPosition > 0) {
      // Drop the end.
      withoutEnd = text.substring(0, endPosition);
    }
    return withoutEnd;
  }

  /// Returns a string representation of this identifier.
  /// The format includes all parent references and attributes.
  @override
  String toString() {
    String result = '';
    if (referenceLength > 0) {
      _referenceMap.forEach((k, v) => result = '$result $v,');
    }
    if (attributeLength > 0) {
      _attributeMap.forEach((k, v) => result = '$result $k:$v,');
    }
    result = _dropEnd(result, ',');
    return result;
  }

  /// Displays the id in a human-readable format in terminal.
  void display([String title = 'Id']) {
    if (title != '') {
      print('');
      print('======================================');
      print('$title                                ');
      print('======================================');
      print('');
    }
    print(toString());
  }
}


========================================

=== entity/interfaces/i_entities.dart ===

part of ednet_core;

/// Interface for collections of domain entities.
///
/// The [IEntities] interface defines the contract for collections of domain entities.
/// It provides functionality for:
/// - Managing a collection of entities of type [E]
/// - Validating entities against domain rules
/// - Managing entity relationships and references
/// - Serializing/deserializing entities to/from JSON
/// - Applying domain policies and validations
///
/// The interface extends [Iterable] to allow iteration over the entities.
///
/// Example usage:
/// ```dart
/// class ProductCollection implements IEntities<Product> {
///   final Concept? concept;
///   final IValidationExceptions exceptions;
///   final List<Product> _entities;
///
///   ProductCollection(this.concept)
///       : exceptions = ValidationExceptions(),
///         _entities = [];
///
///   @override
///   Concept? get concept => concept;
///
///   @override
///   IValidationExceptions get exceptions => exceptions;
///
///   @override
///   Iterator<Product> get iterator => _entities.iterator;
///
///   @override
///   bool add(Product entity) {
///     if (isValid(entity)) {
///       _entities.add(entity);
///       return true;
///     }
///     return false;
///   }
///
///   @override
///   bool remove(Product entity) {
///     if (preRemove(entity)) {
///       _entities.remove(entity);
///       return postRemove(entity);
///     }
///     return false;
///   }
/// }
/// ```
abstract class IEntities<E extends IEntity<E>> implements Iterable<E> {
  /// Gets the [Concept] that defines the metadata for this collection.
  Concept? get concept;

  /// Gets the validation exceptions for this collection.
  IValidationExceptions get exceptions;

  /// Gets the source collection if this is a derived collection.
  IEntities<E>? get source;

  /// Returns the first entity that has the given attribute value.
  E firstWhereAttribute(String code, Object attribute);

  /// Returns a random entity from the collection.
  E random();

  /// Returns the entity with the given [oid], or null if not found.
  E? singleWhereOid(Oid oid);

  /// Returns the entity with the given [oid] from this collection or its internal children.
  IEntity? internalSingle(Oid oid);

  /// Returns the entity with the given [code], or null if not found.
  E? singleWhereCode(String code);

  /// Returns the entity with the given [id], or null if not found.
  E? singleWhereId(Id id);

  /// Returns the entity with the given attribute value.
  E? singleWhereAttributeId(String code, Object attribute);

  /// Creates a shallow copy of this collection.
  IEntities<E> copy();

  /// Orders the entities using the given [compare] function.
  /// If [compare] is not provided, uses the entity's [compareTo] method.
  IEntities<E> order([int Function(E a, E b) compare]);

  /// Returns entities that satisfy the predicate [f].
  IEntities<E> selectWhere(bool Function(E entity) f);

  /// Returns entities that have the given attribute value.
  IEntities<E> selectWhereAttribute(String code, Object attribute);

  /// Returns entities that have the given parent.
  IEntities<E> selectWhereParent(String code, IEntity parent);

  /// Returns all entities except the first [n].
  IEntities<E> skipFirst(int n);

  /// Returns all entities after the first one that doesn't satisfy [f].
  IEntities<E> skipFirstWhile(bool Function(E entity) f);

  /// Returns the first [n] entities.
  IEntities<E> takeFirst(int n);

  /// Returns all entities up to but not including the first one that doesn't satisfy [f].
  IEntities<E> takeFirstWhile(bool Function(E entity) f);

  /// Returns the collection containing the entity with the given [oid].
  IEntities? internalChild(Oid oid);

  /// Removes all entities from the collection.
  void clear();

  /// Sorts the entities using the given [compare] function.
  /// If [compare] is not provided, uses the entity's [compareTo] method.
  void sort([int Function(E a, E b) compare]);

  /// Validates an entity before adding it to the collection.
  bool isValid(E entity);

  /// Adds an entity to the collection if it passes validation.
  bool add(E entity);

  /// Validates an entity after adding it to the collection.
  bool postAdd(E entity);

  /// Validates an entity before removing it from the collection.
  bool preRemove(E entity);

  /// Removes an entity from the collection if it passes validation.
  bool remove(E entity);

  /// Validates an entity after removing it from the collection.
  bool postRemove(E entity);

  /// Converts the collection to a JSON string.
  String toJson();

  /// Loads entities from a JSON string.
  void fromJson(String entitiesJson);

  /// Integrates entities from another collection.
  void integrate(IEntities<E> fromEntities);

  /// Integrates entities to add from another collection.
  void integrateAdd(IEntities<E> addEntities);

  /// Integrates entities to set from another collection.
  void integrateSet(IEntities<E> setEntities);

  /// Integrates entities to remove from another collection.
  void integrateRemove(IEntities<E> removeEntities);

  /// Converts the collection to a graph structure.
  Map<String, dynamic> toGraph();
}
//
// extension IEntitiesExtension<E extends IEntity<E>> on IEntities<E> {
//   Map<String, dynamic> toGraph() {
//     return {
//       'type': runtimeType.toString(),
//       'entities': _entityList.map((entity) => entity.toGraph()).toList(),
//     };
//   }
// }


========================================

=== entity/interfaces/i_entity.dart ===

part of ednet_core;

/// Interface for domain entities.
///
/// The [IEntity] interface defines the contract for domain entities in the system.
/// An entity represents a domain object with:
/// - A unique identifier (OID)
/// - A business identifier (ID)
/// - A code for human-readable identification
/// - Attributes and relationships (parents and children)
/// - Validation rules and exceptions
///
/// The interface extends [Comparable] to allow entities to be ordered.
///
/// Example usage:
/// ```dart
/// class Product implements IEntity<Product> {
///   final Concept concept;
///   final Oid oid;
///   final IId? id;
///   final String? code;
///   final IValidationExceptions exceptions;
///
///   Product(this.concept)
///       : oid = Oid(),
///         exceptions = ValidationExceptions();
///
///   @override
///   Concept get concept => concept;
///
///   @override
///   IValidationExceptions get exceptions => exceptions;
///
///   @override
///   Oid get oid => oid;
///
///   @override
///   IId? get id => id;
///
///   @override
///   String? get code => code;
///
///   @override
///   K? getAttribute<K>(String attributeCode) {
///     // Implement attribute retrieval
///     return null;
///   }
///
///   @override
///   bool setAttribute(String name, Object value) {
///     // Implement attribute setting
///     return true;
///   }
///
///   @override
///   Product copy() {
///     // Implement copying
///     return Product(concept);
///   }
///
///   @override
///   int compareTo(Object other) {
///     // Implement comparison
///     return 0;
///   }
/// }
/// ```
abstract class IEntity<E extends IEntity<E>> implements Comparable {
  /// Gets the [Concept] that defines the metadata for this entity.
  Concept get concept;

  /// Gets the validation exceptions for this entity.
  IValidationExceptions get exceptions;

  /// Gets the object identifier (OID) for this entity.
  Oid get oid;

  /// Gets the business identifier (ID) for this entity.
  IId? get id;

  /// Gets the human-readable code for this entity.
  String? get code;

  /// Timestamp when the entity was added to its collection.
  DateTime? whenAdded;

  /// Timestamp when the entity's attributes were last set.
  DateTime? whenSet;

  /// Timestamp when the entity was removed from its collection.
  DateTime? whenRemoved;

  /// Gets the value of the attribute with the given [attributeCode].
  /// Returns null if the attribute doesn't exist or has no value.
  K? getAttribute<K>(String attributeCode);

  /// Validates and prepares to set an attribute value.
  /// Returns true if the pre-validation passes.
  bool preSetAttribute(String name, Object value);

  /// Sets the value of the attribute with the given [name].
  /// Returns true if the operation was successful.
  bool setAttribute(String name, Object value);

  /// Validates the attribute value after setting.
  /// Returns true if the post-validation passes.
  bool postSetAttribute(String name, Object value);

  /// Gets the string value of the attribute with the given [name].
  /// Returns null if the attribute doesn't exist or has no value.
  String? getStringFromAttribute(String name);

  /// Gets the string value of the attribute with the given [name].
  /// Returns null if the attribute doesn't exist or has no value.
  String? getStringOrNullFromAttribute(String name);

  /// Sets the string value of the attribute with the given [name].
  /// Returns true if the operation was successful.
  bool setStringToAttribute(String name, String string);

  /// Gets the parent entity with the given [name].
  /// Returns null if the parent doesn't exist.
  Object? getParent(String name);

  /// Sets the parent entity with the given [name].
  /// Returns true if the operation was successful.
  bool setParent(String name, entity);

  /// Removes the parent entity with the given [name].
  removeParent(String name);

  /// Gets the child entities with the given [name].
  /// Returns null if the child doesn't exist.
  Object? getChild(String name);

  /// Sets the child entities with the given [name].
  /// Returns true if the operation was successful.
  bool setChild(String name, Object entities);

  /// Creates a deep copy of this entity.
  E copy();

  /// Converts this entity to a JSON string.
  String toJson();

  /// Loads this entity from a JSON string.
  void fromJson<K extends Entity<K>>(String entityJson);

  /// Converts this entity to a graph structure.
  Map<String, dynamic> toGraph();
}

// extension IEntityExtension<E extends IEntity<E>> on IEntity<E> {
//   Map<String, dynamic> toGraph() {
//     return {
//       'code': code,
//       'oid': oid.toString(),
//       'type': runtimeType.toString(),
//       'attributes': _attributeMap,
//       'references': _referenceMap,
//       'parents': _parentMap.map((k, v) => MapEntry(k, v.toGraph())),
//       'children': _childMap.map((k, v) => MapEntry(k, v.toGraph())),
//     };
//   }
// }


========================================

=== entity/interfaces/i_id.dart ===

part of ednet_core;

/// Interface for domain entity identifiers.
///
/// The [IId] interface defines the contract for entity identifiers in the domain model.
/// An identifier can be composed of:
/// - References to parent entities (through [Reference] objects)
/// - Attribute values that form part of the identifier
///
/// The interface extends [Comparable] to allow identifiers to be ordered.
///
/// Example usage:
/// ```dart
/// class ProductId implements IId<ProductId> {
///   final Concept concept;
///   final Map<String, Reference?> references;
///   final Map<String, Object?> attributes;
///
///   ProductId(this.concept)
///       : references = {},
///         attributes = {};
///
///   @override
///   Concept get concept => concept;
///
///   @override
///   int get referenceLength => references.length;
///
///   @override
///   int get attributeLength => attributes.length;
///
///   @override
///   int get length => referenceLength + attributeLength;
///
///   @override
///   Reference? getReference(String code) => references[code];
///
///   @override
///   void setReference(String code, Reference reference) {
///     references[code] = reference;
///   }
///
///   @override
///   Object? getAttribute(String code) => attributes[code];
///
///   @override
///   void setAttribute(String code, Object attribute) {
///     attributes[code] = attribute;
///   }
///
///   @override
///   int compareTo(ProductId other) {
///     // Implement comparison logic
///     return 0;
///   }
/// }
/// ```
abstract class IId<T> implements Comparable<T> {
  /// Gets the [Concept] that defines the metadata for this identifier.
  Concept get concept;

  /// Gets the number of parent references in this identifier.
  int get referenceLength;

  /// Gets the number of attributes in this identifier.
  int get attributeLength;

  /// Gets the total number of components (references + attributes) in this identifier.
  int get length;

  /// Gets the reference for the given parent [code].
  Reference? getReference(String code);

  /// Sets the reference for the given parent [code].
  void setReference(String code, Reference reference);

  /// Gets the attribute value for the given attribute [code].
  Object? getAttribute(String code);

  /// Sets the attribute value for the given attribute [code].
  void setAttribute(String code, Object attribute);
}


========================================

=== error/exceptions.dart ===

part of ednet_core;

class EDNetException implements Exception {
  final String message;

  EDNetException(this.message);

  @override
  toString() => '*** $message ***';
}

class CommandException extends EDNetException {
  CommandException(String message) : super(message);
}

class AddException extends CommandException {
  AddException(String message) : super(message);
}

class CodeException extends EDNetException {
  CodeException(String message) : super(message);
}

class ConceptException extends EDNetException {
  ConceptException(String message) : super(message);
}

class IdException extends EDNetException {
  IdException(String message) : super(message);
}

class JsonException extends EDNetException {
  JsonException(String message) : super(message);
}

class OidException extends EDNetException {
  OidException(String message) : super(message);
}

class OrderException extends EDNetException {
  OrderException(String message) : super(message);
}

class ParentException extends EDNetException {
  ParentException(String message) : super(message);
}

class RemoveException extends CommandException {
  RemoveException(String message) : super(message);
}

class TypeException extends EDNetException {
  TypeException(String message) : super(message);
}

class UpdateException extends CommandException {
  UpdateException(String message) : super(message);
}

class ConceptError extends CommandException {
  ConceptError(String message) : super(message);
}


========================================

=== error/i_validation_exception.dart ===

part of ednet_core;

abstract class IValidationExceptions {
  int get length;

  void add(IValidationExceptions exception);

  void clear();

  List<IValidationExceptions> toList();

  // Category
  String get category;
}


========================================

=== error/validation_exception.dart ===

part of ednet_core;

/// Represents a domain validation exception in the EDNet Core framework.
///
/// The [ValidationException] class provides a structured way to report
/// validation errors from the domain layer, including:
/// - A category to classify the type of validation error
/// - A detailed message explaining the error
/// - Integration with the application layer exception handling
///
/// This class implements [Exception] to enable standard try/catch handling,
/// and is used throughout the domain model to report validation failures.
///
/// Example usage:
/// ```dart
/// throw ValidationException('required', 'The name field is required');
/// ```
class ValidationException implements Exception, IValidationExceptions {
  /// The category of the validation error (e.g., 'required', 'format', 'domain rule').
  final String category;

  /// A descriptive message explaining the validation error.
  final String message;

  /// The entity that caused the validation error, if any.
  final Entity? entity;

  /// The attribute that failed validation, if applicable.
  final String? attribute;

  /// Creates a new validation exception.
  ///
  /// [category] is the type of validation error.
  /// [message] is a descriptive explanation of the error.
  /// [entity] is the optional entity that failed validation.
  /// [attribute] is the optional attribute that failed validation.
  ValidationException(
    this.category,
    this.message, {
    this.entity,
    this.attribute,
  }) {
    if (logExceptions) {
      print('VALIDATION EXCEPTION: $category - $message');
    }
  }

  /// Whether to log exceptions to the console.
  /// This can be useful for debugging, but might be turned off in production.
  static bool logExceptions = true;

  /// Implementation of IValidationExceptions interface
  @override
  int get length => 1;

  @override
  void add(IValidationExceptions exception) {
    /// Single exception can't add other exceptions
    throw UnsupportedError(
      "Can't add exceptions to a ValidationException instance",
    );
  }

  @override
  void clear() {
    /// Single exception can't be cleared
    throw UnsupportedError("Can't clear a ValidationException instance");
  }

  @override
  List<IValidationExceptions> toList() => [this];

  /// Returns a string that represents the error.
  @override
  String toString() {
    if (attribute != null) {
      return '$category: $message (attribute: $attribute)';
    }
    return '$category: $message';
  }

  /// Displays (prints) an exception.
  ///
  /// This method formats and prints details about the exception,
  /// which can be useful for debugging.
  ///
  /// [prefix] is an optional prefix to add to each line of output.
  void display({String prefix = ''}) {
    print('$prefix******************************************');
    print('$prefix$category                               ');
    print('$prefix******************************************');
    print('${prefix}message: $message');
    if (attribute != null) {
      print('${prefix}attribute: $attribute');
    }
    if (entity != null) {
      print('${prefix}entity: ${entity.toString()}');
    }
    print('$prefix******************************************');
    print('');
  }

  /// Converts this exception to an error result for the application layer.
  ///
  /// This method facilitates error reporting to the application layer in
  /// a standardized format that can be used by application services.
  ///
  /// Returns a map with error details.
  Map<String, dynamic> toErrorResult() {
    final result = <String, dynamic>{'category': category, 'message': message};

    if (attribute != null) {
      result['attribute'] = attribute;
    }

    if (entity != null) {
      result['entityType'] = entity?.concept.code;
      result['entityId'] = entity?.id?.toString();
    }

    return result;
  }

  /// Creates a validation exception from an error result.
  ///
  /// This static method creates a validation exception from an error result
  /// that originated in the application layer, enabling bidirectional
  /// conversion between the layers.
  ///
  /// [errorResult] is the error result to convert.
  /// Returns a new [ValidationException].
  static ValidationException fromErrorResult(Map<String, dynamic> errorResult) {
    return ValidationException(
      errorResult['category'] as String,
      errorResult['message'] as String,
      attribute: errorResult['attribute'] as String?,
    );
  }
}


========================================

=== error/validation_exceptions.dart ===

part of ednet_core;

class ValidationExceptions implements IValidationExceptions {
  final List<ValidationException> _exceptionList;

  ValidationExceptions() : _exceptionList = <ValidationException>[];

  @override
  int get length => _exceptionList.length;

  bool get isEmpty => length == 0;

  Iterator<ValidationException> get iterator => _exceptionList.iterator;
  @override
  void add(IValidationExceptions exception) {
    if (exception is ValidationException) {
      _exceptionList.add(exception as ValidationException);
    }
  }

  @override
  void clear() {
    _exceptionList.clear();
  }

  @override
  List<IValidationExceptions> toList() =>
      _exceptionList.cast<IValidationExceptions>().toList();

  /// Returns a string that represents the exceptions.
  @override
  String toString() {
    var messages = '';
    for (var exception in _exceptionList) {
      messages = '${exception.toString()} \n$messages';
    }
    return messages;
  }

  /// Displays (prints) a title, then exceptions.
  void display({String title = 'Entities', bool withOid = true}) {
    if (title == 'Entities') {
      title = 'Errors';
    }
    print('');
    print('************************************************');
    print('$title                                          ');
    print('************************************************');
    print('');
    for (ValidationException exception in _exceptionList) {
      exception.display(prefix: '*** ');
    }
  }

  @override
  String get category => 'Validation';
}


========================================

=== event/event.dart ===

part of ednet_core;

/// Represents a domain event that can be triggered within the system.
///
/// An event is a record of something significant that happened in the domain.
/// It contains information about what happened, who it happened to, and any
/// additional data associated with the event.
///
/// Example usage:
/// ```dart
/// final event = Event(
///   'UserCreated',
///   'A new user has been created in the system',
///   ['SendWelcomeEmail', 'UpdateUserCount'],
///   userEntity,
///   {'email': 'user@example.com'},
/// );
/// ```
class Event {
  /// The name of the event (e.g., 'UserCreated', 'OrderPlaced').
  final String name;

  /// A human-readable description of what the event represents.
  final String description;

  /// List of handler names that should process this event when triggered.
  final List<String> handlers;

  /// The entity associated with this event, if any.
  final Entity? entity;

  /// Additional data associated with the event.
  final Map<String, dynamic> data;

  /// Creates a new [Event] instance.
  ///
  /// [name] is the identifier for the event.
  /// [description] provides context about what happened.
  /// [handlers] are the names of handlers that should process this event.
  /// [entity] is the related domain entity, if any.
  /// [data] is an optional map of additional event data.
  Event(this.name, this.description, this.handlers, this.entity,
      [this.data = const {}]);

  /// Creates a new success [Event] instance.
  ///
  /// This constructor is specifically for events that represent successful operations.
  /// It has the same parameters as the default constructor.
  Event.SuccessEvent(this.name, this.description, this.handlers, this.entity,
      [this.data = const {}]);

  /// Creates a new failure [Event] instance.
  ///
  /// This constructor is specifically for events that represent failed operations.
  /// It has the same parameters as the default constructor.
  Event.FailureEvent(this.name, this.description, this.handlers, this.entity,
      [this.data = const {}]);

  /// Triggers the event handlers associated with this event.
  ///
  /// [session] is the domain session in which the event is being triggered.
  /// This method will execute all registered handlers for this event.
  ///
  /// Note: Currently, the actual handler execution is commented out and only
  /// prints a debug message. This should be implemented based on the specific
  /// requirements of the system.
  void trigger(DomainSession session) {
    // for (var handler in handlers) {
    // session.executeCommand(handler, entity, data);
    print('session handler');
    // }
  }
}


========================================

=== i_model_entries.dart ===

part of ednet_core;

/// Interface defining the contract for model entries in the domain model.
///
/// The [IModelEntries] interface provides functionality for managing and accessing
/// domain entities within a model. It supports:
/// - Retrieving concepts and entries
/// - Finding entities by OID
/// - Managing internal entity relationships
/// - JSON serialization/deserialization
///
/// Example usage:
/// ```dart
/// class DomainModel implements IModelEntries {
///   final Model _model;
///   final Map<String, IEntities> _entries = {};
///
///   DomainModel(this._model);
///
///   @override
///   Model get model => _model;
///
///   @override
///   Concept? getConcept(String conceptCode) {
///     return _model.concepts[conceptCode];
///   }
///
///   @override
///   IEntities getEntry(String entryConceptCode) {
///     return _entries[entryConceptCode]!;
///   }
///
///   // ... implement other methods
/// }
/// ```
abstract class IModelEntries {
  /// Gets the domain model associated with these entries.
  Model get model;

  /// Retrieves a concept by its code.
  ///
  /// [conceptCode] is the unique identifier for the concept.
  /// Returns the [Concept] if found, null otherwise.
  Concept? getConcept(String conceptCode);

  /// Gets the entry entities for a given concept code.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// Returns the collection of entities for that entry concept.
  IEntities getEntry(String entryConceptCode);

  /// Finds a single entity by its OID.
  ///
  /// [oid] is the object identifier of the entity to find.
  /// Returns the entity if found, null otherwise.
  IEntity? single(Oid oid);

  /// Finds a single entity by its OID within a specific entry.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// [oid] is the object identifier of the entity to find.
  /// Returns the entity if found, null otherwise.
  IEntity? internalSingle(String entryConceptCode, Oid oid);

  /// Gets the collection containing an entity with the given OID.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// [oid] is the object identifier of the entity to find.
  /// Returns the collection containing the entity if found, null otherwise.
  IEntities? internalChild(String entryConceptCode, Oid oid);

  /// Whether there are no entries in the model.
  bool get isEmpty;

  /// Removes all entries from the model.
  void clear();

  /// Converts the entries for a specific concept to JSON.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// Returns a JSON string representation of the entries.
  String fromEntryToJson(String entryConceptCode);

  /// Loads entries for a specific concept from JSON.
  ///
  /// [entryJson] is the JSON string containing the entries to load.
  void fromJsonToEntry(String entryJson);

  /// Populates references between entries from JSON.
  ///
  /// [entryJson] is the JSON string containing the reference data.
  void populateEntryReferences(String entryJson);

  /// Converts all entries to JSON.
  ///
  /// Returns a JSON string representation of all entries.
  String toJson();

  /// Loads all entries from JSON.
  ///
  /// [json] is the JSON string containing all entries to load.
  void fromJson(String json);
}


========================================

=== model_entries.dart ===

part of ednet_core;

/// A concrete implementation of [IModelEntries] that manages domain model entries.
///
/// The [ModelEntries] class provides functionality for managing entities within a domain model,
/// including:
/// - Creating and managing entry entities
/// - Finding entities by OID
/// - Managing internal entity relationships
/// - JSON serialization/deserialization
/// - Reference population and management
///
/// Example usage:
/// ```dart
/// final model = Model(domain, 'MyModel');
/// final entries = ModelEntries(model);
///
/// // Create a new entity
/// final entity = entries.newEntity('Product');
///
/// // Get entry entities
/// final products = entries.getEntry('Product');
///
/// // Find an entity by OID
/// final found = entries.single(Oid.ts(1234567890));
/// ```
class ModelEntries implements IModelEntries {
  /// The domain model associated with these entries.
  final Model _model;

  /// Maps entry concept codes to their corresponding entity collections.
  late Map<String, Entities> _entryEntitiesMap;

  /// Creates a new [ModelEntries] instance.
  ///
  /// [model] is the domain model to associate with these entries.
  /// Initializes the entry entities map with empty collections for each entry concept.
  ModelEntries(this._model) {
    _entryEntitiesMap = newEntries();
  }

  /// Creates a new map of entry entities for each entry concept in the model.
  ///
  /// Returns a map where each key is an entry concept code and each value is
  /// an empty [Entities] collection for that concept.
  Map<String, Entities> newEntries() {
    var entries = <String, Entities>{};
    for (var entryConcept in _model.entryConcepts) {
      Entities? entryEntities = Entities<Concept>();

      entryEntities.concept = entryConcept;
      entries[entryConcept.code] = entryEntities;
    }
    return entries;
  }

  /// Creates a new [Entities] collection for a given concept.
  ///
  /// [conceptCode] is the code identifying the concept.
  /// Returns a new [Entities] collection if the concept exists and is not an entry concept.
  /// Throws [ConceptException] if the concept does not exist.
  Entities? newEntities(String conceptCode) {
    var concept = getConcept(conceptCode);

    if (concept == null) {
      throw new ConceptException('${conceptCode} concept does not exist.');
    }

    if (!concept.entry) {
      var entities = Entities<Concept>();
      entities.concept = concept;
      return entities;
    }
    return null;
  }

  /// Creates a new entity instance for a given concept.
  ///
  /// [conceptCode] is the code identifying the concept.
  /// Returns a new [Entity] instance if the concept exists.
  /// Throws [ConceptException] if the concept does not exist.
  Entity? newEntity(String conceptCode) {
    var concept = getConcept(conceptCode);

    if (concept == null) {
      throw ConceptException(
        'Concept with code does not exist: ' + conceptCode,
      );
    }

    var conceptEntity = Entity<Concept>();
    conceptEntity.concept = concept;
    return conceptEntity;
  }

  /// Gets the domain model associated with these entries.
  @override
  Model get model => _model;

  /// Retrieves a concept by its code.
  ///
  /// [conceptCode] is the unique identifier for the concept.
  /// Returns the [Concept] if found, null otherwise.
  @override
  Concept? getConcept(String conceptCode) {
    return _model.getConcept(conceptCode);
  }

  /// Gets the entry entities for a given concept code.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// Returns the collection of entities for that entry concept.
  /// Throws [ConceptException] if the entry concept does not exist.
  @override
  Entities getEntry(String entryConceptCode) {
    if (!_entryEntitiesMap.containsKey(entryConceptCode)) {
      throw ConceptException(
        'Entry concept with code does not exist: ' + entryConceptCode,
      );
    }
    return _entryEntitiesMap[entryConceptCode]!;
  }

  /// Finds a single entity by its OID across all entry concepts.
  ///
  /// [oid] is the object identifier of the entity to find.
  /// Returns the entity if found, null otherwise.
  @override
  Entity? single(Oid oid) {
    for (Concept entryConcept in _model.entryConcepts) {
      var entity = internalSingle(entryConcept.code, oid);
      if (entity != null) return entity;
    }
    return null;
  }

  /// Finds a single entity by its OID within a specific entry.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// [oid] is the object identifier of the entity to find.
  /// Returns the entity if found, null otherwise.
  @override
  Entity? internalSingle(String entryConceptCode, Oid oid) {
    Entities entryEntities = getEntry(entryConceptCode);
    return entryEntities.internalSingle(oid);
  }

  /// Gets the collection containing an entity with the given OID.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// [oid] is the object identifier of the entity to find.
  /// Returns the collection containing the entity if found, null otherwise.
  @override
  Entities? internalChild(String entryConceptCode, Oid oid) {
    Entities entryEntities = getEntry(entryConceptCode);
    return entryEntities.internalChild(oid);
  }

  /// Whether there are no entries in the model.
  ///
  /// Returns true if all entry collections are empty.
  @override
  bool get isEmpty {
    for (Concept entryConcept in _model.entryConcepts) {
      Entities entryEntities = getEntry(entryConcept.code);
      if (!entryEntities.isEmpty) {
        return false;
      }
    }
    return true;
  }

  /// Removes all entries from the model.
  ///
  /// Clears all entity collections for each entry concept.
  @override
  void clear() {
    for (var entryConcept in _model.entryConcepts) {
      var entryEntities = getEntry(entryConcept.code);
      entryEntities.clear();
    }
  }

  /// Converts the entries for a specific concept to JSON.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// Returns a JSON string representation of the entries.
  @override
  String fromEntryToJson(String entryConceptCode) =>
      jsonEncode(fromEntryToMap(entryConceptCode));

  /// Converts the entries for a specific concept to a map.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  /// Returns a map containing the domain, model, entry, and entities data.
  Map<String, dynamic> fromEntryToMap(String entryConceptCode) {
    Map<String, dynamic> entryMap = <String, Object>{};
    entryMap['domain'] = _model.domain.code;
    entryMap['model'] = _model.code;
    entryMap['entry'] = entryConceptCode;
    Entities entryEntities = getEntry(entryConceptCode);
    entryMap['entities'] = entryEntities.toJsonList();
    return entryMap;
  }

  /// Loads entries for a specific concept from JSON.
  ///
  /// [entryJson] is the JSON string containing the entries to load.
  @override
  void fromJsonToEntry(String entryJson) {
    var entryMap = jsonDecode(entryJson);
    fromMapToEntry(entryMap);
  }

  /// Loads entries for a specific concept from a map.
  ///
  /// [entryMap] is the map containing the entry data.
  /// Throws [CodeException] if the domain or model codes don't match.
  /// Throws [ConceptException] if the entry concept doesn't exist.
  /// Throws [JsonException] if the target entry collection is not empty.
  void fromMapToEntry(entryMap) {
    var domainCode = entryMap['domain'];
    var modelCode = entryMap['model'];
    var entryConceptCode = entryMap['entry'];
    if (_model.domain.code != domainCode) {
      throw CodeException('The $domainCode domain does not exist.');
    }
    if (_model.code != modelCode) {
      throw CodeException('The $modelCode model does not exist.');
    }
    var entryConcept = getConcept(entryConceptCode as String);
    if (entryConcept == null) {
      throw ConceptException('${entryConceptCode} concept does not exist.');
    }
    Entities entryEntities = getEntry(entryConceptCode);
    if (entryEntities.isNotEmpty) {
      throw JsonException(
        '$entryConceptCode entry receiving entities are not empty',
      );
    }
    var entitiesList = entryMap['entities'];
    entryEntities.fromJsonList(entitiesList);
  }

  /// Populates entity references for a collection of entities.
  ///
  /// [entities] is the collection of entities to process.
  /// Throws [ParentException] if a referenced parent entity is not found.
  void populateEntityReferences(Entities entities) {
    for (var entity in entities) {
      for (Parent parent in entity.concept.externalParents) {
        Reference? reference = entity.getReference(parent.code);
        if (reference != null) {
          var parentEntity = internalSingle(
            reference.entryConceptCode,
            reference.oid,
          );
          if (parentEntity == null) {
            throw ParentException(
              'Parent not found for the reference: '
              '${reference.toString()}',
            );
          }
          if (entity.getParent(parent.code) == null) {
            entity.setParent(parent.code, parentEntity);
            var parentChildEntities =
                parentEntity.getChild(parent.opposite?.code) as Entities?;
            parentChildEntities?.add(entity);
          }
        }
      }
      for (Child internalChild in entity.concept.internalChildren) {
        var childEntities = entity.getChild(internalChild.code) as Entities?;
        populateEntityReferences(childEntities!);
      }
    }
  }

  /// Populates entry references from a JSON map.
  ///
  /// [entryMap] is the map containing the entry data.
  void populateEntryReferencesFromJsonMap(entryMap) {
    var entryConceptCode = entryMap['entry'];
    var entryEntities = getEntry(entryConceptCode as String);
    populateEntityReferences(entryEntities);
  }

  /// Populates references between entries from JSON.
  ///
  /// [entryJson] is the JSON string containing the reference data.
  @override
  void populateEntryReferences(String entryJson) {
    Map<String, dynamic> entryMap = jsonDecode(entryJson);
    populateEntryReferencesFromJsonMap(entryMap);
  }

  /// Converts all entries to JSON.
  ///
  /// Returns a JSON string representation of all entries.
  @override
  String toJson() => jsonEncode(toJsonMap());

  /// Converts all entries to a map.
  ///
  /// Returns a map containing all entry data.
  Map<String, dynamic> toJsonMap() {
    var entriesMap = <String, Object>{};
    for (var entryConcept in _model.entryConcepts) {
      entriesMap[entryConcept.code] = fromEntryToMap(entryConcept.code);
    }
    return entriesMap;
  }

  /// Loads all entries from JSON.
  ///
  /// [entriesJson] is the JSON string containing all entries to load.
  @override
  void fromJson(String entriesJson) {
    var entriesMap = jsonDecode(entriesJson);
    fromJsonMap(entriesMap);
  }

  /// Loads all entries from a map.
  ///
  /// [entriesMap] is the map containing all entry data.
  void fromJsonMap(entriesMap) {
    for (var entryConcept in _model.entryConcepts) {
      var entryMap = entriesMap[entryConcept.code];
      fromMapToEntry(entryMap);
    }
    populateReferences(entriesMap);
  }

  /// Populates references between entries from a map.
  ///
  /// [entriesMap] is the map containing all entry data.
  void populateReferences(entriesMap) {
    for (var entryConcept in _model.entryConcepts) {
      var entryMap = entriesMap[entryConcept.code];
      populateEntryReferencesFromJsonMap(entryMap);
    }
  }

  /// Displays all entries in a formatted way.
  void display() {
    for (Concept entryConcept in _model.entryConcepts) {
      Entities entryEntities = getEntry(entryConcept.code);
      entryEntities.display(title: entryConcept.code);
    }
  }

  /// Displays the JSON representation of entries for a specific concept.
  ///
  /// [entryConceptCode] is the code identifying the entry concept.
  void displayEntryJson(String entryConceptCode) {
    print('==============================================================');
    print(
      '${_model.domain.code} ${_model.code} ${entryConceptCode} Data in JSON',
    );
    print('==============================================================');
    print(fromEntryToJson(entryConceptCode));
    print('--------------------------------------------------------------');
    print('');
  }

  /// Displays the JSON representation of all entries.
  void displayJson() {
    print('==============================================================');
    print('${_model.domain.code} ${_model.code} Data in JSON');
    print('==============================================================');
    print(toJson());
    print('--------------------------------------------------------------');
    print('');
  }
}


========================================

=== oid.dart ===

part of ednet_core;

/// A class representing a unique object identifier (OID) in the domain model.
///
/// The [Oid] class provides a way to generate and manage unique identifiers for domain entities.
/// It uses a combination of timestamp and increment to ensure uniqueness.
///
/// Example usage:
/// ```dart
/// // Create a new OID with current timestamp
/// final oid1 = Oid();
///
/// // Create an OID with a specific timestamp
/// final oid2 = Oid.ts(1234567890);
///
/// // Compare OIDs
/// if (oid1.compareTo(oid2) < 0) {
///   print('oid1 is less than oid2');
/// }
/// ```
class Oid implements Comparable<Oid> {
  /// Static counter to ensure uniqueness when multiple OIDs are created in the same millisecond.
  static int _increment = 0;

  /// The timestamp value of this OID.
  int _timeStamp = 0;

  /// Creates a new [Oid] instance with the current timestamp.
  ///
  /// The timestamp is calculated as the current milliseconds since epoch plus an increment
  /// to ensure uniqueness even when multiple OIDs are created in the same millisecond.
  Oid() {
    DateTime nowDate = DateTime.now();
    int nowValue = nowDate.millisecondsSinceEpoch;
    _timeStamp = nowValue + _increment++;
  }

  /// Creates a new [Oid] instance with a specific timestamp.
  ///
  /// [timeStamp] is the timestamp value to use for this OID.
  Oid.ts(int timeStamp) {
    _timeStamp = timeStamp;
  }

  /// Gets the timestamp value of this OID.
  int get timeStamp => _timeStamp;

  /// Returns the hash code of this OID based on its timestamp.
  @override
  int get hashCode => _timeStamp.hashCode;

  /// Checks if this OID is equal to another OID.
  ///
  /// [oid] is the OID to compare with.
  /// Returns true if the timestamps are equal, false otherwise.
  bool equals(Oid oid) {
    if (_timeStamp == oid.timeStamp) {
      return true;
    }
    return false;
  }

  /// Compares this OID with another object for equality.
  ///
  /// [other] is the object to compare with.
  /// Returns true if [other] is an OID with the same timestamp, false otherwise.
  ///
  /// This implementation follows Dart's equality operator guidelines:
  /// 1. If either object is null, returns true only if both are null
  /// 2. If the objects are identical, returns true
  /// 3. Otherwise, compares the timestamps using [equals]
  @override
  bool operator ==(Object other) {
    if (other is Oid) {
      Oid oid = other;
      if (identical(this, oid)) {
        return true;
      } else {
        return equals(oid);
      }
    } else {
      return false;
    }
  }

  /// Compares this OID with another OID for ordering.
  ///
  /// [oid] is the OID to compare with.
  /// Returns:
  /// - A negative number if this OID is less than [oid]
  /// - Zero if this OID is equal to [oid]
  /// - A positive number if this OID is greater than [oid]
  ///
  /// The comparison is based on the timestamp values.
  @override
  int compareTo(Oid oid) => _timeStamp.compareTo(oid._timeStamp);

  /// Returns a string representation of this OID.
  ///
  /// Returns the timestamp value as a string.
  @override
  String toString() => _timeStamp.toString();
}


========================================

=== policy/attribute_policy.dart ===

part of ednet_core;

/// A policy that validates entity attributes.
///
/// The [AttributePolicy] class extends [Policy] to provide validation
/// for entity attributes. It can validate:
/// - Direct attributes of an entity
/// - Parent attributes
/// - Child attributes
/// - Complex validation rules using custom validators
///
/// Example usage:
/// ```dart
/// final pricePolicy = AttributePolicy(
///   name: 'PricePolicy',
///   description: 'Product price must be positive',
///   attributeName: 'price',
///   validator: AttributeValidators.isPositive,
/// );
///
/// final emailPolicy = AttributePolicy(
///   name: 'EmailPolicy',
///   description: 'Customer email must be valid',
///   attributeName: 'email',
///   validator: AttributeValidators.isEmail,
/// );
/// ```
class AttributePolicy extends Policy {
  /// The name of the attribute to validate.
  final String attributeName;

  /// The function that validates the attribute value.
  final bool Function(dynamic value) validator;

  /// Creates a new [AttributePolicy] instance.
  ///
  /// [name] is the unique name of the policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [attributeName] is the name of the attribute to validate.
  /// [validator] is the function that validates the attribute value.
  /// [scope] is the scope at which the policy should be evaluated.
  AttributePolicy({
    required String name,
    required String description,
    required this.attributeName,
    required this.validator,
    PolicyScope? scope,
  }) : super(
          name,
          description,
          (e) {
            final value = e.getAttribute(attributeName) ??
                e.getParent(attributeName) ??
                e.getChild(attributeName);
            final isValid = value != null && validator(value);
            if (!isValid) {
              print('Policy "$name" failed for value: $value');
            }
            return isValid;
          },
          scope: scope,
        );

  @override
  bool evaluate(Entity entity) {
    final attributeValue = entity.getAttribute(attributeName);
    final parentValue = entity.getParent(attributeName);
    final childValue = entity.getChild(attributeName);
    final value = attributeValue ?? parentValue ?? childValue;
    if (value == null) {
      print('Policy "$name" failed: attribute "$attributeName" is null.');
      return false;
    }
    final isValid = validator(value);
    if (!isValid) {
      print('Policy "$name: $description" failed for value: $value');
    }
    return isValid;
  }
}

/// Provides common attribute validation functions.
///
/// The [AttributeValidators] class contains static functions for common
/// attribute validation scenarios. These can be used with [AttributePolicy]
/// to create policies for common attribute constraints.
///
/// Example usage:
/// ```dart
/// // Basic validators
/// final isNotNull = AttributeValidators.isNotNull;
/// final isPositive = AttributeValidators.isPositive;
/// final isEmail = AttributeValidators.isEmail;
///
/// // Numeric validators
/// final isInRange = AttributeValidators.isBetween(0, 100);
/// final isGreaterThan = AttributeValidators.isGreaterThan(0);
///
/// // String validators
/// final isValidEmail = AttributeValidators.isEmail;
/// final isValidPhone = AttributeValidators.isPhoneNumber;
/// final hasMinLength = AttributeValidators.hasMinLength(3);
///
/// // Type validators
/// final isString = AttributeValidators.isType(String);
/// final isNumber = AttributeValidators.isType(num);
///
/// // Relationship validators
/// final hasParent = AttributeValidators.hasParentType('Category');
/// final hasChild = AttributeValidators.hasChildType(Product);
/// ```
class AttributeValidators {
  /// Wraps a validator with debug logging.
  ///
  /// [validator] is the validator to wrap.
  /// Returns a new validator that logs validation failures.
  static bool Function(dynamic) withDebug(bool Function(dynamic) validator) =>
      (value) {
        final result = validator(value);
        if (!result) {
          // print('Validation failed for value: $value');
          return false;
        }
        return result;
      };

  /// Validates that a value is not null.
  static bool Function(dynamic) isNotNull = withDebug((value) => value != null);

  /// Creates a validator that checks if a value is greater than a threshold.
  ///
  /// [threshold] is the value to compare against.
  /// Returns a validator that checks if the value is greater than [threshold].
  static bool Function(dynamic) isGreaterThan(num threshold) =>
      withDebug((value) => value is num && value > threshold);

  /// Creates a validator that checks if a value is less than a threshold.
  ///
  /// [threshold] is the value to compare against.
  /// Returns a validator that checks if the value is less than [threshold].
  static bool Function(dynamic) isLessThan(num threshold) =>
      withDebug((value) => value is num && value < threshold);

  /// Creates a validator that checks if a value is within a range.
  ///
  /// [min] is the minimum allowed value.
  /// [max] is the maximum allowed value.
  /// Returns a validator that checks if the value is between [min] and [max].
  static bool Function(dynamic) isBetween(num min, num max) =>
      withDebug((value) => value is num && value >= min && value <= max);

  /// Creates a validator that checks if a string matches a regex pattern.
  ///
  /// [pattern] is the regex pattern to match against.
  /// Returns a validator that checks if the string matches [pattern].
  static bool Function(dynamic) matchesRegex(String pattern) =>
      withDebug((value) => value is String && RegExp(pattern).hasMatch(value));

  /// Creates a validator that checks if a value is in a list of allowed values.
  ///
  /// [allowedValues] is the list of allowed values.
  /// Returns a validator that checks if the value is in [allowedValues].
  static bool Function(dynamic) isOneOf(List<dynamic> allowedValues) =>
      withDebug((value) => allowedValues.contains(value));

  /// Creates a validator that checks if a string has a minimum length.
  ///
  /// [minLength] is the minimum required length.
  /// Returns a validator that checks if the string length is >= [minLength].
  static bool Function(dynamic) hasMinLength(int minLength) =>
      withDebug((value) => value is String && value.length >= minLength);

  /// Creates a validator that checks if a string has a maximum length.
  ///
  /// [maxLength] is the maximum allowed length.
  /// Returns a validator that checks if the string length is <= [maxLength].
  static bool Function(dynamic) hasMaxLength(int maxLength) =>
      withDebug((value) => value is String && value.length <= maxLength);

  /// Validates that a value is a valid email address.
  static bool Function(dynamic) isEmail = withDebug((value) =>
      value is String &&
      RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(value));

  /// Validates that a value is a valid URL.
  static bool Function(dynamic) isUrl =
      withDebug((value) => value is String && Uri.tryParse(value) != null);

  /// Validates that a value is a valid phone number.
  static bool Function(dynamic) isPhoneNumber = withDebug((value) =>
      value is String &&
      RegExp(r'^\+?[0-9]{1,3}-?[0-9]{3,14}$').hasMatch(value));

  /// Validates that a value is a valid date string.
  static bool Function(dynamic) isDate =
      withDebug((value) => value is String && DateTime.tryParse(value) != null);

  /// Creates a validator that checks if a value is of a specific type.
  ///
  /// [type] is the type to check against.
  /// Returns a validator that checks if the value's runtime type matches [type].
  static bool Function(dynamic) isType(Type type) =>
      withDebug((value) => value.runtimeType == type);

  /// Creates a validator that checks if a value is >= a minimum value.
  ///
  /// [minValue] is the minimum allowed value.
  /// Returns a validator that checks if the value is >= [minValue].
  static bool Function(dynamic) hasMinValue(num minValue) =>
      withDebug((value) => value is num && value >= minValue);

  /// Creates a validator that checks if a value is <= a maximum value.
  ///
  /// [maxValue] is the maximum allowed value.
  /// Returns a validator that checks if the value is <= [maxValue].
  static bool Function(dynamic) hasMaxValue(num maxValue) =>
      withDebug((value) => value is num && value <= maxValue);

  /// Validates that a value is positive (> 0).
  static bool Function(dynamic) isPositive =
      withDebug((value) => value is num && value > 0);

  /// Validates that a value is negative (< 0).
  static bool Function(dynamic) isNegative =
      withDebug((value) => value is num && value < 0);

  /// Validates that a value is non-negative (>= 0).
  static bool Function(dynamic) isNonNegative =
      withDebug((value) => value is num && value >= 0);

  /// Validates that a value is non-positive (<= 0).
  static bool Function(dynamic) isNonPositive =
      withDebug((value) => value is num && value <= 0);

  /// Creates a validator that checks if an entity has a parent of a specific type.
  ///
  /// [parentType] is the type of parent to check for.
  /// Returns a validator that checks if the entity has a parent of type [parentType].
  static bool Function(Entity) hasParentType(String parentType) =>
      withDebug((e) =>
          e.concept.parents.any((parent) => parent.runtimeType == parentType));

  /// Creates a validator that checks if an entity has a child of a specific type.
  ///
  /// [childType] is the type of child to check for.
  /// Returns a validator that checks if the entity has a child of type [childType].
  static bool Function(Entity) hasChildType(Type childType) => withDebug(
      (e) => e.concept.children.any((child) => child.runtimeType == childType));

  /// Creates a validator that checks if an entity has a parent with a specific attribute.
  ///
  /// [attributeName] is the name of the attribute to check for.
  /// Returns a validator that checks if any parent has the attribute [attributeName].
  static bool Function(Entity) hasParentWithAttribute(String attributeName) =>
      withDebug((e) => e.concept.parents
          .any((parent) => parent.getAttribute(attributeName) != null));

  /// Creates a validator that checks if an entity has a child with a specific attribute.
  ///
  /// [attributeName] is the name of the attribute to check for.
  /// Returns a validator that checks if any child has the attribute [attributeName].
  static bool Function(Entity) hasChildWithAttribute(String attributeName) =>
      withDebug((e) => e.concept.children
          .any((child) => child.getAttribute(attributeName) != null));

  /// Creates a validator that checks if an entity is a neighbor of another entity.
  ///
  /// [neighbor] is the entity to check for.
  /// Returns a validator that checks if the entity is a neighbor of [neighbor].
  static bool Function(Entity) isNeighborOf(Entity neighbor) => withDebug((e) =>
      e.concept.children.contains(neighbor.concept) ||
      e.concept.parents.contains(neighbor.concept));

  /// Creates a validator that checks if an entity is of a specific type and has a property.
  ///
  /// [type] is the type to check for.
  /// [property] is the name of the property to check for.
  /// Returns a validator that checks if the entity is of type [type] and has property [property].
  static bool Function(Entity) isTypeWithProperty(Type type, String property) =>
      withDebug(
          (e) => e.runtimeType == type && e.getAttribute(property) != null);

  /// Creates a validator that checks if an entity is of a specific type and has a parent of a specific type.
  ///
  /// [type] is the type to check for.
  /// [parentType] is the type of parent to check for.
  /// Returns a validator that checks if the entity is of type [type] and has a parent of type [parentType].
  static bool Function(Entity) isTypeWithParentType(
          Type type, Type parentType) =>
      withDebug((e) =>
          e.runtimeType == type &&
          e.concept.parents.any((parent) => parent.runtimeType == parentType));

  /// Creates a validator that checks if an entity is of a specific type and has a child of a specific type.
  ///
  /// [type] is the type to check for.
  /// [childType] is the type of child to check for.
  /// Returns a validator that checks if the entity is of type [type] and has a child of type [childType].
  static bool Function(Entity) isTypeWithChildType(Type type, Type childType) =>
      withDebug((e) =>
          e.runtimeType == type &&
          e.concept.children.any((child) => child.runtimeType == childType));

  /// Creates a validator that checks if an entity is of a specific type and has a neighbor.
  ///
  /// [neighbor] is the entity to check for.
  /// Returns a validator that checks if the entity is of type [neighbor]'s type or has [neighbor] as a neighbor.
  static bool Function(Entity) isTypeWithNeighbor(Entity neighbor) =>
      withDebug((e) =>
          e.runtimeType == neighbor.runtimeType ||
          e.concept.children.contains(neighbor.concept) ||
          e.concept.parents.contains(neighbor.concept));

  /// Creates a validator that checks if an entity is of a specific type and has a parent.
  ///
  /// [parent] is the parent entity to check for.
  /// Returns a validator that checks if the entity is of type [parent]'s type or has [parent] as a parent.
  static bool Function(Entity) isTypeWithParent(Entity parent) =>
      withDebug((e) =>
          e.runtimeType == parent.runtimeType ||
          e.concept.parents.contains(parent.concept));

  /// Creates a validator that checks if an entity is of a specific type and has a child.
  ///
  /// [child] is the child entity to check for.
  /// Returns a validator that checks if the entity is of type [child]'s type or has [child] as a child.
  static bool Function(Entity) isTypeWithChild(Entity child) => withDebug((e) =>
      e.runtimeType == child.runtimeType ||
      e.concept.children.contains(child.concept));

  /// Creates a validator that checks if an entity is of a specific type and has a neighbor of a specific type.
  ///
  /// [neighborType] is the type of neighbor to check for.
  /// Returns a validator that checks if the entity is of type [neighborType] or has a neighbor of type [neighborType].
  static bool Function(Entity) isTypeWithNeighborType(Type neighborType) =>
      withDebug((e) =>
          e.runtimeType == neighborType ||
          e.concept.children
              .any((child) => child.runtimeType == neighborType) ||
          e.concept.parents
              .any((parent) => parent.runtimeType == neighborType));

  /// Creates a validator that checks if an entity is of a specific type, has a parent of a specific type, and the parent has a property.
  ///
  /// [type] is the type to check for.
  /// [parentType] is the type of parent to check for.
  /// [property] is the name of the property to check for.
  /// Returns a validator that checks all three conditions.
  static bool Function(Entity) isTypeWithParentTypeAndProperty(
          Type type, Type parentType, String property) =>
      withDebug((e) =>
          e.runtimeType == type &&
          e.concept.parents.any((parent) =>
              parent.runtimeType == parentType &&
              parent.getAttribute(property) != null));

  /// Creates a validator that checks if an entity is of a specific type, has a child of a specific type, and the child has an attribute.
  ///
  /// [type] is the type to check for.
  /// [childType] is the type of child to check for.
  /// [attribute] is the name of the attribute to check for.
  /// Returns a validator that checks all three conditions.
  static bool Function(Entity) isTypeWithChildTypeAndAttribute(
          Type type, Type childType, String attribute) =>
      withDebug((e) =>
          e.runtimeType == type &&
          e.concept.children.any((child) =>
              child.runtimeType == childType &&
              child.getAttribute(attribute) != null));

  /// Creates a validator that combines multiple validators.
  ///
  /// [validators] is the list of validators to combine.
  /// Returns a validator that checks if all validators pass.
  static bool Function(Entity) compositeValidator(
          List<bool Function(dynamic)> validators) =>
      withDebug((e) => validators.every((validator) => validator(e)));
}


========================================

=== policy/composite_policy.dart ===

part of ednet_core;

/// A policy that combines multiple policies with a specified evaluation strategy.
///
/// The [CompositePolicy] class implements [IPolicy] to provide a way to combine
/// multiple policies into a single policy. It supports different evaluation strategies
/// through the [CompositePolicyType] enum:
/// - [CompositePolicyType.all]: All policies must pass
/// - [CompositePolicyType.any]: At least one policy must pass
/// - [CompositePolicyType.none]: No policies should pass
/// - [CompositePolicyType.majority]: More than half of the policies must pass
///
/// Example usage:
/// ```dart
/// final pricePolicy = AttributePolicy(
///   name: 'PricePolicy',
///   description: 'Product price must be positive',
///   attributeName: 'price',
///   validator: AttributeValidators.isPositive,
/// );
///
/// final stockPolicy = AttributePolicy(
///   name: 'StockPolicy',
///   description: 'Product must have stock',
///   attributeName: 'stock',
///   validator: AttributeValidators.isGreaterThan(0),
/// );
///
/// final productPolicies = CompositePolicy(
///   name: 'ProductPolicies',
///   description: 'Combined product validation policies',
///   policies: [pricePolicy, stockPolicy],
///   type: CompositePolicyType.all,
/// );
/// ```
class CompositePolicy implements IPolicy {
  /// The unique name of the composite policy.
  @override
  final String name;

  /// A human-readable description of what the composite policy enforces.
  @override
  final String description;

  /// The list of policies to evaluate.
  final List<IPolicy> policies;

  /// The type of composite policy that determines how the policies are evaluated.
  final CompositePolicyType type;

  /// The scope at which the composite policy should be evaluated.
  @override
  final PolicyScope? scope;

  /// Creates a new [CompositePolicy] instance.
  ///
  /// [name] is the unique name of the composite policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [policies] is the list of policies to evaluate.
  /// [type] is the type of composite policy that determines how the policies are evaluated.
  /// [scope] is the scope at which the policy should be evaluated.
  CompositePolicy({
    required this.name,
    required this.description,
    required this.policies,
    required this.type,
    this.scope,
  });

  /// Evaluates the composite policy against an entity.
  ///
  /// This method evaluates all policies in the [policies] list according to the
  /// [type] of composite policy. The evaluation strategy is:
  /// - [CompositePolicyType.all]: Returns true only if all policies pass
  /// - [CompositePolicyType.any]: Returns true if at least one policy passes
  /// - [CompositePolicyType.none]: Returns true if no policies pass
  /// - [CompositePolicyType.majority]: Returns true if more than half of the policies pass
  ///
  /// [entity] is the entity to evaluate the policy against.
  /// Returns true if the policy evaluation passes according to the composite type.
  @override
  bool evaluate(Entity entity) {
    int passCount = 0;
    int failCount = 0;

    for (var policy in policies) {
      var mergedScope = scope?.merge(policy.scope) ?? policy.scope;
      if (mergedScope != null && !mergedScope.isWithinScope(entity)) continue;
      if (policy.evaluate(entity)) {
        passCount++;
      } else {
        failCount++;
      }
    }

    switch (type) {
      case CompositePolicyType.all:
        return failCount == 0;
      case CompositePolicyType.any:
        return passCount > 0;
      case CompositePolicyType.none:
        return passCount == 0;
      case CompositePolicyType.majority:
        return passCount > failCount;
    }
  }

  /// Evaluates the composite policy against an entity and returns detailed results.
  ///
  /// This method evaluates all policies in the [policies] list according to the
  /// [type] of composite policy, collecting any policy violations that occur.
  /// The evaluation strategy is the same as [evaluate], but this method provides
  /// more detailed information about why the evaluation failed.
  ///
  /// [entity] is the entity to evaluate the policy against.
  /// Returns a [PolicyEvaluationResult] containing the success status and any violations.
  @override
  PolicyEvaluationResult evaluateWithDetails(Entity entity) {
    List<PolicyViolation> violations = [];
    int passCount = 0;
    int failCount = 0;

    for (var policy in policies) {
      var mergedScope = scope?.merge(policy.scope) ?? policy.scope;
      if (mergedScope != null && !mergedScope.isWithinScope(entity)) continue;
      var result = policy.evaluateWithDetails(entity);
      if (result.success) {
        passCount++;
        if (type == CompositePolicyType.any) {
          return PolicyEvaluationResult(true, []);
        }
      } else {
        failCount++;
        violations.addAll(result.violations);
        if (type == CompositePolicyType.any) {
          break;
        }
      }
    }

    bool success;
    switch (type) {
      case CompositePolicyType.all:
        success = failCount == 0;
        break;
      case CompositePolicyType.any:
        success = passCount > 0;
        break;
      case CompositePolicyType.none:
        success = passCount == 0;
        break;
      case CompositePolicyType.majority:
        success = passCount > failCount;
        break;
    }

    return PolicyEvaluationResult(success, violations);
  }
}

/// Defines the different types of composite policy evaluation strategies.
///
/// The [CompositePolicyType] enum defines how multiple policies should be
/// evaluated in a [CompositePolicy]:
/// - [all]: All policies must pass for the composite policy to pass
/// - [any]: At least one policy must pass for the composite policy to pass
/// - [none]: No policies should pass for the composite policy to pass
/// - [majority]: More than half of the policies must pass for the composite policy to pass
enum CompositePolicyType {
  /// All policies must pass for the composite policy to pass.
  all,

  /// At least one policy must pass for the composite policy to pass.
  any,

  /// No policies should pass for the composite policy to pass.
  none,

  /// More than half of the policies must pass for the composite policy to pass.
  majority
}


========================================

=== policy/entity_policies.dart ===

part of ednet_core;

// part of ednet_core;
//
// abstract class EntityPolicies {
//   List<EntityPolicy> get policies;
//
//   set policies(List<EntityPolicy> value);
// }


========================================

=== policy/entity_policy_factory.dart ===

part of ednet_core;

// part of ednet_core;
//
// abstract class EntityPolicyFactory {
//   EntityPolicy getPolicy();
// }


========================================

=== policy/i_event_triggered_policy.dart ===

part of ednet_core;

/// Defines a policy that can be triggered by domain events
///
/// Event triggered policies allow for reactive behavior in the domain model,
/// responding to events and potentially generating new commands to continue
/// the workflow.
///
/// A common pattern in DDD is:
/// 1. Command is executed on an AggregateRoot
/// 2. AggregateRoot emits Events
/// 3. Events trigger Policies
/// 4. Policies generate Commands
/// 5. Commands are executed on AggregateRoots (cycle continues)
///
/// Example usage:
/// ```dart
/// class OrderShippedNotificationPolicy implements Policy, IEventTriggeredPolicy {
///   @override
///   String get name => 'OrderShippedNotification';
///
///   @override
///   bool evaluate(Entity entity) {
///     // This policy applies to Order entities
///     return entity is Order;
///   }
///
///   @override
///   bool shouldTriggerOnEvent(Event event) {
///     // This policy triggers on the OrderShipped event
///     return event.name == 'OrderShipped';
///   }
///
///   @override
///   void executeActions(Entity entity, Event event) {
///     // Send notification logic
///     print('Notification: Order ${entity.id} has been shipped with tracking ${event.data['trackingNumber']}');
///   }
///
///   @override
///   List<dynamic> generateCommands(Entity entity, Event event) {
///     // Generate command to update shipping status in reporting system
///     return [
///       UpdateShippingStatusCommand(
///         orderId: entity.id,
///         status: 'Shipped',
///         trackingNumber: event.data['trackingNumber'],
///       )
///     ];
///   }
/// }
/// ```
abstract class IEventTriggeredPolicy {
  /// Determines if this policy should trigger in response to the given event
  ///
  /// Parameters:
  /// - [event]: The event to evaluate
  ///
  /// Returns:
  /// True if this policy should be triggered by the event, false otherwise
  bool shouldTriggerOnEvent(dynamic event);

  /// Executes actions when the policy is triggered
  ///
  /// This method contains the core business logic for the policy,
  /// and is executed when an event triggers the policy.
  ///
  /// Parameters:
  /// - [entity]: The entity associated with the event
  /// - [event]: The event that triggered the policy
  void executeActions(dynamic entity, dynamic event);

  /// Generates commands to be executed after the policy is triggered
  ///
  /// This allows policies to trigger additional actions in the system
  /// by generating commands to be executed.
  ///
  /// Parameters:
  /// - [entity]: The entity associated with the event
  /// - [event]: The event that triggered the policy
  ///
  /// Returns:
  /// A list of commands to be executed
  List<dynamic> generateCommands(dynamic entity, dynamic event);
}


========================================

=== policy/i_policy.dart ===

part of ednet_core;

/// Interface for domain policies that define business rules and constraints.
///
/// The [IPolicy] interface defines the contract for domain policies that can be
/// evaluated against domain entities. A policy represents a business rule or
/// constraint that must be satisfied by entities in the domain model.
///
/// Example usage:
/// ```dart
/// class PricePolicy implements IPolicy {
///   @override
///   String get name => 'PricePolicy';
///
///   @override
///   String get description => 'Product price must be positive';
///
///   @override
///   PolicyScope? get scope => PolicyScope.entity;
///
///   @override
///   bool evaluate(Entity entity) {
///     final price = entity.getAttribute('price') as double?;
///     return price != null && price > 0;
///   }
///
///   @override
///   PolicyEvaluationResult evaluateWithDetails(Entity entity) {
///     final result = evaluate(entity);
///     return PolicyEvaluationResult(
///       result,
///       result ? [] : [PolicyViolation(name, description)],
///     );
///   }
/// }
/// ```
abstract class IPolicy {
  /// Gets the unique name of this policy.
  String get name;

  /// Gets a human-readable description of what this policy enforces.
  String get description;

  /// Gets the scope at which this policy should be evaluated.
  /// If null, the policy can be evaluated at any scope.
  PolicyScope? get scope;

  /// Evaluates this policy against the given entity.
  ///
  /// [entity] is the entity to evaluate.
  /// Returns true if the policy is satisfied, false otherwise.
  bool evaluate(Entity entity);

  /// Evaluates this policy against the given entity and returns detailed results.
  ///
  /// [entity] is the entity to evaluate.
  /// Returns a [PolicyEvaluationResult] containing the evaluation result and any violations.
  PolicyEvaluationResult evaluateWithDetails(Entity entity);
}

/// A concrete implementation of [IPolicy] that uses a function for evaluation.
///
/// The [Policy] class provides a simple way to create policies by providing
/// a function that evaluates an entity.
///
/// Example usage:
/// ```dart
/// final pricePolicy = Policy(
///   'PricePolicy',
///   'Product price must be positive',
///   (entity) {
///     final price = entity.getAttribute('price') as double?;
///     return price != null && price > 0;
///   },
///   scope: PolicyScope.entity,
/// );
/// ```
class Policy implements IPolicy {
  @override
  final String name;

  @override
  final String description;

  /// The function that evaluates the policy.
  bool Function(Entity) _evaluationFunction;

  /// Creates a new [Policy] instance.
  ///
  /// [name] is the unique name of the policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [_evaluationFunction] is the function that evaluates the policy.
  /// [scope] is the scope at which the policy should be evaluated.
  Policy(this.name, this.description, this._evaluationFunction, {this.scope});

  @override
  bool evaluate(Entity entity) {
    return _evaluationFunction(entity);
  }

  @override
  PolicyEvaluationResult evaluateWithDetails(Entity entity) {
    bool result = evaluate(entity);
    return PolicyEvaluationResult(
        result,
        result
            ? []
            : [
                PolicyViolation(
                  name,
                  description,
                )
              ]);
  }

  @override
  PolicyScope? scope;
}

/// A concrete implementation of [IPolicy] that uses an expression for evaluation.
///
/// The [PolicyWithDependencies] class allows policies to be defined using
/// expressions that reference entity attributes. It automatically handles
/// dependency tracking and evaluation.
///
/// Example usage:
/// ```dart
/// final pricePolicy = PolicyWithDependencies(
///   'PricePolicy',
///   'Product price must be positive',
///   'price > 0',
///   {'price'},
///   scope: PolicyScope.entity,
/// );
/// ```
class PolicyWithDependencies implements IPolicy {
  final String name;
  final String description;
  final String expression;
  final Set<String> dependencies;

  /// Creates a new [PolicyWithDependencies] instance.
  ///
  /// [name] is the unique name of the policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [expression] is the expression to evaluate.
  /// [dependencies] is the set of attribute names that the expression depends on.
  /// [scope] is the scope at which the policy should be evaluated.
  PolicyWithDependencies(
      this.name, this.description, this.expression, this.dependencies,
      {this.scope});

  @override
  bool evaluate(Entity entity) {
    final evaluator = ExpressionEvaluator();
    final exp = Expression.parse(expression);

    final context = <String, dynamic>{};
    for (var dep in dependencies) {
      context[dep] = entity.getAttribute(dep);
    }

    try {
      return evaluator.eval(exp, context) as bool;
    } catch (e) {
      print('Error evaluating policy $name: $e');
      return false;
    }
  }

  @override
  PolicyEvaluationResult evaluateWithDetails(Entity entity) {
    bool result = evaluate(entity);
    return PolicyEvaluationResult(
        result,
        result
            ? []
            : [
                PolicyViolation(
                  name,
                  'Evaluation failed',
                )
              ]);
  }

  @override
  PolicyScope? scope;
}


========================================

=== policy/policy_engine.dart ===

part of ednet_core;

/// A class that manages and executes domain policies.
///
/// The [PolicyEngine] class is responsible for:
/// - Managing a collection of domain policies
/// - Determining which policies apply to a given entity
/// - Executing applicable policies in the correct order
/// - Handling event-triggered policies
/// - Managing the policy-command-event cycle
///
/// The engine can be associated with a [DomainSession] to provide context
/// for policy execution and access to domain services.
///
/// Example usage:
/// ```dart
/// final engine = PolicyEngine(session);
///
/// // Add policies
/// engine.addPolicy(PricePolicy());
/// engine.addPolicy(OrderShippedNotificationPolicy());
///
/// // Execute policies for an entity
/// engine.executePolicies(product);
///
/// // Process an event through policies
/// engine.processEvent(orderShippedEvent);
/// ```
class PolicyEngine {
  /// The list of policies managed by this engine.
  final List<Policy> _policies = [];

  /// The domain session associated with this engine.
  /// Provides context and access to domain services.
  final dynamic _session;

  /// Creates a new [PolicyEngine] instance.
  ///
  /// [session] is the domain session to associate with this engine.
  /// If null, the engine will operate without session context.
  PolicyEngine(this._session);

  /// Gets the domain session
  dynamic get session => _session;

  /// Adds a policy to this engine.
  ///
  /// [policy] is the policy to add.
  /// The policy will be evaluated when [executePolicies] is called.
  void addPolicy(Policy policy) {
    _policies.add(policy);
  }

  /// Adds multiple policies to this engine.
  ///
  /// [policies] is the list of policies to add.
  void addPolicies(List<Policy> policies) {
    _policies.addAll(policies);
  }

  /// Remove a policy from this engine.
  ///
  /// [policy] is the policy to remove.
  void removePolicy(Policy policy) {
    _policies.remove(policy);
  }

  /// Gets all policies registered with this engine.
  List<Policy> get policies => List.unmodifiable(_policies);

  /// Gets all policies that apply to the given entity.
  ///
  /// [entity] is the entity to check policies against.
  /// Returns a list of policies that evaluate to true for the entity.
  List<Policy> getApplicablePolicies(Entity entity) {
    return _policies.where((policy) => policy.evaluate(entity)).toList();
  }

  /// Helper method to check if a policy supports event triggering
  bool _isEventTriggeredPolicy(Policy policy) {
    return policy != null &&
        policy is Policy &&
        (policy as dynamic).shouldTriggerOnEvent != null &&
        (policy as dynamic).executeActions != null &&
        (policy as dynamic).generateCommands != null;
  }

  /// Gets all event-triggered policies that apply to the given entity and should
  /// trigger on the specified event.
  ///
  /// [entity] is the entity to check policies against.
  /// [event] is the event to check triggering conditions against.
  /// Returns a list of event-triggered policies that apply.
  List<Policy> getTriggeredPolicies(Entity entity, Event event) {
    return _policies
        .where(
          (policy) =>
              _isEventTriggeredPolicy(policy) &&
              policy.evaluate(entity) &&
              (policy as dynamic).shouldTriggerOnEvent(event),
        )
        .toList();
  }

  /// Executes all applicable policies for the given entity.
  ///
  /// [entity] is the entity to execute policies for.
  /// This method:
  /// 1. Gets all applicable policies using [getApplicablePolicies]
  /// 2. Executes each policy in sequence
  /// 3. Collects commands generated by policies
  /// 4. Returns the list of generated commands
  ///
  /// Returns a list of commands generated by executed policies
  List<dynamic> executePolicies(Entity entity) {
    final List<dynamic> generatedCommands = [];

    final applicablePolicies = getApplicablePolicies(entity);
    for (var policy in applicablePolicies) {
      // Standard policies don't generate commands
      if (!_isEventTriggeredPolicy(policy)) continue;

      // For event-triggered policies, we need an event
      // Here we're creating a synthetic event for demonstration
      final event = Event(
        'PolicyEvaluation',
        'Policy evaluation triggered by direct execution',
        [],
        entity,
      );

      // Skip if policy shouldn't trigger on this synthetic event
      if (!(policy as dynamic).shouldTriggerOnEvent(event)) continue;

      // Execute policy actions
      (policy as dynamic).executeActions(entity, event);

      // Collect commands
      final commands = (policy as dynamic).generateCommands(entity, event);
      generatedCommands.addAll(commands);
    }

    return generatedCommands;
  }

  /// Processes an event through applicable policies and returns generated commands.
  ///
  /// This method:
  /// 1. Finds policies that apply to the entity and should trigger on the event
  /// 2. Executes policy actions
  /// 3. Collects commands generated by policies
  /// 4. Returns the list of generated commands
  ///
  /// [entity] is the entity associated with the event
  /// [event] is the event to process
  ///
  /// Returns a list of commands generated by triggered policies
  List<dynamic> processEvent(Entity entity, Event event) {
    final List<dynamic> generatedCommands = [];

    final triggeredPolicies = getTriggeredPolicies(entity, event);
    for (var policy in triggeredPolicies) {
      if (!_isEventTriggeredPolicy(policy)) continue;

      // Execute policy actions
      (policy as dynamic).executeActions(entity, event);

      // Collect commands
      final commands = (policy as dynamic).generateCommands(entity, event);
      generatedCommands.addAll(commands);
    }

    return generatedCommands;
  }

  /// Executes commands generated by policies.
  ///
  /// This method executes commands on aggregate roots,
  /// resulting in new events that can trigger more policies,
  /// continuing the command-event-policy cycle.
  ///
  /// [commands] is the list of commands to execute
  /// [aggregateRoot] is the aggregate root to execute commands on
  ///
  /// Returns a list of results from command execution
  List<dynamic> executeGeneratedCommands(
    List<dynamic> commands,
    dynamic aggregateRoot,
  ) {
    final List<dynamic> results = [];

    for (var command in commands) {
      // Check if the aggregateRoot has the executeCommand method
      if (aggregateRoot.executeCommand == null) {
        continue;
      }

      final result = aggregateRoot.executeCommand(command);
      results.add(result);

      // If command succeeded, process events it generated
      if (result.isSuccess == true &&
          aggregateRoot.pendingEvents != null &&
          aggregateRoot.pendingEvents.isNotEmpty) {
        for (var event in aggregateRoot.pendingEvents) {
          // Process event through policies, potentially generating more commands
          final newCommands = processEvent(aggregateRoot, event);

          // Recursively execute those commands if there are any
          if (newCommands.isNotEmpty) {
            executeGeneratedCommands(newCommands, aggregateRoot);
          }
        }

        // Mark events as processed if method exists
        if (aggregateRoot.markEventsAsProcessed != null) {
          aggregateRoot.markEventsAsProcessed();
        }
      }
    }

    return results;
  }
}


========================================

=== policy/policy_evaluation_tracer.dart ===

part of ednet_core;

/// A tracer for tracking the evaluation of policies and their checks.
///
/// The [PolicyEvaluationTracer] class provides detailed tracing of:
/// - Policy evaluation start and end
/// - Attribute value checks
/// - Relationship value checks
/// - Nested policy evaluations through depth tracking
///
/// Example usage:
/// ```dart
/// final tracer = PolicyEvaluationTracer();
///
/// // Start policy evaluation
/// tracer.startEvaluation('pricePolicy', product);
///
/// // Add attribute check
/// tracer.addAttributeCheck('price', 100.0, true);
///
/// // Add relationship check
/// tracer.addRelationshipCheck('category', electronics, true);
///
/// // End policy evaluation
/// tracer.endEvaluation('pricePolicy', true);
///
/// // Get trace output
/// print(tracer.getTrace());
/// ```
class PolicyEvaluationTracer {
  /// The list of trace entries recording the evaluation process.
  final List<TraceEntry> _traceEntries = [];

  /// The current nesting depth of policy evaluations.
  int _depth = 0;

  /// Records the start of a policy evaluation.
  ///
  /// [policyName] is the name of the policy being evaluated.
  /// [entity] is the entity being evaluated.
  void startEvaluation(String policyName, Entity entity) {
    _traceEntries.add(TraceEntry(
      type: TraceEntryType.start,
      policyName: policyName,
      entityInfo: '${entity.concept.code}(${entity.oid})',
      depth: _depth,
    ));
    _depth++;
  }

  /// Records the end of a policy evaluation.
  ///
  /// [policyName] is the name of the policy being evaluated.
  /// [result] indicates whether the policy evaluation passed.
  void endEvaluation(String policyName, bool result) {
    _depth--;
    _traceEntries.add(TraceEntry(
      type: TraceEntryType.end,
      policyName: policyName,
      result: result,
      depth: _depth,
    ));
  }

  /// Records an attribute value check.
  ///
  /// [attributeName] is the name of the attribute being checked.
  /// [value] is the value being checked.
  /// [result] indicates whether the check passed.
  void addAttributeCheck(String attributeName, dynamic value, bool result) {
    _traceEntries.add(TraceEntry(
      type: TraceEntryType.attributeCheck,
      attributeName: attributeName,
      attributeValue: value,
      result: result,
      depth: _depth,
    ));
  }

  /// Records a relationship value check.
  ///
  /// [relationshipName] is the name of the relationship being checked.
  /// [value] is the value being checked.
  /// [result] indicates whether the check passed.
  void addRelationshipCheck(
      String relationshipName, dynamic value, bool result) {
    _traceEntries.add(TraceEntry(
      type: TraceEntryType.relationshipCheck,
      relationshipName: relationshipName,
      relationshipValue: value,
      result: result,
      depth: _depth,
    ));
  }

  /// Gets the formatted trace output as a string.
  ///
  /// Returns a string containing all trace entries with proper indentation.
  String getTrace() {
    StringBuffer buffer = StringBuffer();
    for (var entry in _traceEntries) {
      buffer.writeln(entry.toString());
    }
    return buffer.toString();
  }

  /// Clears all trace entries and resets the depth counter.
  void clear() {
    _traceEntries.clear();
    _depth = 0;
  }
}

/// Types of entries that can be recorded in the policy evaluation trace.
///
/// The [TraceEntryType] enum defines the different types of events that can be
/// traced during policy evaluation:
/// - [start]: Beginning of a policy evaluation
/// - [end]: End of a policy evaluation
/// - [attributeCheck]: Check of an attribute value
/// - [relationshipCheck]: Check of a relationship value
enum TraceEntryType { start, end, attributeCheck, relationshipCheck }

/// Represents a single entry in the policy evaluation trace.
///
/// The [TraceEntry] class captures all information about a traced event:
/// - The type of event
/// - Policy name (for start/end events)
/// - Entity information (for start events)
/// - Attribute/relationship details (for check events)
/// - Evaluation results
/// - Nesting depth
///
/// Example usage:
/// ```dart
/// final entry = TraceEntry(
///   type: TraceEntryType.attributeCheck,
///   attributeName: 'price',
///   attributeValue: 100.0,
///   result: true,
///   depth: 1,
/// );
/// print(entry.toString()); // "  • Attribute check: price = 100.0 (Passed)"
/// ```
class TraceEntry {
  /// The type of trace entry.
  final TraceEntryType type;

  /// The name of the policy being evaluated (for start/end events).
  final String? policyName;

  /// Information about the entity being evaluated (for start events).
  final String? entityInfo;

  /// The name of the attribute being checked (for attribute check events).
  final String? attributeName;

  /// The value of the attribute being checked (for attribute check events).
  final dynamic attributeValue;

  /// The name of the relationship being checked (for relationship check events).
  final String? relationshipName;

  /// The value of the relationship being checked (for relationship check events).
  final dynamic relationshipValue;

  /// The result of the check or evaluation (for end/check events).
  final bool? result;

  /// The nesting depth of this entry in the trace.
  final int depth;

  /// Creates a new [TraceEntry] instance.
  ///
  /// [type] is the type of trace entry.
  /// [policyName] is the name of the policy (for start/end events).
  /// [entityInfo] is information about the entity (for start events).
  /// [attributeName] is the name of the attribute (for attribute check events).
  /// [attributeValue] is the value of the attribute (for attribute check events).
  /// [relationshipName] is the name of the relationship (for relationship check events).
  /// [relationshipValue] is the value of the relationship (for relationship check events).
  /// [result] is the result of the check/evaluation (for end/check events).
  /// [depth] is the nesting depth of this entry.
  TraceEntry({
    required this.type,
    this.policyName,
    this.entityInfo,
    this.attributeName,
    this.attributeValue,
    this.relationshipName,
    this.relationshipValue,
    this.result,
    required this.depth,
  });

  /// Returns a formatted string representation of this trace entry.
  ///
  /// The output is indented based on the depth and includes all relevant
  /// information in a human-readable format.
  @override
  String toString() {
    String indent = '  ' * depth;
    switch (type) {
      case TraceEntryType.start:
        return '$indent► Starting evaluation of $policyName for $entityInfo';
      case TraceEntryType.end:
        return '$indent◄ Ending evaluation of $policyName: ${result! ? 'Passed' : 'Failed'}';
      case TraceEntryType.attributeCheck:
        return '$indent• Attribute check: $attributeName = $attributeValue (${result! ? 'Passed' : 'Failed'})';
      case TraceEntryType.relationshipCheck:
        return '$indent• Relationship check: $relationshipName = $relationshipValue (${result! ? 'Passed' : 'Failed'})';
    }
  }
}


========================================

=== policy/policy_evaluator.dart ===

part of ednet_core;

/// Evaluates domain policies against entities and provides detailed evaluation results.
///
/// The [PolicyEvaluator] class is responsible for:
/// - Evaluating individual policies or all applicable policies
/// - Tracking policy evaluation through a tracer
/// - Handling policy scope and exceptions
/// - Providing detailed evaluation results and violations
///
/// Example usage:
/// ```dart
/// final registry = PolicyRegistry();
/// final evaluator = PolicyEvaluator(registry);
///
/// // Evaluate a specific policy
/// final result = evaluator.evaluate(product, policyKey: 'pricePolicy');
/// if (!result.success) {
///   print('Policy violations: ${result.violations}');
/// }
///
/// // Evaluate all applicable policies
/// final allResults = evaluator.evaluate(product);
///
/// // Get evaluation trace
/// print(evaluator.getEvaluationTrace());
/// ```
class PolicyEvaluator {
  /// The registry containing all available policies.
  final PolicyRegistry _policyRegistry;

  /// The tracer for tracking policy evaluation.
  final PolicyEvaluationTracer _tracer;

  /// Creates a new [PolicyEvaluator] instance.
  ///
  /// [_policyRegistry] is the registry containing the policies to evaluate.
  PolicyEvaluator(this._policyRegistry) : _tracer = PolicyEvaluationTracer();

  /// Evaluates policies against the given entity.
  ///
  /// [entity] is the entity to evaluate.
  /// [policyKey] is an optional key to evaluate a specific policy.
  /// Returns a [PolicyEvaluationResult] containing the evaluation results.
  PolicyEvaluationResult evaluate(Entity entity, {String? policyKey}) {
    _tracer.clear();

    if (policyKey != null) {
      return _evaluateSinglePolicy(entity, policyKey);
    } else {
      return _evaluateAllPolicies(entity);
    }
  }

  /// Evaluates a single policy against the given entity.
  ///
  /// [entity] is the entity to evaluate.
  /// [policyKey] is the key of the policy to evaluate.
  /// Returns a [PolicyEvaluationResult] containing the evaluation results.
  PolicyEvaluationResult _evaluateSinglePolicy(
      Entity entity, String policyKey) {
    try {
      var policy = _policyRegistry.getPolicy(policyKey);
      if (policy == null) {
        return PolicyEvaluationResult(false, [
          PolicyViolation(policyKey, 'Policy not found'),
        ]);
      }

      _tracer.startEvaluation(policy.name, entity);

      if (policy.scope != null && !policy.scope!.isWithinScope(entity)) {
        _tracer.endEvaluation(policy.name, false);
        return PolicyEvaluationResult(true, []);
      }

      var details = policy.evaluateWithDetails(entity);
      _tracer.endEvaluation(policy.name, true);

      return details;
    } catch (e) {
      return PolicyEvaluationResult(
        false,
        [PolicyViolation(policyKey, 'Error during evaluation: $e')],
      );
    }
  }

  /// Evaluates all applicable policies against the given entity.
  ///
  /// [entity] is the entity to evaluate.
  /// Returns a [PolicyEvaluationResult] containing all violations.
  PolicyEvaluationResult _evaluateAllPolicies(Entity entity) {
    var violations = <PolicyViolation>[];
    for (var policy in _policyRegistry.getAllPolicies()) {
      _tracer.startEvaluation(policy.name, entity);

      if (policy.scope == null || policy.scope!.isWithinScope(entity)) {
        var result = policy.evaluateWithDetails(entity);
        if (!result.success) {
          violations.addAll(result.violations);
        }
        _tracer.endEvaluation(policy.name, violations.isEmpty);
      } else {
        _tracer.endEvaluation(policy.name, false);
      }
    }
    return PolicyEvaluationResult(violations.isEmpty, violations);
  }

  /// Gets the evaluation trace as a string.
  ///
  /// Returns a formatted string containing the evaluation history.
  String getEvaluationTrace() {
    return _tracer.getTrace();
  }
}

/// Represents the result of evaluating one or more policies.
///
/// The [PolicyEvaluationResult] class contains:
/// - Whether the evaluation was successful
/// - Any policy violations that occurred
///
/// Example usage:
/// ```dart
/// final result = evaluator.evaluate(entity);
/// if (!result.success) {
///   print('Violations: ${result.violations}');
/// }
/// ```
class PolicyEvaluationResult {
  /// Whether all evaluated policies passed.
  final bool success;

  /// The list of policy violations that occurred.
  final List<PolicyViolation> violations;

  /// Creates a new [PolicyEvaluationResult] instance.
  ///
  /// [success] indicates whether all policies passed.
  /// [violations] is the list of policy violations that occurred.
  PolicyEvaluationResult(this.success, this.violations);
}

/// Represents a single policy violation.
///
/// The [PolicyViolation] class contains:
/// - The key of the violated policy
/// - A message describing the violation
///
/// Example usage:
/// ```dart
/// final violation = PolicyViolation('pricePolicy', 'Price must be positive');
/// print(violation.toString()); // "Policy "pricePolicy" violated: Price must be positive"
/// ```
class PolicyViolation {
  /// The key of the violated policy.
  final String policyKey;

  /// A message describing the violation.
  final String message;

  /// Creates a new [PolicyViolation] instance.
  ///
  /// [policyKey] is the key of the violated policy.
  /// [message] is a description of the violation.
  PolicyViolation(this.policyKey, this.message);

  /// Returns a string representation of this violation.
  @override
  String toString() => 'Policy "$policyKey" violated: $message';
}


========================================

=== policy/policy_registry.dart ===

part of ednet_core;

/// A registry for managing domain policies.
///
/// The [PolicyRegistry] class provides a central location for registering, retrieving,
/// and evaluating domain policies. It maintains a map of policy keys to their implementations
/// and provides methods for policy management and evaluation.
///
/// Example usage:
/// ```dart
/// final registry = PolicyRegistry();
///
/// // Register a policy
/// registry.registerPolicy('pricePolicy', pricePolicy);
///
/// // Evaluate a specific policy
/// if (!registry.evaluateNamedPolicy('pricePolicy', product)) {
///   print('Price policy violation');
/// }
///
/// // Evaluate all applicable policies
/// final violations = registry.evaluateAllPolicies(product);
/// ```
class PolicyRegistry {
  /// Internal map of policy keys to their implementations.
  final Map<String, IPolicy> _policies = {};

  /// Registers a policy with the given key.
  ///
  /// [key] is the unique identifier for the policy.
  /// [policy] is the policy implementation to register.
  /// Throws [PolicyRegistrationException] if a policy with the same key already exists.
  void registerPolicy(String key, IPolicy policy) {
    if (_policies.containsKey(key)) {
      throw PolicyRegistrationException('Policy with key "$key" already exists.');
    }
    _policies[key] = policy;
  }

  /// Retrieves a policy by its key.
  ///
  /// [key] is the unique identifier of the policy to retrieve.
  /// Returns the policy if found, null otherwise.
  IPolicy? getPolicy(String key) => _policies[key];

  /// Removes a policy from the registry.
  ///
  /// [key] is the unique identifier of the policy to remove.
  void removePolicy(String key) {
    _policies.remove(key);
  }

  /// Returns all registered policies.
  ///
  /// Returns a list of all policy implementations.
  List<IPolicy> getAllPolicies() => _policies.values.toList();

  /// Evaluates a specific policy against an entity.
  ///
  /// [key] is the unique identifier of the policy to evaluate.
  /// [entity] is the entity to evaluate.
  /// Returns true if the policy is satisfied, false otherwise.
  /// Throws [PolicyNotFoundException] if the policy is not found.
  /// Skips evaluation if the entity is outside the policy's scope.
  bool evaluateNamedPolicy(String key, Entity entity) {
    var policy = getPolicy(key);
    if (policy == null) {
      throw PolicyNotFoundException('Policy not found: $key');
    }
    if (policy.scope != null && !policy.scope!.isWithinScope(entity)) {
      return true; // Skip evaluation for entities out of scope
    }
    return policy.evaluate(entity);
  }

  /// Evaluates all applicable policies against an entity.
  ///
  /// [entity] is the entity to evaluate.
  /// Returns a list of policy keys that were violated.
  /// Only evaluates policies whose scope includes the entity.
  List<String> evaluateAllPolicies(Entity entity) {
    return _policies.entries
        .where((entry) => entry.value.scope == null || entry.value.scope!.isWithinScope(entity))
        .map((entry) => entry.value.evaluateWithDetails(entity))
        .expand((result) => result.violations)
        .map((violation) => violation.policyKey)
        .toList();
  }

  /// Removes all policies from the registry.
  void clear() {
    _policies.clear();
  }
}

/// Exception thrown when attempting to register a policy with a key that already exists.
///
/// Example usage:
/// ```dart
/// try {
///   registry.registerPolicy('existingKey', policy);
/// } on PolicyRegistrationException catch (e) {
///   print('Registration failed: ${e.toString()}');
/// }
/// ```
class PolicyRegistrationException implements Exception {
  /// The error message describing the registration failure.
  final String message;

  /// Creates a new [PolicyRegistrationException] instance.
  ///
  /// [message] is the error message describing the registration failure.
  PolicyRegistrationException(this.message);

  /// Returns a string representation of this exception.
  @override
  String toString() => 'PolicyRegistrationException: $message';
}

/// Exception thrown when attempting to evaluate a policy that doesn't exist.
///
/// Example usage:
/// ```dart
/// try {
///   registry.evaluateNamedPolicy('nonexistentKey', entity);
/// } on PolicyNotFoundException catch (e) {
///   print('Evaluation failed: ${e.toString()}');
/// }
/// ```
class PolicyNotFoundException implements Exception {
  /// The error message describing the policy not found error.
  final String message;

  /// Creates a new [PolicyNotFoundException] instance.
  ///
  /// [message] is the error message describing the policy not found error.
  PolicyNotFoundException(this.message);

  /// Returns a string representation of this exception.
  @override
  String toString() => 'PolicyNotFoundException: $message';
}


========================================

=== policy/policy_scope.dart ===

part of ednet_core;

/// Defines the scope of applicability for domain policies.
///
/// The [PolicyScope] class determines when a policy should be applied by specifying:
/// - Which domain concepts the policy applies to
/// - What conditions must be met for the policy to be applicable
///
/// Example usage:
/// ```dart
/// // Create a scope that applies to all products
/// final productScope = PolicyScope({'Product'});
///
/// // Create a scope that applies to active products
/// final activeProductScope = PolicyScope(
///   {'Product'},
///   {'status': 'active'},
/// );
///
/// // Check if an entity is within scope
/// if (productScope.isWithinScope(productEntity)) {
///   // Apply policy...
/// }
///
/// // Merge two scopes
/// final mergedScope = productScope.merge(activeProductScope);
/// ```
class PolicyScope {
  /// The set of concept codes that this scope applies to.
  /// If empty, the scope applies to all concepts.
  final Set<String> applicableConcepts;

  /// A map of attribute conditions that must be met for the scope to apply.
  /// Key: attribute code; Value: expected attribute value.
  final Map<String, dynamic> conditions;

  /// Creates a new [PolicyScope] instance.
  ///
  /// [applicableConcepts] is the set of concept codes that this scope applies to.
  /// [conditions] is an optional map of attribute conditions that must be met.
  PolicyScope(this.applicableConcepts, [this.conditions = const {}]);

  /// Checks if the given entity is within this scope.
  ///
  /// [entity] is the entity to check.
  /// Returns true if:
  /// 1. The entity's concept is in [applicableConcepts] (or [applicableConcepts] is empty)
  /// 2. All conditions in [conditions] are satisfied by the entity's attributes
  bool isWithinScope(Entity entity) {
    if (applicableConcepts.isNotEmpty &&
        !applicableConcepts.contains(entity.concept.code)) {
      return false;
    }
    for (var entry in conditions.entries) {
      if (entity.getAttribute(entry.key) != entry.value) {
        return false;
      }
    }
    return true;
  }

  /// Merges this scope with another scope.
  ///
  /// [other] is the scope to merge with. If null, returns this scope.
  /// Returns a new scope that:
  /// 1. Applies to the union of both scopes' applicable concepts
  /// 2. Requires all conditions from both scopes to be met
  PolicyScope merge(PolicyScope? other) {
    if (other == null) return this;
    return PolicyScope(
      applicableConcepts.union(other.applicableConcepts),
      {...conditions, ...other.conditions},
    );
  }
}


========================================

=== policy/policy_violation_exception.dart ===

part of ednet_core;

/// Exception thrown when one or more domain policies are violated.
///
/// The [PolicyViolationException] class represents a collection of policy violations
/// that occurred during policy evaluation. It provides a way to aggregate multiple
/// violations and present them in a human-readable format.
///
/// Example usage:
/// ```dart
/// try {
///   final result = policy.evaluateWithDetails(entity);
///   if (!result.isValid) {
///     throw PolicyViolationException(result.violations);
///   }
/// } on PolicyViolationException catch (e) {
///   print('Policy violations found: ${e.toString()}');
/// }
/// ```
class PolicyViolationException implements Exception {
  /// The list of policy violations that occurred.
  final List<PolicyViolation> violations;

  /// Creates a new [PolicyViolationException] instance.
  ///
  /// [violations] is the list of policy violations that occurred.
  PolicyViolationException(this.violations);

  /// Returns a string representation of this exception.
  ///
  /// The string includes all policy violations, separated by commas.
  @override
  String toString() {
    return 'Policy violations: ${violations.map((v) => v.toString()).join(", ")}';
  }
}


========================================

=== policy/relationship_policy.dart ===

part of ednet_core;

/// A policy that validates relationships between entities.
///
/// The [RelationshipPolicy] class extends [Policy] to provide specialized validation
/// for entity relationships. It can validate:
/// - Parent-child relationships
/// - Relationship existence
/// - Relationship cardinality
/// - Relationship attribute values
///
/// Example usage:
/// ```dart
/// final categoryPolicy = RelationshipPolicy(
///   name: 'CategoryPolicy',
///   description: 'Product must have a valid category',
///   relationshipName: 'category',
///   relationshipType: RelationshipType.parent,
///   validator: RelationshipValidators.isNotNull,
/// );
///
/// final minChildrenPolicy = RelationshipPolicy(
///   name: 'MinChildrenPolicy',
///   description: 'Category must have at least 3 products',
///   relationshipName: 'products',
///   relationshipType: RelationshipType.child,
///   validator: RelationshipValidators.hasMinimumChildren(3),
/// );
/// ```
class RelationshipPolicy extends Policy {
  /// The name of the relationship to validate.
  final String relationshipName;

  /// The type of relationship to validate (parent or child).
  final RelationshipType relationshipType;

  /// The function that validates the relationship.
  final bool Function(Entity, dynamic) validator;

  /// Creates a new [RelationshipPolicy] instance.
  ///
  /// [name] is the unique name of the policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [relationshipName] is the name of the relationship to validate.
  /// [relationshipType] is the type of relationship to validate.
  /// [validator] is the function that validates the relationship.
  /// [scope] is the scope at which the policy should be evaluated.
  RelationshipPolicy({
    required String name,
    required String description,
    required this.relationshipName,
    required this.relationshipType,
    required this.validator,
    PolicyScope? scope,
  }) : super(
            name,
            description,
            (Entity e) =>
                e.getRelationship(relationshipName) != null &&
                validator(e, e.getRelationship(relationshipName)),
            scope: scope);

  @override
  bool evaluate(Entity entity) {
    dynamic relationship = getRelationship(entity);
    if (relationship == null) {
      return false;
    }
    return validator(entity, relationship);
  }

  /// Gets the relationship value from the entity based on the relationship type.
  ///
  /// [entity] is the entity to get the relationship from.
  /// Returns the relationship value (parent entity or child collection).
  dynamic getRelationship(Entity entity) {
    switch (relationshipType) {
      case RelationshipType.parent:
        return entity.getParent(relationshipName);
      case RelationshipType.child:
        return entity.getChild(relationshipName);
    }
  }
}

/// Defines the types of relationships that can be validated.
enum RelationshipType {
  /// A parent relationship (e.g., a product's category).
  parent,

  /// A child relationship (e.g., a category's products).
  child
}

/// Provides common relationship validation functions.
///
/// The [RelationshipValidators] class contains static functions for common
/// relationship validation scenarios. These can be used with [RelationshipPolicy]
/// to create policies for common relationship constraints.
///
/// Example usage:
/// ```dart
/// // Check if a relationship exists
/// final hasCategory = RelationshipValidators.isNotNull;
///
/// // Check minimum number of children
/// final hasMinProducts = RelationshipValidators.hasMinimumChildren(3);
///
/// // Check parent attribute value
/// final categoryIsActive = RelationshipValidators.parentHasAttribute('status', 'active');
///
/// // Check all children have a specific attribute value
/// final allProductsInStock = RelationshipValidators.allChildrenHaveAttribute('inStock', true);
/// ```
class RelationshipValidators {
  /// Validates that a relationship exists (is not null).
  static bool Function(Entity, dynamic) isNotNull = (_, value) => value != null;

  /// Creates a validator that checks for a minimum number of children.
  ///
  /// [minCount] is the minimum number of children required.
  /// Returns a validator function that checks if the child collection has at least [minCount] items.
  static bool Function(Entity, dynamic) hasMinimumChildren(int minCount) {
    return (_, value) {
      if (value is Entities) {
        return value.length >= minCount;
      }
      return false;
    };
  }

  /// Creates a validator that checks for a maximum number of children.
  ///
  /// [maxCount] is the maximum number of children allowed.
  /// Returns a validator function that checks if the child collection has at most [maxCount] items.
  static bool Function(Entity, dynamic) hasMaximumChildren(int maxCount) {
    return (_, value) {
      if (value is Entities) {
        return value.length <= maxCount;
      }
      return false;
    };
  }

  /// Creates a validator that checks a parent's attribute value.
  ///
  /// [attributeName] is the name of the attribute to check.
  /// [expectedValue] is the expected value of the attribute.
  /// Returns a validator function that checks if the parent entity's attribute matches [expectedValue].
  static bool Function(Entity, dynamic) parentHasAttribute(
      String attributeName, dynamic expectedValue) {
    return (_, value) {
      if (value is Entity) {
        return value.getAttribute(attributeName) == expectedValue;
      }
      return false;
    };
  }

  /// Creates a validator that checks all children's attribute values.
  ///
  /// [attributeName] is the name of the attribute to check.
  /// [expectedValue] is the expected value of the attribute.
  /// Returns a validator function that checks if all child entities' attributes match [expectedValue].
  static bool Function(Entity, dynamic) allChildrenHaveAttribute(
      String attributeName, dynamic expectedValue) {
    return (_, value) {
      if (value is Entities) {
        return value.every(
            (child) => child.getAttribute(attributeName) == expectedValue);
      }
      return false;
    };
  }

  /// Creates a validator from a custom validation function.
  ///
  /// [customValidator] is the custom validation function to use.
  /// Returns a validator function that uses the custom validation logic.
  static bool Function(Entity, dynamic) customRelationshipValidator(
      bool Function(Entity parent, dynamic relationship) customValidator) {
    return (parent, relationship) => customValidator(parent, relationship);
  }
}


========================================

=== policy/time_based_policy.dart ===

part of ednet_core;

/// A policy that validates time-based conditions on entity attributes.
///
/// The [TimeBasedPolicy] class implements [IPolicy] to provide validation
/// for time-based conditions. It can validate:
/// - Whether a time attribute is before/after a certain duration
/// - Whether a time attribute falls within a specific time range
/// - Whether a time attribute is within a recent or upcoming period
///
/// Example usage:
/// ```dart
/// final expiryPolicy = TimeBasedPolicy(
///   name: 'ExpiryPolicy',
///   description: 'Product must not be expired',
///   timeAttributeName: 'expiryDate',
///   validator: TimeValidators.isBefore(Duration(days: 30)),
/// );
///
/// final upcomingPolicy = TimeBasedPolicy(
///   name: 'UpcomingPolicy',
///   description: 'Event must be in the future',
///   timeAttributeName: 'eventDate',
///   validator: TimeValidators.isAfter(Duration(days: 0)),
/// );
/// ```
class TimeBasedPolicy implements IPolicy {
  @override
  final String name;
  @override
  final String description;
  /// The name of the attribute containing the time value to validate.
  final String timeAttributeName;
  /// The function that validates the time value.
  final TimeValidator validator;
  /// The clock used to get the current time.
  final Clock clock;
  @override
  final PolicyScope? scope;

  /// Creates a new [TimeBasedPolicy] instance.
  ///
  /// [name] is the unique name of the policy.
  /// [description] is a human-readable description of what the policy enforces.
  /// [timeAttributeName] is the name of the attribute containing the time value.
  /// [validator] is the function that validates the time value.
  /// [scope] is the scope at which the policy should be evaluated.
  /// [clock] is the clock to use for getting the current time.
  TimeBasedPolicy({
    required this.name,
    required this.description,
    required this.timeAttributeName,
    required this.validator,
    this.scope,
    Clock? clock,
  }) : clock = clock ?? SystemClock();

  /// Evaluates the time-based condition for the given entity.
  ///
  /// [entity] is the entity to evaluate.
  /// Returns true if the time condition is satisfied, false otherwise.
  bool _evaluateTime(Entity entity) {
    var timeAttribute = entity.getAttribute(timeAttributeName);
    if (timeAttribute == null || timeAttribute is! DateTime) {
      print(
          'Time-based policy violation: Attribute "$timeAttributeName" is missing or not a DateTime.');
      return false;
    }
    return validator(timeAttribute, clock.now());
  }

  @override
  bool evaluate(Entity entity) {
    if (scope == null) {
      return _evaluateTime(entity);
    }
    if (!scope!.isWithinScope(entity)) {
      return true; // Skip entities not within scope
    }
    return _evaluateTime(entity);
  }

  @override
  PolicyEvaluationResult evaluateWithDetails(Entity entity) {
    if (scope == null) {
      bool result = _evaluateTime(entity);
      if (result) {
        return PolicyEvaluationResult(true, []);
      } else {
        var currentTime = clock.now();
        var timeAttribute = entity.getAttribute(timeAttributeName);
        log(entity, timeAttribute, currentTime);
      }
      return policyEvaluationResult;
    }

    if (!scope!.isWithinScope(entity)) {
      return PolicyEvaluationResult(true, []); // Skip entities not within scope
    }

    bool result = _evaluateTime(entity);
    if (result) {
      return PolicyEvaluationResult(true, []);
    } else {
      var currentTime = clock.now();
      var timeAttribute = entity.getAttribute(timeAttributeName);
      log(entity, timeAttribute, currentTime);
      return policyEvaluationResult;
    }
  }

  /// Gets the evaluation result for a policy violation.
  PolicyEvaluationResult get policyEvaluationResult {
    return PolicyEvaluationResult(false,
        [PolicyViolation(name, 'Time-based policy violation: $description')]);
  }

  /// Logs details about a policy violation.
  ///
  /// [entity] is the entity that violated the policy.
  /// [timeAttribute] is the time value that caused the violation.
  /// [currentTime] is the current time when the violation occurred.
  void log(
      Entity<Entity<dynamic>> entity, timeAttribute, DateTime currentTime) {
    print('Time-based policy violation: $description. '
        'Entity: ${entity.toString()}, '
        'Attribute: $timeAttributeName, '
        'Attribute Value: $timeAttribute, '
        'Current Time: $currentTime');
  }
}

/// A function type for validating time-based conditions.
///
/// [attributeTime] is the time value from the entity's attribute.
/// [currentTime] is the current time.
/// Returns true if the time condition is satisfied, false otherwise.
typedef TimeValidator = bool Function(
    DateTime attributeTime, DateTime currentTime);

/// Provides common time-based validation functions.
///
/// The [TimeValidators] class contains static functions for common
/// time-based validation scenarios. These can be used with [TimeBasedPolicy]
/// to create policies for common time-based constraints.
///
/// Example usage:
/// ```dart
/// // Check if a time is before a certain duration ago
/// final isExpired = TimeValidators.isBefore(Duration(days: 30));
///
/// // Check if a time is after a certain duration in the future
/// final isUpcoming = TimeValidators.isAfter(Duration(days: 7));
///
/// // Check if a time is within a specific range
/// final isInSeason = TimeValidators.isBetween(
///   DateTime(2024, 6, 1),
///   DateTime(2024, 8, 31),
/// );
///
/// // Check if a time is within the last duration
/// final isRecent = TimeValidators.isWithinLast(Duration(hours: 24));
///
/// // Check if a time is within the next duration
/// final isSoon = TimeValidators.isWithinNext(Duration(days: 7));
/// ```
class TimeValidators {
  /// Creates a validator that checks if a time is before a certain duration ago.
  ///
  /// [duration] is the duration to check against.
  /// Returns a validator that checks if the attribute time is before (current time - duration).
  static TimeValidator isBefore(Duration duration) {
    return (DateTime attributeTime, DateTime currentTime) =>
        attributeTime.isBefore(currentTime.subtract(duration));
  }

  /// Creates a validator that checks if a time is after a certain duration in the future.
  ///
  /// [duration] is the duration to check against.
  /// Returns a validator that checks if the attribute time is after (current time + duration).
  static TimeValidator isAfter(Duration duration) {
    return (DateTime attributeTime, DateTime currentTime) =>
        attributeTime.isAfter(currentTime.add(duration));
  }

  /// Creates a validator that checks if a time is within a specific range.
  ///
  /// [start] is the start of the valid time range.
  /// [end] is the end of the valid time range.
  /// Returns a validator that checks if the attribute time is between [start] and [end].
  static TimeValidator isBetween(DateTime start, DateTime end) {
    return (DateTime attributeTime, DateTime currentTime) =>
        attributeTime.isAfter(start) && attributeTime.isBefore(end);
  }

  /// Creates a validator that checks if a time is within the last duration.
  ///
  /// [duration] is the duration to check against.
  /// Returns a validator that checks if the attribute time is after (current time - duration).
  static TimeValidator isWithinLast(Duration duration) {
    return (DateTime attributeTime, DateTime currentTime) =>
        attributeTime.isAfter(currentTime.subtract(duration));
  }

  /// Creates a validator that checks if a time is within the next duration.
  ///
  /// [duration] is the duration to check against.
  /// Returns a validator that checks if the attribute time is before (current time + duration).
  static TimeValidator isWithinNext(Duration duration) {
    return (DateTime attributeTime, DateTime currentTime) =>
        attributeTime.isBefore(currentTime.add(duration));
  }
}

/// A concrete implementation of [Clock] that uses the system time.
class SystemClock implements Clock {
  @override
  DateTime now() => DateTime.now();
}

/// An abstract class for getting the current time.
///
/// This class allows for dependency injection of time sources,
/// making it easier to test time-based policies.
abstract class Clock {
  /// Gets the current time.
  DateTime now();
}


========================================

=== policy/todo.md ===

# Policy Documentation TODO

## Completed
- Documented policy evaluation tracer capabilities:
  - Policy evaluation start/end tracking
  - Attribute and relationship value checks
  - Nested policy evaluation depth tracking
  - Human-readable trace output with indentation
  - Example usage and implementation details

## Remaining Tasks
- Add more examples of policy evaluation scenarios
- Document policy performance considerations
- Add troubleshooting guide for common policy issues
- Document policy testing best practices

========================================

=== primitives/dart_basic_types.dart ===

part of ednet_core;

/// Enumeration of basic Dart types used in the domain model.
///
/// This enum represents the primitive and basic collection types available in Dart
/// that can be used as attribute types in domain entities. It includes:
/// - Boolean values ([bool])
/// - Numeric types ([int], [double])
/// - Text type ([string])
/// - Collection types ([list], [map], [set])
/// - Dynamic type ([dynamic]) for values of unknown type
///
/// Example usage:
/// ```dart
/// final type = DartBasicType.string;
/// if (type == DartBasicType.string) {
///   // Handle string type
/// }
/// ```
enum DartBasicType {
  /// Boolean type (true/false)
  bool,

  /// Integer type (whole numbers)
  int,

  /// Double type (floating-point numbers)
  double,

  /// String type (text)
  string,

  /// List type (ordered collection)
  list,

  /// Map type (key-value pairs)
  map,

  /// Set type (unique collection)
  set,

  /// Dynamic type (any value)
  dynamic,
}


========================================

=== queries/concept_query.dart ===

// part of ednet_core;
//
// /// Represents a query specifically for concept operations.
// ///
// /// This class extends the standard [Query] to provide capabilities
// /// specifically designed for querying concepts, including support for
// /// validation against concept attributes and constraints.
// ///
// /// Example usage:
// /// ```dart
// /// final query = ConceptQuery(
// ///   'FindTasksByStatus',
// ///   taskConcept,
// ///   {'status': 'completed'}
// /// );
// ///
// /// // Or with method chaining
// /// final query = ConceptQuery.create('FindTasksByStatus', taskConcept)
// ///   .withAttribute('status', 'completed')
// ///   .withPagination(page: 1, pageSize: 10);
// /// ```
// class ConceptQuery extends Query {
//   /// The concept this query targets.
//   final Concept concept;
//
//   /// Creates a new concept query.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [concept]: The concept being queried
//   /// - [parameters]: Initial parameters for the query
//   ConceptQuery(
//     String name,
//     this.concept, [
//     Map<String, dynamic>? parameters,
//   ]) : super(name, conceptCode: concept.code) {
//     if (parameters != null) {
//       withParameters(parameters);
//     }
//   }
//
//   /// Factory constructor for cleaner creation.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [concept]: The concept being queried
//   factory ConceptQuery.create(String name, Concept concept) {
//     return ConceptQuery(name, concept);
//   }
//
//   /// Adds a filter based on a concept attribute.
//   ///
//   /// This method ensures the attribute exists in the concept
//   /// before adding it as a filter parameter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The code of the attribute to filter by
//   /// - [value]: The value to filter for
//   ///
//   /// Returns this query for method chaining.
//   /// Throws [AttributeException] if the attribute doesn't exist.
//   ConceptQuery withAttribute(String attributeCode, dynamic value) {
//     // Verify the attribute exists
//     Attribute? attribute = concept.getAttribute<Attribute>(attributeCode);
//     if (attribute == null) {
//       throw AttributeException(
//         'Attribute $attributeCode does not exist in concept ${concept.code}'
//       );
//     }
//
//     return withParameter(attributeCode, value) as ConceptQuery;
//   }
//
//   /// Adds pagination parameters to the query.
//   ///
//   /// This is a convenience method for adding standard pagination parameters.
//   ///
//   /// Parameters:
//   /// - [page]: The page number to retrieve (1-based)
//   /// - [pageSize]: The number of items per page
//   ///
//   /// Returns this query for method chaining.
//   ConceptQuery withPagination({int page = 1, int pageSize = 20}) {
//     return withParameters({
//       'page': page,
//       'pageSize': pageSize,
//     }) as ConceptQuery;
//   }
//
//   /// Adds sorting parameters to the query.
//   ///
//   /// This method verifies that the attribute exists in the concept
//   /// before adding the sort parameter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The code of the attribute to sort by
//   /// - [ascending]: Whether to sort in ascending order
//   ///
//   /// Returns this query for method chaining.
//   /// Throws [AttributeException] if the attribute doesn't exist.
//   ConceptQuery withSorting(String attributeCode, {bool ascending = true}) {
//     // Verify the attribute exists
//     Attribute? attribute = concept.getAttribute<Attribute>(attributeCode);
//     if (attribute == null) {
//       throw AttributeException(
//         'Cannot sort by attribute $attributeCode: it does not exist in concept ${concept.code}'
//       );
//     }
//
//     return withParameters({
//       'sortBy': attributeCode,
//       'sortDirection': ascending ? 'asc' : 'desc',
//     }) as ConceptQuery;
//   }
//
//   /// Validates this query against the concept's structure.
//   ///
//   /// This method checks that all attribute filters refer to valid
//   /// attributes in the concept, and that the values are of the correct type.
//   ///
//   /// Returns true if the query is valid, false otherwise.
//   bool validate() {
//     for (String key in getParameters().keys) {
//       // Skip standard parameters
//       if (['page', 'pageSize', 'sortBy', 'sortDirection'].contains(key)) {
//         continue;
//       }
//
//       // Check if this is an attribute filter
//       Attribute? attribute = concept.getAttribute<Attribute>(key);
//       if (attribute != null) {
//         // We found an attribute - check value type compatibility
//         var value = getParameters()[key];
//         if (value != null && attribute.type != null) {
//           if (!attribute.type!.isCompatibleWith(value)) {
//             return false;
//           }
//         }
//       }
//     }
//     return true;
//   }
// }

========================================

=== queries/entity_query_result.dart ===

// part of ednet_core;
//
// /// Represents a query result specifically for entity operations.
// ///
// /// This class extends the standard [QueryResult] to provide capabilities
// /// specifically designed for working with entities, including support for
// /// converting results to [Entities] collections.
// ///
// /// Type parameters:
// /// - [T]: The type of entity this result contains
// ///
// /// Example usage:
// /// ```dart
// /// final result = EntityQueryResult.success<Task>(
// ///   taskEntities,
// ///   concept: taskConcept,
// ///   metadata: {'totalCount': 42}
// /// );
// ///
// /// // Convert to Entities collection
// /// final entities = result.asEntities;
// /// ```
// class EntityQueryResult<T extends Entity<T>> extends QueryResult<List<T>> {
//   /// The concept that defines the entities in this result.
//   final Concept concept;
//
//   /// Creates a new entity query result.
//   ///
//   /// Parameters:
//   /// - [isSuccess]: Whether the query was successful
//   /// - [entities]: List of entities in the result (null if query failed)
//   /// - [errorMessage]: Error message (null if query succeeded)
//   /// - [concept]: The concept defining the entities
//   /// - [metadata]: Additional metadata for the result
//   EntityQueryResult({
//     required bool isSuccess,
//     List<T>? entities,
//     String? errorMessage,
//     required this.concept,
//     Map<String, dynamic> metadata = const {},
//   }) : super(
//     isSuccess: isSuccess,
//     data: entities,
//     errorMessage: errorMessage,
//     metadata: metadata,
//     conceptCode: concept.code,
//   );
//
//   /// Creates a successful entity query result.
//   ///
//   /// Parameters:
//   /// - [entities]: List of entities in the result
//   /// - [concept]: The concept defining the entities
//   /// - [metadata]: Additional metadata for the result
//   factory EntityQueryResult.success(
//     List<T> entities, {
//     required Concept concept,
//     Map<String, dynamic> metadata = const {},
//   }) {
//     return EntityQueryResult(
//       isSuccess: true,
//       entities: entities,
//       concept: concept,
//       metadata: metadata,
//     );
//   }
//
//   /// Creates a failed entity query result.
//   ///
//   /// Parameters:
//   /// - [errorMessage]: The error message
//   /// - [concept]: The concept defining the entities
//   /// - [metadata]: Additional metadata for the result
//   factory EntityQueryResult.failure(
//     String errorMessage, {
//     required Concept concept,
//     Map<String, dynamic> metadata = const {},
//   }) {
//     return EntityQueryResult(
//       isSuccess: false,
//       errorMessage: errorMessage,
//       concept: concept,
//       metadata: metadata,
//     );
//   }
//
//   /// Creates an empty successful entity query result.
//   ///
//   /// Parameters:
//   /// - [concept]: The concept defining the entities
//   /// - [metadata]: Additional metadata for the result
//   factory EntityQueryResult.empty({
//     required Concept concept,
//     Map<String, dynamic> metadata = const {},
//   }) {
//     return EntityQueryResult(
//       isSuccess: true,
//       entities: [],
//       concept: concept,
//       metadata: metadata,
//     );
//   }
//
//   /// Converts the result data to an [Entities] collection.
//   ///
//   /// This provides a convenient way to work with the result in the
//   /// EDNet Core entity framework, taking advantage of [Entities]
//   /// collection capabilities.
//   ///
//   /// Returns an [Entities] collection containing the result data.
//   Entities<T> get asEntities {
//     final result = Entities<T>();
//     result.concept = concept;
//     if (data != null) {
//       result.addAll(data!);
//     }
//     return result;
//   }
//
//   /// Creates a new result with updated pagination information.
//   ///
//   /// This overrides the base class method to ensure the returned
//   /// result is an [EntityQueryResult].
//   ///
//   /// Parameters:
//   /// - [page]: The current page number
//   /// - [pageSize]: The number of items per page
//   /// - [totalCount]: The total number of items
//   ///
//   /// Returns a new entity query result with updated metadata
//   @override
//   EntityQueryResult<T> withPagination({
//     required int page,
//     required int pageSize,
//     required int totalCount,
//   }) {
//     final newMetadata = Map<String, dynamic>.from(metadata)
//       ..addAll({
//         'page': page,
//         'pageSize': pageSize,
//         'totalCount': totalCount,
//         'totalPages': (totalCount / pageSize).ceil(),
//       });
//
//     return EntityQueryResult(
//       isSuccess: isSuccess,
//       entities: data,
//       errorMessage: errorMessage,
//       concept: concept,
//       metadata: newMetadata,
//     );
//   }
// }

========================================

=== queries/expression_query.dart ===

// part of ednet_core;
//
// /// Implements a query using the expression system for powerful filtering.
// ///
// /// The [ExpressionQuery] class extends [ConceptQuery] to provide advanced
// /// querying capabilities using the expression system. This allows for
// /// more complex filtering, sorting, and relationship traversal.
// ///
// /// Example usage:
// /// ```dart
// /// // Create an expression to find products with price < 100 that have 'electronics' category
// /// final priceExpression = AttributeExpression('price', ComparisonOperator.lessThan, 100);
// /// final categoryExpression = RelationshipExpression(
// ///   'category',
// ///   RelationshipType.parent,
// ///   AttributeExpression('name', ComparisonOperator.equals, 'electronics')
// /// );
// ///
// /// final combinedExpression = priceExpression.and(categoryExpression);
// ///
// /// final query = ExpressionQuery('FindAffordableElectronics', productConcept, combinedExpression)
// ///   .withPagination(page: 1, pageSize: 20)
// ///   .withSorting('price');
// /// ```
// class ExpressionQuery extends ConceptQuery {
//   /// The expression to evaluate against entities.
//   final QueryExpression expression;
//
//   /// Creates a new expression-based query.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [concept]: The concept being queried
//   /// - [expression]: The expression to evaluate
//   /// - [parameters]: Additional parameters for the query
//   ExpressionQuery(
//     String name,
//     Concept concept,
//     this.expression, [
//     Map<String, dynamic>? parameters,
//   ]) : super(name, concept, parameters);
//
//   /// Factory method for creating a query with an attribute expression.
//   ///
//   /// This convenience method creates a query with an attribute expression
//   /// using the specified operator and value.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [concept]: The concept being queried
//   /// - [attributeCode]: The attribute to filter on
//   /// - [operator]: The comparison operator
//   /// - [value]: The value to compare against
//   ///
//   /// Returns a new expression query.
//   factory ExpressionQuery.withAttribute(
//     String name,
//     Concept concept,
//     String attributeCode,
//     ComparisonOperator operator,
//     dynamic value
//   ) {
//     return ExpressionQuery(
//       name,
//       concept,
//       AttributeExpression(attributeCode, operator, value)
//     );
//   }
//
//   /// Factory method for creating a query with a relationship expression.
//   ///
//   /// This convenience method creates a query that filters based on
//   /// a relationship with the specified expression.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [concept]: The concept being queried
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   /// - [relatedExpression]: The expression to apply to related entities
//   ///
//   /// Returns a new expression query.
//   factory ExpressionQuery.withRelationship(
//     String name,
//     Concept concept,
//     String relationshipCode,
//     RelationshipType relationshipType,
//     QueryExpression relatedExpression
//   ) {
//     return ExpressionQuery(
//       name,
//       concept,
//       RelationshipExpression(relationshipCode, relationshipType, relatedExpression)
//     );
//   }
//
//   /// Adds the expression to the query parameters.
//   @override
//   Map<String, dynamic> getParameters() {
//     final params = super.getParameters();
//
//     // Clone the parameters map since super.getParameters() returns an unmodifiable map
//     final mutableParams = Map<String, dynamic>.from(params);
//
//     // Add the expression to the parameters
//     mutableParams['expression'] = expression;
//
//     return Map.unmodifiable(mutableParams);
//   }
//
//   /// Gets the expression from this query.
//   ///
//   /// This method is useful for query handlers to access the expression
//   /// for evaluation.
//   ///
//   /// Returns the query expression.
//   QueryExpression getExpression() => expression;
//
//   /// Applies the expression to a collection of entities.
//   ///
//   /// This method filters a collection of entities using the expression,
//   /// and applies any additional filtering, sorting, and pagination from
//   /// the query parameters.
//   ///
//   /// Parameters:
//   /// - [entities]: The collection of entities to filter
//   ///
//   /// Returns a filtered collection of entities.
//   Iterable<Entity> apply(Iterable<Entity> entities) {
//     // Filter entities using the expression
//     var result = entities.where((entity) => expression.evaluate(entity));
//
//     // Apply sorting if specified
//     final sortBy = getParameters()['sortBy'] as String?;
//     final sortDirection = getParameters()['sortDirection'] as String?;
//
//     if (sortBy != null) {
//       final ascending = sortDirection != 'desc';
//
//       result = result.toList()
//         ..sort((a, b) {
//           final aValue = a.getAttribute(sortBy);
//           final bValue = b.getAttribute(sortBy);
//
//           // Handle null values
//           if (aValue == null && bValue == null) return 0;
//           if (aValue == null) return ascending ? -1 : 1;
//           if (bValue == null) return ascending ? 1 : -1;
//
//           // Compare values
//           if (aValue is Comparable && bValue is Comparable) {
//             final comparison = aValue.compareTo(bValue);
//             return ascending ? comparison : -comparison;
//           }
//
//           // If not comparable, use toString()
//           final comparison = aValue.toString().compareTo(bValue.toString());
//           return ascending ? comparison : -comparison;
//         });
//     }
//
//     // Apply pagination if specified
//     final page = getParameters()['page'] as int?;
//     final pageSize = getParameters()['pageSize'] as int?;
//
//     if (page != null && pageSize != null && pageSize > 0) {
//       final start = (page - 1) * pageSize;
//       final end = start + pageSize;
//
//       final asList = result.toList();
//       if (start < asList.length) {
//         result = asList.sublist(start, end > asList.length ? asList.length : end);
//       } else {
//         result = [];
//       }
//     }
//
//     return result;
//   }
// }

========================================

=== queries/expressions/query_expression.dart ===

// part of ednet_core;
//
// /// Base class for all query expressions in the EDNet query language.
// ///
// /// This abstract class serves as the foundation for a rich, composable
// /// query expression system that allows developers to express complex
// /// filtering, sorting, and traversal operations in a type-safe way.
// ///
// /// The expression system is designed to be:
// /// - Composable: expressions can be combined to form more complex expressions
// /// - Type-safe: expressions validate against concept metadata
// /// - Serializable: expressions can be serialized for storage or transmission
// /// - Extensible: new expression types can be added to enhance capabilities
// abstract class QueryExpression implements model.ValueObject {
//   /// Evaluates this expression against an entity.
//   ///
//   /// [entity] is the entity to evaluate against.
//   /// Returns true if the expression matches the entity, false otherwise.
//   bool evaluate(Entity entity);
//
//   /// Creates a logical AND with another expression.
//   ///
//   /// [other] is the expression to combine with.
//   /// Returns a new expression representing the logical AND.
//   QueryExpression and(QueryExpression other) {
//     return LogicalExpression(this, other, LogicalOperator.and);
//   }
//
//   /// Creates a logical OR with another expression.
//   ///
//   /// [other] is the expression to combine with.
//   /// Returns a new expression representing the logical OR.
//   QueryExpression or(QueryExpression other) {
//     return LogicalExpression(this, other, LogicalOperator.or);
//   }
//
//   /// Creates a logical NOT of this expression.
//   ///
//   /// Returns a new expression representing the logical NOT.
//   QueryExpression not() {
//     return NotExpression(this);
//   }
//
//   /// Converts this expression to JSON.
//   @override
//   Map<String, dynamic> toJson();
//
//   /// Creates an expression from its JSON representation.
//   /// This is implemented by concrete subclasses.
//   static QueryExpression fromJson(Map<String, dynamic> json) {
//     final type = json['type'] as String;
//
//     switch (type) {
//       case 'attribute':
//         return AttributeExpression.fromJson(json);
//       case 'logical':
//         return LogicalExpression.fromJson(json);
//       case 'not':
//         return NotExpression.fromJson(json);
//       case 'relationship':
//         return RelationshipExpression.fromJson(json);
//       case 'constant':
//         return ConstantExpression.fromJson(json);
//       case 'function':
//         return FunctionExpression.fromJson(json);
//       default:
//         throw ArgumentError('Unknown expression type: $type');
//     }
//   }
// }
//
// /// Expression for filtering by attribute values.
// ///
// /// This expression type allows filtering entities based on their attribute
// /// values using various comparison operators.
// ///
// /// Example usage:
// /// ```dart
// /// // Find entities where 'price' is less than 100
// /// final expression = AttributeExpression(
// ///   'price',
// ///   ComparisonOperator.lessThan,
// ///   100
// /// );
// /// ```
// class AttributeExpression extends QueryExpression {
//   /// The code of the attribute to filter by.
//   final String attributeCode;
//
//   /// The comparison operator to use.
//   final ComparisonOperator operator;
//
//   /// The value to compare against.
//   final dynamic value;
//
//   /// Creates a new attribute expression.
//   AttributeExpression(this.attributeCode, this.operator, this.value);
//
//   @override
//   bool evaluate(Entity entity) {
//     final attributeValue = entity.getAttribute(attributeCode);
//
//     switch (operator) {
//       case ComparisonOperator.equals:
//         return attributeValue == value;
//       case ComparisonOperator.notEquals:
//         return attributeValue != value;
//       case ComparisonOperator.greaterThan:
//         if (attributeValue is Comparable && value is Comparable) {
//           return attributeValue.compareTo(value) > 0;
//         }
//         return false;
//       case ComparisonOperator.greaterThanOrEqual:
//         if (attributeValue is Comparable && value is Comparable) {
//           return attributeValue.compareTo(value) >= 0;
//         }
//         return false;
//       case ComparisonOperator.lessThan:
//         if (attributeValue is Comparable && value is Comparable) {
//           return attributeValue.compareTo(value) < 0;
//         }
//         return false;
//       case ComparisonOperator.lessThanOrEqual:
//         if (attributeValue is Comparable && value is Comparable) {
//           return attributeValue.compareTo(value) <= 0;
//         }
//         return false;
//       case ComparisonOperator.contains:
//         if (attributeValue is String && value is String) {
//           return attributeValue.contains(value);
//         }
//         return false;
//       case ComparisonOperator.startsWith:
//         if (attributeValue is String && value is String) {
//           return attributeValue.startsWith(value);
//         }
//         return false;
//       case ComparisonOperator.endsWith:
//         if (attributeValue is String && value is String) {
//           return attributeValue.endsWith(value);
//         }
//         return false;
//       case ComparisonOperator.isNull:
//         return attributeValue == null;
//       case ComparisonOperator.isNotNull:
//         return attributeValue != null;
//       case ComparisonOperator.inList:
//         if (value is List) {
//           return value.contains(attributeValue);
//         }
//         return false;
//       case ComparisonOperator.notInList:
//         if (value is List) {
//           return !value.contains(attributeValue);
//         }
//         return false;
//       case ComparisonOperator.between:
//         if (attributeValue is Comparable && value is List && value.length == 2) {
//           return attributeValue.compareTo(value[0]) >= 0 &&
//                  attributeValue.compareTo(value[1]) <= 0;
//         }
//         return false;
//       default:
//         return false;
//     }
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'attribute',
//       'attributeCode': attributeCode,
//       'operator': operator.toString(),
//       'value': value is model.ValueObject ? (value as model.ValueObject).toJson() : value,
//     };
//   }
//
//   static AttributeExpression fromJson(Map<String, dynamic> json) {
//     return AttributeExpression(
//       json['attributeCode'],
//       ComparisonOperator.fromString(json['operator']),
//       json['value'],
//     );
//   }
// }
//
// /// Logical expression combining two expressions with AND or OR.
// ///
// /// This expression type allows creating complex expressions by combining
// /// simpler expressions with logical operators.
// ///
// /// Example usage:
// /// ```dart
// /// final priceExpression = AttributeExpression(
// ///   'price',
// ///   ComparisonOperator.lessThan,
// ///   100
// /// );
// ///
// /// final nameExpression = AttributeExpression(
// ///   'name',
// ///   ComparisonOperator.contains,
// ///   'Laptop'
// /// );
// ///
// /// // Find entities where price < 100 AND name contains 'Laptop'
// /// final combinedExpression = LogicalExpression(
// ///   priceExpression,
// ///   nameExpression,
// ///   LogicalOperator.and
// /// );
// /// ```
// class LogicalExpression extends QueryExpression {
//   /// The left operand expression.
//   final QueryExpression left;
//
//   /// The right operand expression.
//   final QueryExpression right;
//
//   /// The logical operator to use.
//   final LogicalOperator operator;
//
//   /// Creates a new logical expression.
//   LogicalExpression(this.left, this.right, this.operator);
//
//   @override
//   bool evaluate(Entity entity) {
//     switch (operator) {
//       case LogicalOperator.and:
//         return left.evaluate(entity) && right.evaluate(entity);
//       case LogicalOperator.or:
//         return left.evaluate(entity) || right.evaluate(entity);
//       default:
//         return false;
//     }
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'logical',
//       'left': left.toJson(),
//       'right': right.toJson(),
//       'operator': operator.toString(),
//     };
//   }
//
//   static LogicalExpression fromJson(Map<String, dynamic> json) {
//     return LogicalExpression(
//       QueryExpression.fromJson(json['left']),
//       QueryExpression.fromJson(json['right']),
//       LogicalOperator.fromString(json['operator']),
//     );
//   }
// }
//
// /// Negation of an expression.
// ///
// /// This expression type negates the result of another expression.
// ///
// /// Example usage:
// /// ```dart
// /// final priceExpression = AttributeExpression(
// ///   'price',
// ///   ComparisonOperator.lessThan,
// ///   100
// /// );
// ///
// /// // Find entities where price is NOT < 100 (i.e., price >= 100)
// /// final notExpression = NotExpression(priceExpression);
// /// ```
// class NotExpression extends QueryExpression {
//   /// The expression to negate.
//   final QueryExpression expression;
//
//   /// Creates a new NOT expression.
//   NotExpression(this.expression);
//
//   @override
//   bool evaluate(Entity entity) {
//     return !expression.evaluate(entity);
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'not',
//       'expression': expression.toJson(),
//     };
//   }
//
//   static NotExpression fromJson(Map<String, dynamic> json) {
//     return NotExpression(
//       QueryExpression.fromJson(json['expression']),
//     );
//   }
// }
//
// /// Expression for traversing and filtering by relationships.
// ///
// /// This expression type allows filtering entities based on their relationships
// /// with other entities, supporting parent and child traversal.
// ///
// /// Example usage:
// /// ```dart
// /// // Find tasks where the assigned user's name contains 'John'
// /// final userNameExpression = AttributeExpression(
// ///   'name',
// ///   ComparisonOperator.contains,
// ///   'John'
// /// );
// ///
// /// final expression = RelationshipExpression(
// ///   'assignedUser',
// ///   RelationshipType.parent,
// ///   userNameExpression
// /// );
// /// ```
// class RelationshipExpression extends QueryExpression {
//   /// The code of the relationship to traverse.
//   final String relationshipCode;
//
//   /// The type of relationship (parent or child).
//   final RelationshipType relationshipType;
//
//   /// The expression to apply to the related entity.
//   final QueryExpression expression;
//
//   /// Creates a new relationship expression.
//   RelationshipExpression(
//     this.relationshipCode,
//     this.relationshipType,
//     this.expression
//   );
//
//   @override
//   bool evaluate(Entity entity) {
//     if (relationshipType == RelationshipType.parent) {
//       final parent = entity.getParent(relationshipCode);
//       if (parent is Entity) {
//         return expression.evaluate(parent);
//       }
//       return false;
//     } else if (relationshipType == RelationshipType.child) {
//       final children = entity.getChild(relationshipCode);
//       if (children is Entities) {
//         // For child relationships, we check if ANY child matches
//         return children.any((child) => expression.evaluate(child));
//       }
//       return false;
//     }
//     return false;
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'relationship',
//       'relationshipCode': relationshipCode,
//       'relationshipType': relationshipType.toString(),
//       'expression': expression.toJson(),
//     };
//   }
//
//   static RelationshipExpression fromJson(Map<String, dynamic> json) {
//     return RelationshipExpression(
//       json['relationshipCode'],
//       RelationshipType.fromString(json['relationshipType']),
//       QueryExpression.fromJson(json['expression']),
//     );
//   }
// }
//
// /// Constant expression that always evaluates to a fixed value.
// ///
// /// This expression type is useful for creating conditional expressions
// /// or as placeholders in complex expressions.
// ///
// /// Example usage:
// /// ```dart
// /// // Always evaluates to true
// /// final trueExpression = ConstantExpression(true);
// /// ```
// class ConstantExpression extends QueryExpression {
//   /// The constant value of this expression.
//   final bool value;
//
//   /// Creates a new constant expression.
//   ConstantExpression(this.value);
//
//   @override
//   bool evaluate(Entity entity) {
//     return value;
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'constant',
//       'value': value,
//     };
//   }
//
//   static ConstantExpression fromJson(Map<String, dynamic> json) {
//     return ConstantExpression(json['value']);
//   }
// }
//
// /// Function-based expression for advanced filtering.
// ///
// /// This expression type allows applying functions to attributes
// /// for more complex filtering operations.
// ///
// /// Example usage:
// /// ```dart
// /// // Find entities where the date attribute is within the current month
// /// final expression = FunctionExpression(
// ///   'currentMonth',
// ///   'createdDate',
// ///   {}
// /// );
// /// ```
// class FunctionExpression extends QueryExpression {
//   /// The name of the function to apply.
//   final String functionName;
//
//   /// The code of the attribute to apply the function to.
//   final String attributeCode;
//
//   /// Parameters for the function.
//   final Map<String, dynamic> parameters;
//
//   /// Creates a new function expression.
//   FunctionExpression(this.functionName, this.attributeCode, this.parameters);
//
//   @override
//   bool evaluate(Entity entity) {
//     final attributeValue = entity.getAttribute(attributeCode);
//
//     switch (functionName) {
//       case 'currentMonth':
//         if (attributeValue is DateTime) {
//           final now = DateTime.now();
//           return attributeValue.year == now.year &&
//                  attributeValue.month == now.month;
//         }
//         return false;
//       case 'lastNDays':
//         if (attributeValue is DateTime && parameters.containsKey('days')) {
//           final days = parameters['days'] as int;
//           final now = DateTime.now();
//           final difference = now.difference(attributeValue).inDays;
//           return difference <= days;
//         }
//         return false;
//       case 'length':
//         if (attributeValue is String && parameters.containsKey('operator') && parameters.containsKey('value')) {
//           final operator = ComparisonOperator.fromString(parameters['operator']);
//           final value = parameters['value'] as int;
//
//           switch (operator) {
//             case ComparisonOperator.equals:
//               return attributeValue.length == value;
//             case ComparisonOperator.notEquals:
//               return attributeValue.length != value;
//             case ComparisonOperator.greaterThan:
//               return attributeValue.length > value;
//             case ComparisonOperator.greaterThanOrEqual:
//               return attributeValue.length >= value;
//             case ComparisonOperator.lessThan:
//               return attributeValue.length < value;
//             case ComparisonOperator.lessThanOrEqual:
//               return attributeValue.length <= value;
//             default:
//               return false;
//           }
//         }
//         return false;
//       default:
//         return false;
//     }
//   }
//
//   @override
//   Map<String, dynamic> toJson() {
//     return {
//       'type': 'function',
//       'functionName': functionName,
//       'attributeCode': attributeCode,
//       'parameters': parameters,
//     };
//   }
//
//   static FunctionExpression fromJson(Map<String, dynamic> json) {
//     return FunctionExpression(
//       json['functionName'],
//       json['attributeCode'],
//       Map<String, dynamic>.from(json['parameters']),
//     );
//   }
// }
//
// /// Enumeration of comparison operators for attribute expressions.
// enum ComparisonOperator {
//   equals,
//   notEquals,
//   greaterThan,
//   greaterThanOrEqual,
//   lessThan,
//   lessThanOrEqual,
//   contains,
//   startsWith,
//   endsWith,
//   isNull,
//   isNotNull,
//   inList,
//   notInList,
//   between;
//
//   static ComparisonOperator fromString(String value) {
//     return ComparisonOperator.values.firstWhere(
//       (op) => op.toString() == value ||
//               op.toString() == 'ComparisonOperator.$value',
//       orElse: () => throw ArgumentError('Unknown operator: $value'),
//     );
//   }
// }
//
// /// Enumeration of logical operators for logical expressions.
// enum LogicalOperator {
//   and,
//   or;
//
//   static LogicalOperator fromString(String value) {
//     return LogicalOperator.values.firstWhere(
//       (op) => op.toString() == value ||
//               op.toString() == 'LogicalOperator.$value',
//       orElse: () => throw ArgumentError('Unknown operator: $value'),
//     );
//   }
// }
//
// /// Enumeration of relationship types for relationship expressions.
// enum RelationshipType {
//   parent,
//   child;
//
//   static RelationshipType fromString(String value) {
//     return RelationshipType.values.firstWhere(
//       (type) => type.toString() == value ||
//                 type.toString() == 'RelationshipType.$value',
//       orElse: () => throw ArgumentError('Unknown relationship type: $value'),
//     );
//   }
// }

========================================

=== queries/interfaces/i_query.dart ===

part of ednet_core;

/// Represents a query in the CQRS pattern.
///
/// Queries are used to retrieve data from the domain model without causing
/// state changes. This interface serves as the foundation for all query types
/// in the system, enabling clear separation from commands.
///
/// Queries should:
/// - Be named after their intent (e.g., 'FindTasksAssignedToUser')
/// - Return immutable data transfer objects
/// - Not cause side effects
/// - Be optimized for read operations
abstract class IQuery {
  /// The name of the query.
  String get name;
  
  /// The concept code this query targets, if applicable.
  /// 
  /// This enables concept-specific query handling and validation.
  /// If null, the query is not specific to a single concept.
  String? get conceptCode;
  
  /// Gets the parameters for this query.
  ///
  /// Returns a map of parameter names to their values.
  Map<String, dynamic> getParameters();
  
  /// Indicates if this query targets the specified concept.
  /// 
  /// This can be used for routing queries to the appropriate handlers
  /// based on concept metadata.
  /// 
  /// [code] is the concept code to check against.
  /// Returns true if this query targets the specified concept.
  bool forConcept(String code) {
    return conceptCode == code;
  }
  
  /// Creates a string representation of the query.
  ///
  /// This is useful for logging and debugging purposes.
  @override
  String toString() {
    String base = 'Query: $name, Parameters: ${getParameters()}';
    if (conceptCode != null) {
      base += ', Concept: $conceptCode';
    }
    return base;
  }
} 

========================================

=== queries/interfaces/i_query_handler.dart ===

// part of ednet_core;
//
// /// Interface for query handlers in CQRS.
// ///
// /// The [IQueryHandler] interface defines the contract for components that handle
// /// queries. It ensures that query handlers:
// /// - Accept a specific query type
// /// - Return a specific result type
// /// - Have a consistent execution pattern
// ///
// /// This promotes a clear separation of query handling logic from command processing.
// ///
// /// Type parameters:
// /// - [Q]: The type of query this handler processes
// /// - [R]: The type of result this handler returns
// abstract class IQueryHandler<Q extends IQuery, R extends IQueryResult> {
//   /// Handles a query and returns a result.
//   ///
//   /// This method should:
//   /// - Process the query without side effects
//   /// - Return a result containing the requested data
//   /// - Handle any errors that occur during processing
//   ///
//   /// Parameters:
//   /// - [query]: The query to handle
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<R> handle(Q query);
// }

========================================

=== queries/interfaces/i_query_result.dart ===

part of ednet_core;

/// Represents the result of a query operation in CQRS.
///
/// The [IQueryResult] interface provides a standardized way to handle
/// query results, including support for pagination, metadata, and error handling.
///
/// This interface serves as the foundation for all query result types in the system,
/// providing a clear contract for components that process query results.
abstract class IQueryResult<T> {
  /// Indicates whether the query was successful.
  bool get isSuccess;
  
  /// The result data.
  ///
  /// This will contain the actual query result data when [isSuccess] is true.
  /// It will be null when [isSuccess] is false.
  T? get data;
  
  /// Error message when the query fails.
  ///
  /// This will contain an error message when [isSuccess] is false.
  /// It will be null when [isSuccess] is true.
  String? get errorMessage;
  
  /// Metadata associated with the query result.
  ///
  /// This can include information like total count, pagination details,
  /// execution time, etc.
  Map<String, dynamic> get metadata;
  
  /// The concept code related to this query result, if applicable.
  ///
  /// This is used to identify which concept's entities are being returned
  /// or processed in this result.
  String? get conceptCode;
  
  /// Indicates whether this result contains pagination information.
  ///
  /// Returns true if the metadata contains standard pagination fields.
  bool get isPaginated {
    return metadata.containsKey('page') && 
           metadata.containsKey('pageSize') && 
           metadata.containsKey('totalCount');
  }
  
  /// Gets the total number of items available across all pages.
  ///
  /// This is only available when the result is paginated.
  /// Returns the total count or null if pagination information is not available.
  int? get totalCount {
    return isPaginated ? metadata['totalCount'] as int? : null;
  }
  
  /// Gets the current page number.
  ///
  /// This is only available when the result is paginated.
  /// Returns the current page or null if pagination information is not available.
  int? get page {
    return isPaginated ? metadata['page'] as int? : null;
  }
  
  /// Gets the number of items per page.
  ///
  /// This is only available when the result is paginated.
  /// Returns the page size or null if pagination information is not available.
  int? get pageSize {
    return isPaginated ? metadata['pageSize'] as int? : null;
  }
} 

========================================

=== queries/query.dart ===

// part of ednet_core;
//
// /// Represents a query in the application layer.
// ///
// /// The [Query] class extends the domain model's query class, adding
// /// application-specific functionality while maintaining compatibility with
// /// the domain model layer.
// ///
// /// This class serves as the foundation for all application-level queries,
// /// providing enhanced features like validation and metadata.
// ///
// /// Example usage:
// /// ```dart
// /// class FindActiveTasksQuery extends Query {
// ///   final DateTime cutoffDate;
// ///
// ///   FindActiveTasksQuery(this.cutoffDate) : super('FindActiveTasks');
// ///
// ///   @override
// ///   Map<String, dynamic> getParameters() => {
// ///     'cutoffDate': cutoffDate.toIso8601String(),
// ///   };
// ///
// ///   @override
// ///   bool validate() => cutoffDate.isAfter(DateTime.now());
// /// }
// /// ```
// class Query extends model.Query implements IQuery {
//   /// Metadata associated with this query.
//   final Map<String, dynamic> metadata;
//
//   /// Creates a new application-level query.
//   ///
//   /// Parameters:
//   /// - [name]: The name of the query
//   /// - [conceptCode]: Optional concept code this query targets
//   /// - [metadata]: Additional metadata for the query
//   Query(
//     String name, {
//     String? conceptCode,
//     this.metadata = const {},
//   }) : super(name, conceptCode: conceptCode);
//
//   /// Validates the query before execution.
//   ///
//   /// Override this method to implement specific validation logic
//   /// for queries in your application.
//   ///
//   /// Returns true if the query is valid, false otherwise.
//   bool validate() => true;
//
//   @override
//   Map<String, dynamic> getParameters() => super.getParameters();
// }
//
// /// Interface for application-level queries.
// ///
// /// This interface extends the domain model query interface,
// /// providing a contract for application-specific query capabilities.
// ///
// /// This interface is being maintained for backward compatibility,
// /// but future code should prefer using model.IQuery directly.
// abstract class IQuery implements model.IQuery {
//   /// Validates the query before execution.
//   bool validate();
//
//   /// Metadata associated with this query.
//   Map<String, dynamic> get metadata;
// }

========================================

=== queries/query_builder.dart ===

// part of ednet_core;
//
// /// Provides a fluent API for building queries.
// ///
// /// The [QueryBuilder] class simplifies the construction of complex queries
// /// by providing a fluent, chainable interface. It supports building attribute
// /// filters, relationship traversals, and logical combinations.
// ///
// /// Example usage:
// /// ```dart
// /// final query = QueryBuilder.forConcept(productConcept, 'FindProducts')
// ///   .where('price').lessThan(100)
// ///   .and('name').contains('laptop')
// ///   .andWhere('category', RelationshipType.parent)
// ///     .where('name').equals('electronics')
// ///   .orderBy('price')
// ///   .paginate(1, 20)
// ///   .build();
// /// ```
// class QueryBuilder {
//   /// The concept being queried.
//   final Concept _concept;
//
//   /// The name of the query.
//   final String _name;
//
//   /// The current expression being built.
//   QueryExpression? _expression;
//
//   /// Additional query parameters.
//   final Map<String, dynamic> _parameters = {};
//
//   /// Creates a new query builder for the specified concept.
//   ///
//   /// Parameters:
//   /// - [concept]: The concept to query
//   /// - [name]: The name of the query
//   QueryBuilder.forConcept(this._concept, this._name);
//
//   /// Starts an attribute filter clause.
//   ///
//   /// This method begins a filter on the specified attribute.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns an attribute filter builder for chaining.
//   AttributeFilterBuilder where(String attributeCode) {
//     return AttributeFilterBuilder(this, attributeCode);
//   }
//
//   /// Starts a relationship traversal clause.
//   ///
//   /// This method begins a filter on entities related to the current entity.
//   ///
//   /// Parameters:
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship (parent or child)
//   ///
//   /// Returns a relationship builder for chaining.
//   RelationshipBuilder whereRelated(String relationshipCode, RelationshipType relationshipType) {
//     return RelationshipBuilder(this, relationshipCode, relationshipType);
//   }
//
//   /// Adds a sort clause to the query.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to sort by
//   /// - [ascending]: Whether to sort in ascending order
//   ///
//   /// Returns this builder for chaining.
//   QueryBuilder orderBy(String attributeCode, {bool ascending = true}) {
//     _parameters['sortBy'] = attributeCode;
//     _parameters['sortDirection'] = ascending ? 'asc' : 'desc';
//     return this;
//   }
//
//   /// Adds pagination to the query.
//   ///
//   /// Parameters:
//   /// - [page]: The page number to retrieve (1-based)
//   /// - [pageSize]: The number of items per page
//   ///
//   /// Returns this builder for chaining.
//   QueryBuilder paginate(int page, int pageSize) {
//     _parameters['page'] = page;
//     _parameters['pageSize'] = pageSize;
//     return this;
//   }
//
//   /// Sets the current expression.
//   ///
//   /// This is an internal method used by the filter builders.
//   ///
//   /// Parameters:
//   /// - [expression]: The expression to set
//   void _setExpression(QueryExpression expression) {
//     if (_expression == null) {
//       _expression = expression;
//     } else {
//       _expression = LogicalExpression(_expression!, expression, LogicalOperator.and);
//     }
//   }
//
//   /// Adds a logical AND with another filter.
//   ///
//   /// This method adds an AND clause to the query and starts a new attribute filter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns an attribute filter builder for chaining.
//   AttributeFilterBuilder and(String attributeCode) {
//     return AttributeFilterBuilder(this, attributeCode, isAnd: true);
//   }
//
//   /// Adds a logical OR with another filter.
//   ///
//   /// This method adds an OR clause to the query and starts a new attribute filter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns an attribute filter builder for chaining.
//   AttributeFilterBuilder or(String attributeCode) {
//     return AttributeFilterBuilder(this, attributeCode, isOr: true);
//   }
//
//   /// Adds a logical AND with a relationship filter.
//   ///
//   /// This method adds an AND clause to the query and starts a relationship traversal.
//   ///
//   /// Parameters:
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   ///
//   /// Returns a relationship builder for chaining.
//   RelationshipBuilder andWhere(String relationshipCode, RelationshipType relationshipType) {
//     return RelationshipBuilder(this, relationshipCode, relationshipType, isAnd: true);
//   }
//
//   /// Adds a logical OR with a relationship filter.
//   ///
//   /// This method adds an OR clause to the query and starts a relationship traversal.
//   ///
//   /// Parameters:
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   ///
//   /// Returns a relationship builder for chaining.
//   RelationshipBuilder orWhere(String relationshipCode, RelationshipType relationshipType) {
//     return RelationshipBuilder(this, relationshipCode, relationshipType, isOr: true);
//   }
//
//   /// Builds the final query.
//   ///
//   /// This method creates an [ExpressionQuery] from the built expression
//   /// and parameters.
//   ///
//   /// Returns the built query.
//   ExpressionQuery build() {
//     if (_expression == null) {
//       // If no expression has been set, create a default that matches everything
//       _expression = ConstantExpression(true);
//     }
//
//     return ExpressionQuery(_name, _concept, _expression!, _parameters);
//   }
// }
//
// /// Builder for attribute filters.
// ///
// /// This class provides methods for filtering on attribute values
// /// with various comparison operators.
// class AttributeFilterBuilder {
//   /// The parent query builder.
//   final QueryBuilder _parent;
//
//   /// The attribute code to filter on.
//   final String _attributeCode;
//
//   /// Whether this is part of an AND clause.
//   final bool _isAnd;
//
//   /// Whether this is part of an OR clause.
//   final bool _isOr;
//
//   /// Creates a new attribute filter builder.
//   ///
//   /// Parameters:
//   /// - [parent]: The parent query builder
//   /// - [attributeCode]: The attribute to filter on
//   /// - [isAnd]: Whether this is part of an AND clause
//   /// - [isOr]: Whether this is part of an OR clause
//   AttributeFilterBuilder(
//     this._parent,
//     this._attributeCode, {
//     bool isAnd = false,
//     bool isOr = false,
//   })  : _isAnd = isAnd,
//         _isOr = isOr;
//
//   /// Helper method to add an expression to the parent builder.
//   ///
//   /// This method creates an attribute expression and adds it to the
//   /// parent query builder with the appropriate logical operator.
//   ///
//   /// Parameters:
//   /// - [operator]: The comparison operator
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder _addExpression(ComparisonOperator operator, dynamic value) {
//     final expression = AttributeExpression(_attributeCode, operator, value);
//
//     if (_isAnd) {
//       _parent._setExpression(LogicalExpression(_parent._expression!, expression, LogicalOperator.and));
//     } else if (_isOr) {
//       _parent._setExpression(LogicalExpression(_parent._expression!, expression, LogicalOperator.or));
//     } else {
//       _parent._setExpression(expression);
//     }
//
//     return _parent;
//   }
//
//   /// Adds an equals filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder equals(dynamic value) {
//     return _addExpression(ComparisonOperator.equals, value);
//   }
//
//   /// Adds a not equals filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder notEquals(dynamic value) {
//     return _addExpression(ComparisonOperator.notEquals, value);
//   }
//
//   /// Adds a greater than filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder greaterThan(dynamic value) {
//     return _addExpression(ComparisonOperator.greaterThan, value);
//   }
//
//   /// Adds a greater than or equal filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder greaterThanOrEqual(dynamic value) {
//     return _addExpression(ComparisonOperator.greaterThanOrEqual, value);
//   }
//
//   /// Adds a less than filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder lessThan(dynamic value) {
//     return _addExpression(ComparisonOperator.lessThan, value);
//   }
//
//   /// Adds a less than or equal filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder lessThanOrEqual(dynamic value) {
//     return _addExpression(ComparisonOperator.lessThanOrEqual, value);
//   }
//
//   /// Adds a contains filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The substring to check for
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder contains(String value) {
//     return _addExpression(ComparisonOperator.contains, value);
//   }
//
//   /// Adds a starts with filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The prefix to check for
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder startsWith(String value) {
//     return _addExpression(ComparisonOperator.startsWith, value);
//   }
//
//   /// Adds an ends with filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The suffix to check for
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder endsWith(String value) {
//     return _addExpression(ComparisonOperator.endsWith, value);
//   }
//
//   /// Adds a null check filter.
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder isNull() {
//     return _addExpression(ComparisonOperator.isNull, null);
//   }
//
//   /// Adds a not null check filter.
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder isNotNull() {
//     return _addExpression(ComparisonOperator.isNotNull, null);
//   }
//
//   /// Adds an in list filter.
//   ///
//   /// Parameters:
//   /// - [values]: The list of values to check against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder inList(List<dynamic> values) {
//     return _addExpression(ComparisonOperator.inList, values);
//   }
//
//   /// Adds a not in list filter.
//   ///
//   /// Parameters:
//   /// - [values]: The list of values to check against
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder notInList(List<dynamic> values) {
//     return _addExpression(ComparisonOperator.notInList, values);
//   }
//
//   /// Adds a between filter.
//   ///
//   /// Parameters:
//   /// - [min]: The minimum value (inclusive)
//   /// - [max]: The maximum value (inclusive)
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder between(dynamic min, dynamic max) {
//     return _addExpression(ComparisonOperator.between, [min, max]);
//   }
// }
//
// /// Builder for relationship filters.
// ///
// /// This class provides methods for filtering entities based on
// /// their relationships with other entities.
// class RelationshipBuilder {
//   /// The parent query builder.
//   final QueryBuilder _parent;
//
//   /// The relationship code to traverse.
//   final String _relationshipCode;
//
//   /// The type of relationship.
//   final RelationshipType _relationshipType;
//
//   /// Whether this is part of an AND clause.
//   final bool _isAnd;
//
//   /// Whether this is part of an OR clause.
//   final bool _isOr;
//
//   /// The current nested expression being built.
//   QueryExpression? _nestedExpression;
//
//   /// Creates a new relationship builder.
//   ///
//   /// Parameters:
//   /// - [parent]: The parent query builder
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   /// - [isAnd]: Whether this is part of an AND clause
//   /// - [isOr]: Whether this is part of an OR clause
//   RelationshipBuilder(
//     this._parent,
//     this._relationshipCode,
//     this._relationshipType, {
//     bool isAnd = false,
//     bool isOr = false,
//   })  : _isAnd = isAnd,
//         _isOr = isOr;
//
//   /// Helper method to set a nested expression.
//   ///
//   /// This method stores a nested expression for use in the relationship.
//   ///
//   /// Parameters:
//   /// - [expression]: The expression to set
//   void _setNestedExpression(QueryExpression expression) {
//     if (_nestedExpression == null) {
//       _nestedExpression = expression;
//     } else {
//       _nestedExpression = LogicalExpression(_nestedExpression!, expression, LogicalOperator.and);
//     }
//   }
//
//   /// Finalizes the relationship expression and adds it to the parent builder.
//   ///
//   /// This method creates a relationship expression from the nested expression
//   /// and adds it to the parent query builder.
//   ///
//   /// Returns the parent query builder.
//   QueryBuilder _finalize() {
//     if (_nestedExpression == null) {
//       // If no nested expression, create a default that matches everything
//       _nestedExpression = ConstantExpression(true);
//     }
//
//     final relationshipExpression = RelationshipExpression(
//       _relationshipCode,
//       _relationshipType,
//       _nestedExpression!
//     );
//
//     if (_isAnd) {
//       _parent._setExpression(LogicalExpression(_parent._expression!, relationshipExpression, LogicalOperator.and));
//     } else if (_isOr) {
//       _parent._setExpression(LogicalExpression(_parent._expression!, relationshipExpression, LogicalOperator.or));
//     } else {
//       _parent._setExpression(relationshipExpression);
//     }
//
//     return _parent;
//   }
//
//   /// Starts an attribute filter on the related entity.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns a nested attribute filter builder.
//   NestedAttributeFilterBuilder where(String attributeCode) {
//     return NestedAttributeFilterBuilder(this, attributeCode);
//   }
//
//   /// Adds a nested relationship filter.
//   ///
//   /// This method allows traversing multiple relationships in a chain.
//   ///
//   /// Parameters:
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   ///
//   /// Returns a nested relationship builder.
//   NestedRelationshipBuilder andRelated(String relationshipCode, RelationshipType relationshipType) {
//     return NestedRelationshipBuilder(this, relationshipCode, relationshipType);
//   }
//
//   /// Adds a logical AND with another attribute filter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns a nested attribute filter builder.
//   NestedAttributeFilterBuilder and(String attributeCode) {
//     return NestedAttributeFilterBuilder(this, attributeCode, isAnd: true);
//   }
//
//   /// Adds a logical OR with another attribute filter.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns a nested attribute filter builder.
//   NestedAttributeFilterBuilder or(String attributeCode) {
//     return NestedAttributeFilterBuilder(this, attributeCode, isOr: true);
//   }
//
//   /// Completes the relationship filter and returns to the parent builder.
//   ///
//   /// Returns the parent query builder for chaining.
//   QueryBuilder end() {
//     return _finalize();
//   }
// }
//
// /// Builder for nested attribute filters within a relationship.
// ///
// /// This class provides methods for filtering attributes of related entities.
// class NestedAttributeFilterBuilder {
//   /// The parent relationship builder.
//   final RelationshipBuilder _parent;
//
//   /// The attribute code to filter on.
//   final String _attributeCode;
//
//   /// Whether this is part of an AND clause.
//   final bool _isAnd;
//
//   /// Whether this is part of an OR clause.
//   final bool _isOr;
//
//   /// Creates a new nested attribute filter builder.
//   ///
//   /// Parameters:
//   /// - [parent]: The parent relationship builder
//   /// - [attributeCode]: The attribute to filter on
//   /// - [isAnd]: Whether this is part of an AND clause
//   /// - [isOr]: Whether this is part of an OR clause
//   NestedAttributeFilterBuilder(
//     this._parent,
//     this._attributeCode, {
//     bool isAnd = false,
//     bool isOr = false,
//   })  : _isAnd = isAnd,
//         _isOr = isOr;
//
//   /// Helper method to add an expression to the parent relationship builder.
//   ///
//   /// This method creates an attribute expression and adds it to the
//   /// parent relationship builder with the appropriate logical operator.
//   ///
//   /// Parameters:
//   /// - [operator]: The comparison operator
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder _addExpression(ComparisonOperator operator, dynamic value) {
//     final expression = AttributeExpression(_attributeCode, operator, value);
//
//     if (_isAnd) {
//       final parentExpr = _parent._nestedExpression;
//       if (parentExpr != null) {
//         _parent._setNestedExpression(LogicalExpression(parentExpr, expression, LogicalOperator.and));
//       } else {
//         _parent._setNestedExpression(expression);
//       }
//     } else if (_isOr) {
//       final parentExpr = _parent._nestedExpression;
//       if (parentExpr != null) {
//         _parent._setNestedExpression(LogicalExpression(parentExpr, expression, LogicalOperator.or));
//       } else {
//         _parent._setNestedExpression(expression);
//       }
//     } else {
//       _parent._setNestedExpression(expression);
//     }
//
//     return _parent;
//   }
//
//   /// Adds an equals filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder equals(dynamic value) {
//     return _addExpression(ComparisonOperator.equals, value);
//   }
//
//   /// Adds a not equals filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder notEquals(dynamic value) {
//     return _addExpression(ComparisonOperator.notEquals, value);
//   }
//
//   /// Adds a greater than filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder greaterThan(dynamic value) {
//     return _addExpression(ComparisonOperator.greaterThan, value);
//   }
//
//   /// Adds a greater than or equal filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder greaterThanOrEqual(dynamic value) {
//     return _addExpression(ComparisonOperator.greaterThanOrEqual, value);
//   }
//
//   /// Adds a less than filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder lessThan(dynamic value) {
//     return _addExpression(ComparisonOperator.lessThan, value);
//   }
//
//   /// Adds a less than or equal filter.
//   ///
//   /// Parameters:
//   /// - [value]: The value to compare against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder lessThanOrEqual(dynamic value) {
//     return _addExpression(ComparisonOperator.lessThanOrEqual, value);
//   }
//
//   /// Adds a contains filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The substring to check for
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder contains(String value) {
//     return _addExpression(ComparisonOperator.contains, value);
//   }
//
//   /// Adds a starts with filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The prefix to check for
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder startsWith(String value) {
//     return _addExpression(ComparisonOperator.startsWith, value);
//   }
//
//   /// Adds an ends with filter for string attributes.
//   ///
//   /// Parameters:
//   /// - [value]: The suffix to check for
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder endsWith(String value) {
//     return _addExpression(ComparisonOperator.endsWith, value);
//   }
//
//   /// Adds a null check filter.
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder isNull() {
//     return _addExpression(ComparisonOperator.isNull, null);
//   }
//
//   /// Adds a not null check filter.
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder isNotNull() {
//     return _addExpression(ComparisonOperator.isNotNull, null);
//   }
//
//   /// Adds an in list filter.
//   ///
//   /// Parameters:
//   /// - [values]: The list of values to check against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder inList(List<dynamic> values) {
//     return _addExpression(ComparisonOperator.inList, values);
//   }
//
//   /// Adds a not in list filter.
//   ///
//   /// Parameters:
//   /// - [values]: The list of values to check against
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder notInList(List<dynamic> values) {
//     return _addExpression(ComparisonOperator.notInList, values);
//   }
//
//   /// Adds a between filter.
//   ///
//   /// Parameters:
//   /// - [min]: The minimum value (inclusive)
//   /// - [max]: The maximum value (inclusive)
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder between(dynamic min, dynamic max) {
//     return _addExpression(ComparisonOperator.between, [min, max]);
//   }
// }
//
// /// Builder for nested relationship traversals.
// ///
// /// This class provides methods for traversing relationships of related entities.
// class NestedRelationshipBuilder {
//   /// The parent relationship builder.
//   final RelationshipBuilder _parent;
//
//   /// The relationship code to traverse.
//   final String _relationshipCode;
//
//   /// The type of relationship.
//   final RelationshipType _relationshipType;
//
//   /// The nested expression being built.
//   QueryExpression? _nestedExpression;
//
//   /// Creates a new nested relationship builder.
//   ///
//   /// Parameters:
//   /// - [parent]: The parent relationship builder
//   /// - [relationshipCode]: The relationship to traverse
//   /// - [relationshipType]: The type of relationship
//   NestedRelationshipBuilder(
//     this._parent,
//     this._relationshipCode,
//     this._relationshipType
//   );
//
//   /// Helper method to set a nested expression.
//   ///
//   /// This method stores a nested expression for use in the relationship.
//   ///
//   /// Parameters:
//   /// - [expression]: The expression to set
//   void _setNestedExpression(QueryExpression expression) {
//     if (_nestedExpression == null) {
//       _nestedExpression = expression;
//     } else {
//       _nestedExpression = LogicalExpression(_nestedExpression!, expression, LogicalOperator.and);
//     }
//   }
//
//   /// Finalizes the nested relationship expression and adds it to the parent builder.
//   ///
//   /// This method creates a relationship expression from the nested expression
//   /// and adds it to the parent relationship builder.
//   ///
//   /// Returns the parent relationship builder.
//   RelationshipBuilder _finalize() {
//     if (_nestedExpression == null) {
//       // If no nested expression, create a default that matches everything
//       _nestedExpression = ConstantExpression(true);
//     }
//
//     final relationshipExpression = RelationshipExpression(
//       _relationshipCode,
//       _relationshipType,
//       _nestedExpression!
//     );
//
//     _parent._setNestedExpression(relationshipExpression);
//
//     return _parent;
//   }
//
//   /// Starts an attribute filter on the related entity.
//   ///
//   /// Parameters:
//   /// - [attributeCode]: The attribute to filter on
//   ///
//   /// Returns a nested attribute filter builder.
//   NestedAttributeFilterBuilder where(String attributeCode) {
//     return NestedAttributeFilterBuilder(this, attributeCode);
//   }
//
//   /// Completes the nested relationship filter and returns to the parent builder.
//   ///
//   /// Returns the parent relationship builder for chaining.
//   RelationshipBuilder end() {
//     return _finalize();
//   }
// }
//
// /// Extension on NestedAttributeFilterBuilder to redirect methods to the nested relationship builder.
// extension NestedAttributeFilterBuilderExtension on NestedAttributeFilterBuilder {
//   /// Redirects the _addExpression method to work with a NestedRelationshipBuilder.
//   ///
//   /// This extension allows the same fluent API to be used with nested relationship traversals.
//   RelationshipBuilder _addExpression(ComparisonOperator operator, dynamic value) {
//     final expression = AttributeExpression(_attributeCode, operator, value);
//
//     if (_parent is NestedRelationshipBuilder) {
//       final nestedParent = _parent as NestedRelationshipBuilder;
//
//       if (_isAnd) {
//         final parentExpr = nestedParent._nestedExpression;
//         if (parentExpr != null) {
//           nestedParent._setNestedExpression(LogicalExpression(parentExpr, expression, LogicalOperator.and));
//         } else {
//           nestedParent._setNestedExpression(expression);
//         }
//       } else if (_isOr) {
//         final parentExpr = nestedParent._nestedExpression;
//         if (parentExpr != null) {
//           nestedParent._setNestedExpression(LogicalExpression(parentExpr, expression, LogicalOperator.or));
//         } else {
//           nestedParent._setNestedExpression(expression);
//         }
//       } else {
//         nestedParent._setNestedExpression(expression);
//       }
//
//       return nestedParent;
//     }
//
//     return _parent;
//   }
// }

========================================

=== queries/query_dispatcher.dart ===

// part of ednet_core;
//
// /// Dispatches queries to their appropriate handlers.
// ///
// /// The [QueryDispatcher] class is responsible for routing queries to their
// /// registered handlers, providing a centralized entry point for query processing.
// /// This follows the mediator pattern, decoupling query senders from handlers.
// ///
// /// This dispatcher serves as the single unified query handling mechanism for both
// /// domain model and application layers, eliminating duplication and inconsistency.
// ///
// /// Example usage:
// /// ```dart
// /// final dispatcher = QueryDispatcher();
// /// dispatcher.registerHandler<FindTasksByStatusQuery, TasksQueryResult>(
// ///   findTasksHandler
// /// );
// ///
// /// // Later, dispatch a query
// /// final result = await dispatcher.dispatch(FindTasksByStatusQuery('completed'));
// /// ```
// class QueryDispatcher {
//   /// Map of query types to their handlers
//   final Map<Type, IQueryHandler> _handlers = {};
//
//   /// Map of concept codes to their handlers
//   final Map<String, Map<String, IQueryHandler>> _conceptHandlers = {};
//
//   /// Map of query names to handlers (for application-level queries without concepts)
//   final Map<String, IQueryHandler> _namedHandlers = {};
//
//   /// Registers a query handler for a specific query type.
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to handle
//   /// - [R]: The type of result the handler returns
//   ///
//   /// Parameters:
//   /// - [handler]: The handler to register
//   void registerHandler<Q extends IQuery, R extends IQueryResult>(
//     IQueryHandler<Q, R> handler
//   ) {
//     _handlers[Q] = handler;
//   }
//
//   /// Registers a query handler for a specific concept and query name.
//   ///
//   /// This enables dispatching queries based on concept code and query name,
//   /// which is useful for dynamic query handling based on metadata.
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to handle
//   /// - [R]: The type of result the handler returns
//   ///
//   /// Parameters:
//   /// - [conceptCode]: The code of the concept this handler targets
//   /// - [queryName]: The name of the query this handler processes
//   /// - [handler]: The handler to register
//   void registerConceptHandler<Q extends IQuery, R extends IQueryResult>(
//     String conceptCode,
//     String queryName,
//     IQueryHandler<Q, R> handler
//   ) {
//     _conceptHandlers.putIfAbsent(conceptCode, () => {});
//     _conceptHandlers[conceptCode]![queryName] = handler;
//   }
//
//   /// Registers a query handler for a specific query name without a concept.
//   ///
//   /// This is useful for application-level queries that don't target a specific concept.
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to handle
//   /// - [R]: The type of result the handler returns
//   ///
//   /// Parameters:
//   /// - [queryName]: The name of the query this handler processes
//   /// - [handler]: The handler to register
//   void registerNamedHandler<Q extends IQuery, R extends IQueryResult>(
//     String queryName,
//     IQueryHandler<Q, R> handler
//   ) {
//     _namedHandlers[queryName] = handler;
//   }
//
//   /// Dispatches a query to its registered handler.
//   ///
//   /// This method implements a dispatch strategy that tries multiple approaches:
//   /// 1. First tries concept-based dispatch if applicable
//   /// 2. Then falls back to name-based dispatch
//   /// 3. Finally tries type-based dispatch
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to dispatch
//   /// - [R]: The expected result type
//   ///
//   /// Parameters:
//   /// - [query]: The query to dispatch
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<R> dispatch<Q extends IQuery, R extends IQueryResult>(Q query) async {
//     // Try concept-based dispatch if applicable
//     if (query.conceptCode != null) {
//       final conceptHandlerMap = _conceptHandlers[query.conceptCode];
//       if (conceptHandlerMap != null) {
//         final handler = conceptHandlerMap[query.name];
//         if (handler != null) {
//           return await (handler as IQueryHandler<Q, R>).handle(query);
//         }
//       }
//     }
//
//     // Try name-based dispatch
//     final namedHandler = _namedHandlers[query.name];
//     if (namedHandler != null) {
//       return await (namedHandler as IQueryHandler<Q, R>).handle(query);
//     }
//
//     // Fall back to type-based dispatch
//     final handler = _handlers[Q];
//
//     if (handler == null) {
//       throw StateError('No handler registered for query type ${Q.toString()} with name ${query.name}');
//     }
//
//     try {
//       return await (handler as IQueryHandler<Q, R>).handle(query);
//     } catch (e) {
//       throw StateError('Error handling query: ${e.toString()}');
//     }
//   }
//
//   /// Dispatches a query using its concept code and name.
//   ///
//   /// This method is useful for dynamic query dispatching based on
//   /// concept metadata rather than static types.
//   ///
//   /// Parameters:
//   /// - [conceptCode]: The code of the concept being queried
//   /// - [queryName]: The name of the query to dispatch
//   /// - [parameters]: Query parameters
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<IQueryResult> dispatchByName(
//     String conceptCode,
//     String queryName,
//     [Map<String, dynamic>? parameters]
//   ) async {
//     final conceptHandlerMap = _conceptHandlers[conceptCode];
//     if (conceptHandlerMap == null) {
//       return QueryResult.failure(
//         'No handlers registered for concept: $conceptCode',
//         conceptCode: conceptCode,
//       );
//     }
//
//     final handler = conceptHandlerMap[queryName];
//     if (handler == null) {
//       return QueryResult.failure(
//         'No handler registered for query: $queryName in concept: $conceptCode',
//         conceptCode: conceptCode,
//       );
//     }
//
//     try {
//       // Create a dynamic query
//       final query = Query(queryName, conceptCode: conceptCode);
//       if (parameters != null) {
//         query.withParameters(parameters);
//       }
//
//       return await handler.handle(query);
//     } catch (e) {
//       return QueryResult.failure(
//         'Error handling query: ${e.toString()}',
//         conceptCode: conceptCode,
//       );
//     }
//   }
//
//   /// Dispatches a query by name without requiring a concept.
//   ///
//   /// This method is useful for application-level queries that don't target a specific concept.
//   ///
//   /// Parameters:
//   /// - [queryName]: The name of the query to dispatch
//   /// - [parameters]: Query parameters
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<IQueryResult> dispatchByNameOnly(
//     String queryName,
//     [Map<String, dynamic>? parameters]
//   ) async {
//     final handler = _namedHandlers[queryName];
//     if (handler == null) {
//       return QueryResult.failure(
//         'No handler registered for query: $queryName',
//       );
//     }
//
//     try {
//       // Create a dynamic query
//       final query = Query(queryName);
//       if (parameters != null) {
//         query.withParameters(parameters);
//       }
//
//       return await handler.handle(query);
//     } catch (e) {
//       return QueryResult.failure(
//         'Error handling query: ${e.toString()}',
//       );
//     }
//   }
// }

========================================

=== queries/query_handler/application_query_handler.dart ===

// part of ednet_core;
//
// /// Base class for application-level query handlers.
// ///
// /// This class provides a foundation for implementing query handlers that work with
// /// the unified query system, handling application-specific validation and processing.
// ///
// /// Type parameters:
// /// - [Q]: The type of query this handler processes
// /// - [R]: The type of result this handler returns
// ///
// /// Example usage:
// /// ```dart
// /// class FindActiveTasksHandler extends ApplicationQueryHandler<FindActiveTasksQuery, TaskQueryResult> {
// ///   final TaskRepository repository;
// ///
// ///   FindActiveTasksHandler(this.repository);
// ///
// ///   @override
// ///   Future<TaskQueryResult> processQuery(FindActiveTasksQuery query) async {
// ///     final tasks = await repository.findByStatus('active');
// ///     return TaskQueryResult(tasks);
// ///   }
// /// }
// /// ```
// abstract class ApplicationQueryHandler<Q extends IQuery, R extends IQueryResult> implements model.IQueryHandler<Q, R> {
//   /// Validates the query before processing.
//   ///
//   /// This method calls the query's validate method and provides additional
//   /// application-specific validation.
//   ///
//   /// Override this method to add custom validation logic.
//   ///
//   /// Parameters:
//   /// - [query]: The query to validate
//   ///
//   /// Returns true if the query is valid, false otherwise.
//   bool validateQuery(Q query) {
//     // Call the query's validate method if it's an application query
//     if (query is Query) {
//       return query.validate();
//     }
//
//     // Default to true for other query types
//     return true;
//   }
//
//   /// Process the validated query and return a result.
//   ///
//   /// Implement this method to define the core query handling logic.
//   ///
//   /// Parameters:
//   /// - [query]: The validated query to process
//   ///
//   /// Returns a Future with the query result.
//   Future<R> processQuery(Q query);
//
//   @override
//   Future<R> handle(Q query) async {
//     // Validate the query
//     if (!validateQuery(query)) {
//       // Create a failure result
//       // This is a bit complex due to type erasure in Dart
//       dynamic result;
//
//       if (R == model.QueryResult || R == model.EntityQueryResult) {
//         result = model.QueryResult.failure('Query validation failed');
//       } else if (R == QueryResult) {
//         result = QueryResult.failure('Query validation failed');
//       } else {
//         throw StateError('Cannot create failure result for type $R');
//       }
//
//       return result as R;
//     }
//
//     try {
//       // Process the query
//       return await processQuery(query);
//     } catch (e) {
//       // Handle exceptions
//       dynamic result;
//
//       if (R == model.QueryResult || R == model.EntityQueryResult) {
//         result = model.QueryResult.failure('Query processing failed: $e');
//       } else if (R == QueryResult) {
//         result = QueryResult.failure('Query processing failed: $e');
//       } else {
//         throw StateError('Cannot create failure result for type $R');
//       }
//
//       return result as R;
//     }
//   }
// }

========================================

=== queries/query_handler/base_query_handler.dart ===

// part of ednet_core;
//
// /// Base implementation of the query handler interface.
// ///
// /// This class provides a foundation for all query handlers in the application layer,
// /// implementing common functionality like validation, authorization, and error handling.
// ///
// /// Example usage:
// /// ```dart
// /// class FindTasksByStatusHandler extends BaseQueryHandler<FindTasksByStatusQuery, TasksQueryResult> {
// ///   final TaskRepository repository;
// ///
// ///   FindTasksByStatusHandler(this.repository);
// ///
// ///   @override
// ///   Future<TasksQueryResult> executeQuery(FindTasksByStatusQuery query) async {
// ///     try {
// ///       final tasks = await repository.findByStatus(query.status);
// ///       return TasksQueryResult.success(tasks);
// ///     } catch (e) {
// ///       return TasksQueryResult.failure('Failed to find tasks: $e');
// ///     }
// ///   }
// /// }
// /// ```
// abstract class BaseQueryHandler<Q extends IQuery, R extends IQueryResult>
//     implements IQueryHandler<Q, R> {
//
//   /// Handles a query and returns a result.
//   ///
//   /// This implementation follows a template method pattern:
//   /// 1. Validates the query
//   /// 2. Performs authorization checks
//   /// 3. Executes the query
//   /// 4. Returns the result
//   ///
//   /// Parameters:
//   /// - [query]: The query to handle
//   ///
//   /// Returns:
//   /// A Future with the query result
//   @override
//   Future<R> handle(covariant Q query) async {
//     try {
//       // Validation
//       if (!validateQuery(query)) {
//         return createFailureResult('Query validation failed') as R;
//       }
//
//       // Authorization
//       if (!authorizeExecution(query)) {
//         return createFailureResult('Not authorized to execute this query') as R;
//       }
//
//       // Execution
//       return await executeQuery(query);
//     } catch (e) {
//       return createFailureResult('Error handling query: $e') as R;
//     }
//   }
//
//   /// Validates a query before processing.
//   ///
//   /// The default implementation checks the query's validate() method,
//   /// but subclasses can override this for more complex validation.
//   ///
//   /// Parameters:
//   /// - [query]: The query to validate
//   ///
//   /// Returns:
//   /// True if the query is valid, false otherwise
//   @override
//   bool validateQuery(Q query) {
//     return query.validate();
//   }
//
//   /// Authorizes the execution of a query.
//   ///
//   /// The default implementation allows all queries,
//   /// but subclasses should override this for proper authorization.
//   ///
//   /// Parameters:
//   /// - [query]: The query to authorize
//   ///
//   /// Returns:
//   /// True if execution is authorized, false otherwise
//   @override
//   bool authorizeExecution(Q query) {
//     return true;
//   }
//
//   /// Creates a failure result with the given error message.
//   ///
//   /// This method should be implemented by subclasses to create
//   /// the appropriate failure result for their result type.
//   ///
//   /// Parameters:
//   /// - [errorMessage]: The error message
//   ///
//   /// Returns:
//   /// A failure result
//   IQueryResult createFailureResult(String errorMessage);
//
//   /// Executes the query and returns a result.
//   ///
//   /// This method should implement the actual query execution logic,
//   /// retrieving data from repositories or other sources.
//   ///
//   /// Parameters:
//   /// - [query]: The query to execute
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<R> executeQuery(Q query);
// }

========================================

=== queries/query_handler/concept_query_handler.dart ===

// part of ednet_core;
//
// /// Base implementation for concept-specific query handlers.
// ///
// /// This class extends [BaseQueryHandler] with capabilities
// /// specifically designed for handling concept-specific queries,
// /// including validation against concept attributes.
// ///
// /// Type parameters:
// /// - [T]: The type of entity being queried
// ///
// /// Example usage:
// /// ```dart
// /// class FindTasksByStatusHandler extends ConceptQueryHandler<Task> {
// ///   FindTasksByStatusHandler(Repository<Task> repository, Concept concept)
// ///     : super(repository, concept);
// ///
// ///   @override
// ///   Future<EntityQueryResult<Task>> executeConceptQuery(
// ///     model.ConceptQuery query
// ///   ) async {
// ///     final status = query.getParameters()['status'];
// ///     final tasks = await repository.findByStatus(status);
// ///     return EntityQueryResult.success(tasks, concept: concept);
// ///   }
// /// }
// /// ```
// abstract class ConceptQueryHandler<T extends AggregateRoot>
//     extends BaseQueryHandler<model.ConceptQuery, model.EntityQueryResult<T>> {
//
//   /// The repository for accessing entities.
//   final Repository<T> repository;
//
//   /// The concept this handler processes queries for.
//   final model.Concept concept;
//
//   /// Creates a new concept query handler.
//   ///
//   /// Parameters:
//   /// - [repository]: Repository for accessing entities
//   /// - [concept]: The concept this handler processes queries for
//   ConceptQueryHandler(this.repository, this.concept);
//
//   /// Creates a failure result with the given error message.
//   ///
//   /// Parameters:
//   /// - [errorMessage]: The error message
//   ///
//   /// Returns a concept-aware failure result
//   @override
//   model.IQueryResult createFailureResult(String errorMessage) {
//     return model.EntityQueryResult<T>.failure(
//       errorMessage,
//       concept: concept,
//     );
//   }
//
//   /// Validates the query against the concept's structure.
//   ///
//   /// This method uses the concept query's validate method,
//   /// which checks attribute compatibility.
//   ///
//   /// Parameters:
//   /// - [query]: The query to validate
//   ///
//   /// Returns true if the query is valid, false otherwise
//   @override
//   bool validateQuery(model.ConceptQuery query) {
//     // Check that the query is for this concept
//     if (query.conceptCode != concept.code) {
//       return false;
//     }
//
//     return query.validate();
//   }
//
//   /// Authorizes the execution of a query.
//   ///
//   /// This implementation checks if any attribute in the query
//   /// is marked as sensitive, and if so, requires additional authorization.
//   ///
//   /// Parameters:
//   /// - [query]: The query to authorize
//   ///
//   /// Returns true if execution is authorized, false otherwise
//   @override
//   bool authorizeExecution(model.ConceptQuery query) {
//     // Check for sensitive attributes
//     for (String key in query.getParameters().keys) {
//       if (concept.isAttributeSensitive(key)) {
//         return hasPermissionForSensitiveData();
//       }
//     }
//
//     return true;
//   }
//
//   /// Checks if the current context has permission to access sensitive data.
//   ///
//   /// This method should be overridden by subclasses to implement
//   /// proper authorization logic.
//   ///
//   /// Returns true if the current context has permission, false otherwise
//   bool hasPermissionForSensitiveData() {
//     // Default implementation allows access
//     // Subclasses should override this with proper authorization logic
//     return true;
//   }
//
//   /// Handles a concept query and returns a result.
//   ///
//   /// This method delegates to the base class handle method,
//   /// which implements the template method pattern.
//   ///
//   /// Parameters:
//   /// - [query]: The query to handle
//   ///
//   /// Returns a Future with the query result
//   @override
//   Future<model.EntityQueryResult<T>> handle(model.ConceptQuery query) {
//     return super.handle(query);
//   }
//
//   /// Executes the query and returns a result.
//   ///
//   /// This method does the actual query execution,
//   /// after validation and authorization have passed.
//   ///
//   /// Parameters:
//   /// - [query]: The query to execute
//   ///
//   /// Returns a Future with the query result
//   @override
//   Future<model.EntityQueryResult<T>> executeQuery(model.ConceptQuery query) {
//     return executeConceptQuery(query);
//   }
//
//   /// Executes a concept query and returns an entity result.
//   ///
//   /// This method should be implemented by subclasses to
//   /// handle specific query types.
//   ///
//   /// Parameters:
//   /// - [query]: The concept query to execute
//   ///
//   /// Returns a Future with the entity query result
//   Future<model.EntityQueryResult<T>> executeConceptQuery(model.ConceptQuery query);
// }

========================================

=== queries/query_handler/default_concept_query_handler.dart ===

// part of ednet_core;
//
// /// Standard implementation of a concept query handler that supports common queries.
// ///
// /// This class extends [ConceptQueryHandler] with implementations of
// /// standard query operations like findAll, findById, and findByCriteria.
// ///
// /// Type parameters:
// /// - [T]: The type of entity being queried
// ///
// /// Example usage:
// /// ```dart
// /// final handler = DefaultConceptQueryHandler<Task>(
// ///   taskRepository,
// ///   taskConcept,
// /// );
// ///
// /// // Register with query dispatcher
// /// dispatcher.registerConceptHandler<model.ConceptQuery, model.EntityQueryResult<Task>>(
// ///   'Task',
// ///   'FindAll',
// ///   handler
// /// );
// /// ```
// class DefaultConceptQueryHandler<T extends AggregateRoot> extends ConceptQueryHandler<T> {
//   /// Standard query names supported by this handler
//   static const String FIND_ALL = 'FindAll';
//   static const String FIND_BY_ID = 'FindById';
//   static const String FIND_BY_CRITERIA = 'FindByCriteria';
//
//   /// Creates a new default concept query handler.
//   ///
//   /// Parameters:
//   /// - [repository]: Repository for accessing entities
//   /// - [concept]: The concept this handler processes queries for
//   DefaultConceptQueryHandler(
//     Repository<T> repository,
//     model.Concept concept,
//   ) : super(repository, concept);
//
//   /// Executes a concept query, dispatching to the appropriate method
//   /// based on the query name.
//   ///
//   /// Supports the following standard queries:
//   /// - FindAll: Returns all entities
//   /// - FindById: Returns a single entity by ID
//   /// - FindByCriteria: Returns entities matching criteria derived from parameters
//   ///
//   /// Parameters:
//   /// - [query]: The concept query to execute
//   ///
//   /// Returns a Future with the entity query result
//   @override
//   Future<model.EntityQueryResult<T>> executeConceptQuery(model.ConceptQuery query) async {
//     switch (query.name) {
//       case FIND_ALL:
//         return _handleFindAll(query);
//       case FIND_BY_ID:
//         return _handleFindById(query);
//       case FIND_BY_CRITERIA:
//         return _handleFindByCriteria(query);
//       default:
//         return model.EntityQueryResult.failure(
//           'Unsupported query name: ${query.name}',
//           concept: concept,
//         );
//     }
//   }
//
//   /// Handles the FindAll query.
//   ///
//   /// Returns all entities of this concept, with optional pagination.
//   ///
//   /// Parameters:
//   /// - [query]: The query containing pagination parameters
//   ///
//   /// Returns a Future with the entity query result
//   Future<model.EntityQueryResult<T>> _handleFindAll(model.ConceptQuery query) async {
//     try {
//       // Extract pagination parameters if present
//       final page = query.getParameters()['page'] as int?;
//       final pageSize = query.getParameters()['pageSize'] as int?;
//
//       if (page != null && pageSize != null) {
//         // Get count for pagination
//         final totalCount = await repository.count();
//
//         // Get paginated results
//         final results = await repository.findAll(
//           skip: (page - 1) * pageSize,
//           take: pageSize,
//         );
//
//         return model.EntityQueryResult.success(
//           results,
//           concept: concept,
//           metadata: {
//             'page': page,
//             'pageSize': pageSize,
//             'totalCount': totalCount,
//           },
//         );
//       } else {
//         // Get all results
//         final results = await repository.findAll();
//         return model.EntityQueryResult.success(
//           results,
//           concept: concept,
//         );
//       }
//     } catch (e) {
//       return model.EntityQueryResult.failure(
//         'Error executing FindAll query: $e',
//         concept: concept,
//       );
//     }
//   }
//
//   /// Handles the FindById query.
//   ///
//   /// Returns a single entity by ID.
//   ///
//   /// Parameters:
//   /// - [query]: The query containing the ID parameter
//   ///
//   /// Returns a Future with the entity query result
//   Future<model.EntityQueryResult<T>> _handleFindById(model.ConceptQuery query) async {
//     try {
//       // Get the ID parameter
//       final id = query.getParameters()['id'];
//       if (id == null) {
//         return model.EntityQueryResult.failure(
//           'Missing required parameter: id',
//           concept: concept,
//         );
//       }
//
//       // Find the entity
//       final entity = await repository.findById(id);
//       if (entity == null) {
//         return model.EntityQueryResult.failure(
//           'Entity not found with id: $id',
//           concept: concept,
//         );
//       }
//
//       return model.EntityQueryResult.success(
//         [entity],
//         concept: concept,
//       );
//     } catch (e) {
//       return model.EntityQueryResult.failure(
//         'Error executing FindById query: $e',
//         concept: concept,
//       );
//     }
//   }
//
//   /// Handles the FindByCriteria query.
//   ///
//   /// Returns entities matching criteria derived from query parameters.
//   ///
//   /// Parameters:
//   /// - [query]: The query containing filter parameters
//   ///
//   /// Returns a Future with the entity query result
//   Future<model.EntityQueryResult<T>> _handleFindByCriteria(model.ConceptQuery query) async {
//     try {
//       // Extract pagination parameters if present
//       final page = query.getParameters()['page'] as int?;
//       final pageSize = query.getParameters()['pageSize'] as int?;
//
//       // Create criteria from query parameters
//       final criteria = model.FilterCriteria<T>();
//
//       // Apply filters from query parameters
//       for (var entry in query.getParameters().entries) {
//         final key = entry.key;
//         final value = entry.value;
//
//         // Skip pagination and sorting parameters
//         if (['page', 'pageSize', 'sortBy', 'sortDirection'].contains(key)) {
//           continue;
//         }
//
//         // Add criterion for this attribute
//         criteria.addCriterion(model.Criterion(key, value));
//       }
//
//       // Apply sorting if specified
//       final sortBy = query.getParameters()['sortBy'] as String?;
//       final sortDirection = query.getParameters()['sortDirection'] as String?;
//
//       if (sortBy != null) {
//         criteria.orderBy(
//           sortBy,
//           ascending: sortDirection != 'desc',
//         );
//       }
//
//       if (page != null && pageSize != null) {
//         // Get count for pagination
//         final totalCount = await repository.countByCriteria(criteria);
//
//         // Get paginated results
//         final results = await repository.findByCriteria(
//           criteria,
//           skip: (page - 1) * pageSize,
//           take: pageSize,
//         );
//
//         return model.EntityQueryResult.success(
//           results,
//           concept: concept,
//           metadata: {
//             'page': page,
//             'pageSize': pageSize,
//             'totalCount': totalCount,
//           },
//         );
//       } else {
//         // Get all results
//         final results = await repository.findByCriteria(criteria);
//         return model.EntityQueryResult.success(
//           results,
//           concept: concept,
//         );
//       }
//     } catch (e) {
//       return model.EntityQueryResult.failure(
//         'Error executing FindByCriteria query: $e',
//         concept: concept,
//       );
//     }
//   }
// }

========================================

=== queries/query_handler/expression_query_handler.dart ===

// part of ednet_core;
//
// /// Handler for expression-based queries.
// ///
// /// The [ExpressionQueryHandler] class implements the query handler interface
// /// for [ExpressionQuery] objects. It executes the query expression against
// /// entities from a repository.
// ///
// /// Example usage:
// /// ```dart
// /// final handler = ExpressionQueryHandler(productRepository, productConcept);
// /// dispatcher.registerHandler<ExpressionQuery, EntityQueryResult<Product>>(handler);
// /// ```
// class ExpressionQueryHandler<T extends Entity<T>> implements IQueryHandler<ExpressionQuery, EntityQueryResult<T>> {
//   /// The repository to query entities from.
//   final Repository<T> _repository;
//
//   /// The concept being queried.
//   final Concept _concept;
//
//   /// Creates a new expression query handler.
//   ///
//   /// Parameters:
//   /// - [repository]: The repository to query entities from
//   /// - [concept]: The concept being queried
//   ExpressionQueryHandler(this._repository, this._concept);
//
//   @override
//   Future<EntityQueryResult<T>> handle(ExpressionQuery query) async {
//     try {
//       // Validate that the query is for the correct concept
//       if (query.concept != _concept) {
//         return EntityQueryResult.failure(
//           'Query concept does not match handler concept',
//           concept: _concept,
//         );
//       }
//
//       // Get all entities from the repository
//       final allEntities = await _repository.getEntities();
//
//       // Apply the expression to filter the entities
//       final filteredEntities = query.apply(allEntities).cast<T>().toList();
//
//       // Count the total number of entities (before pagination)
//       final totalCount = filteredEntities.length;
//
//       // Return the result with metadata
//       final page = query.getParameters()['page'] as int?;
//       final pageSize = query.getParameters()['pageSize'] as int?;
//
//       if (page != null && pageSize != null && pageSize > 0) {
//         return EntityQueryResult.success(
//           filteredEntities,
//           concept: _concept,
//           metadata: {
//             'page': page,
//             'pageSize': pageSize,
//             'totalCount': totalCount,
//           },
//         );
//       } else {
//         return EntityQueryResult.success(
//           filteredEntities,
//           concept: _concept,
//         );
//       }
//     } catch (e) {
//       return EntityQueryResult.failure(
//         'Error executing query: $e',
//         concept: _concept,
//       );
//     }
//   }
// }

========================================

=== queries/query_handler/query_dispatcher.dart ===

// part of ednet_core;
//
// /// Dispatches queries to their appropriate handlers in the application layer.
// ///
// /// The [QueryDispatcher] class extends the domain model's query dispatcher,
// /// providing application-specific enhancements like validation, authorization,
// /// metrics, and logging.
// ///
// /// Example usage:
// /// ```dart
// /// final dispatcher = QueryDispatcher();
// ///
// /// // Register handlers
// /// dispatcher.registerHandler<FindTasksByStatusQuery, TasksQueryResult>(
// ///   FindTasksByStatusHandler(taskRepository)
// /// );
// ///
// /// // Execute a query
// /// final result = await dispatcher.dispatch(
// ///   FindTasksByStatusQuery('completed')
// /// );
// /// ```
// class QueryDispatcher extends model.QueryDispatcher {
//   /// Registry of query handlers by their query types
//   final Map<Type, IQueryHandler> _appHandlers = {};
//
//   /// Registers a query handler for a specific query type.
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to handle
//   /// - [R]: The type of result the handler returns
//   ///
//   /// Parameters:
//   /// - [handler]: The handler to register
//   void registerHandler<Q extends IQuery, R extends IQueryResult>(
//     IQueryHandler<Q, R> handler
//   ) {
//     _appHandlers[Q] = handler;
//
//     // Register with the base class as well for compatibility
//     super.registerHandler<Q, R>(handler as model.IQueryHandler<Q, R>);
//   }
//
//   /// Dispatches a query to its registered handler.
//   ///
//   /// This method:
//   /// 1. Finds the appropriate handler for the query type
//   /// 2. Records metrics about the query execution
//   /// 3. Handles any errors that occur during processing
//   ///
//   /// Type parameters:
//   /// - [Q]: The type of query to dispatch
//   /// - [R]: The expected result type
//   ///
//   /// Parameters:
//   /// - [query]: The query to dispatch
//   ///
//   /// Returns:
//   /// A Future with the query result
//   Future<R> dispatch<Q extends IQuery, R extends IQueryResult>(Q query) async {
//     final stopwatch = Stopwatch()..start();
//
//     try {
//       final handler = _appHandlers[Q];
//
//       if (handler == null) {
//         // Create a failure result
//         throw StateError('No handler registered for query type ${Q.toString()}');
//       }
//
//       // Execute the query
//       final result = await (handler as IQueryHandler<Q, R>).handle(query);
//
//       // Add execution time metadata
//       if (result is QueryResult<dynamic>) {
//         final newMetadata = Map<String, dynamic>.from(result.metadata)
//           ..['executionTimeMs'] = stopwatch.elapsedMilliseconds;
//
//         return QueryResult(
//           isSuccess: result.isSuccess,
//           data: result.data,
//           errorMessage: result.errorMessage,
//           metadata: newMetadata,
//         ) as R;
//       }
//
//       return result;
//     } catch (e) {
//       // Create a failure result
//       return QueryResult.failure(
//         'Error dispatching query: $e',
//         metadata: {'executionTimeMs': stopwatch.elapsedMilliseconds}
//       ) as R;
//     } finally {
//       stopwatch.stop();
//     }
//   }
// }

========================================

=== queries/query_handler/repository_query_handler.dart ===

// part of ednet_core;
//
// /// Query handler that works directly with repositories.
// ///
// /// This handler simplifies common query operations against a repository,
// /// providing standard implementations for common query patterns.
// ///
// /// Type parameters:
// /// - [T]: The entity type this handler works with
// /// - [Q]: The query type this handler processes
// /// - [R]: The result type this handler returns
// ///
// /// Example usage:
// /// ```dart
// /// final handler = RepositoryQueryHandler<Task, FindTasksQuery, EntityQueryResult<Task>>(
// ///   taskRepository,
// ///   buildCriteria: (query) => FilterCriteria<Task>()
// ///     ..addCriterion(Criterion('status', query.status))
// /// );
// ///
// /// queryDispatcher.registerHandler<FindTasksQuery, EntityQueryResult<Task>>(handler);
// /// ```
// class RepositoryQueryHandler<T extends Entity, Q extends IQuery, R extends model.EntityQueryResult<T>>
//     extends ApplicationQueryHandler<Q, R> {
//   /// The repository this handler queries.
//   final Repository<T> repository;
//
//   /// Function to build criteria from a query.
//   final FilterCriteria<T> Function(Q query)? buildCriteria;
//
//   /// Function to transform repository results before returning.
//   final List<T> Function(List<T> results, Q query)? transformResults;
//
//   /// Function to extract pagination parameters from a query.
//   final Map<String, dynamic>? Function(Q query)? extractPagination;
//
//   /// Function to extract sorting parameters from a query.
//   final Map<String, dynamic>? Function(Q query)? extractSorting;
//
//   /// The concept this handler is associated with.
//   final model.Concept? concept;
//
//   /// Creates a new repository query handler.
//   ///
//   /// Parameters:
//   /// - [repository]: The repository to query
//   /// - [buildCriteria]: Optional function to build criteria from a query
//   /// - [transformResults]: Optional function to transform results
//   /// - [extractPagination]: Optional function to extract pagination parameters
//   /// - [extractSorting]: Optional function to extract sorting parameters
//   /// - [concept]: Optional concept this handler is associated with
//   RepositoryQueryHandler(
//     this.repository, {
//     this.buildCriteria,
//     this.transformResults,
//     this.extractPagination,
//     this.extractSorting,
//     this.concept,
//   });
//
//   @override
//   Future<R> processQuery(Q query) async {
//     try {
//       // Build criteria if a builder is provided
//       FilterCriteria<T>? criteria;
//       if (buildCriteria != null) {
//         criteria = buildCriteria!(query);
//       } else {
//         // Default to empty criteria
//         criteria = FilterCriteria<T>();
//
//         // If query has parameters, try to use them
//         if (query is model.Query) {
//           // Apply filters from query parameters
//           for (var entry in query.getParameters().entries) {
//             final key = entry.key;
//             final value = entry.value;
//
//             // Skip standard parameters
//             if (['page', 'pageSize', 'sortBy', 'sortDirection'].contains(key)) {
//               continue;
//             }
//
//             // Add criterion for this parameter
//             criteria.addCriterion(model.Criterion(key, value));
//           }
//         }
//       }
//
//       // Extract pagination parameters
//       int? page;
//       int? pageSize;
//
//       if (extractPagination != null) {
//         final pagination = extractPagination!(query);
//         if (pagination != null) {
//           page = pagination['page'] as int?;
//           pageSize = pagination['pageSize'] as int?;
//         }
//       } else if (query is model.Query) {
//         // Try to get pagination from query parameters
//         page = query.getParameters()['page'] as int?;
//         pageSize = query.getParameters()['pageSize'] as int?;
//       }
//
//       // Extract sorting parameters
//       String? sortBy;
//       bool? ascending;
//
//       if (extractSorting != null) {
//         final sorting = extractSorting!(query);
//         if (sorting != null) {
//           sortBy = sorting['sortBy'] as String?;
//           final sortDirection = sorting['sortDirection'] as String?;
//           if (sortBy != null) {
//             ascending = sortDirection != 'desc';
//           }
//         }
//       } else if (query is model.Query) {
//         // Try to get sorting from query parameters
//         sortBy = query.getParameters()['sortBy'] as String?;
//         final sortDirection = query.getParameters()['sortDirection'] as String?;
//         if (sortBy != null) {
//           ascending = sortDirection != 'desc';
//         }
//       }
//
//       // Apply sorting if specified
//       if (sortBy != null && ascending != null) {
//         criteria.orderBy(sortBy, ascending: ascending);
//       }
//
//       // Execute the query
//       List<T> results;
//       int totalCount = 0;
//
//       if (page != null && pageSize != null) {
//         // Get paginated results
//         totalCount = await repository.countByCriteria(criteria);
//         results = await repository.findByCriteria(
//           criteria,
//           skip: (page - 1) * pageSize,
//           take: pageSize,
//         );
//       } else {
//         // Get all results
//         results = await repository.findByCriteria(criteria);
//         totalCount = results.length;
//       }
//
//       // Transform results if a transformer is provided
//       if (transformResults != null) {
//         results = transformResults!(results, query);
//       }
//
//       // Create metadata
//       final metadata = <String, dynamic>{};
//
//       if (page != null && pageSize != null) {
//         metadata['page'] = page;
//         metadata['pageSize'] = pageSize;
//         metadata['totalCount'] = totalCount;
//       }
//
//       // Create success result
//       // This is a bit complex due to type erasure in Dart
//       dynamic result;
//
//       // Create the appropriate result type
//       if (R == model.EntityQueryResult<T>) {
//         result = model.EntityQueryResult<T>.success(
//           results,
//           concept: concept,
//           conceptCode: concept?.code,
//           metadata: metadata,
//         );
//       } else if (R == model.QueryResult) {
//         result = model.QueryResult.success(
//           results,
//           conceptCode: concept?.code,
//           metadata: metadata,
//         );
//       } else {
//         throw StateError('Cannot create success result for type $R');
//       }
//
//       return result as R;
//     } catch (e) {
//       // Create failure result
//       dynamic result;
//
//       if (R == model.EntityQueryResult<T>) {
//         result = model.EntityQueryResult<T>.failure(
//           'Error processing query: $e',
//           concept: concept,
//           conceptCode: concept?.code,
//         );
//       } else if (R == model.QueryResult) {
//         result = model.QueryResult.failure(
//           'Error processing query: $e',
//           conceptCode: concept?.code,
//         );
//       } else {
//         throw StateError('Cannot create failure result for type $R');
//       }
//
//       return result as R;
//     }
//   }
// }

========================================

=== queries/query_handler.dart ===

// part of ednet_core;
//
// /// Interface for query handlers in the application layer.
// ///
// /// The [IQueryHandler] interface extends the domain model's query handler interface,
// /// providing application-specific enhancements like validation, authorization,
// /// and performance monitoring.
// ///
// /// This interface defines the contract for components that handle queries at the
// /// application layer, ensuring a consistent pattern for query processing.
// ///
// /// Type parameters:
// /// - [Q]: The type of query this handler processes
// /// - [R]: The type of result this handler returns
// abstract class IQueryHandler<Q extends IQuery, R extends IQueryResult>
//     implements model.IQueryHandler<model.IQuery, model.IQueryResult> {
//
//   /// Handles a query and returns a result.
//   ///
//   /// This method implements the complete query handling process:
//   /// 1. Validates the query
//   /// 2. Performs authorization checks
//   /// 3. Executes the query
//   /// 4. Formats and returns the result
//   ///
//   /// Parameters:
//   /// - [query]: The query to handle
//   ///
//   /// Returns:
//   /// A Future with the query result
//   @override
//   Future<R> handle(Q query);
//
//   /// Validates a query before processing.
//   ///
//   /// This method should implement validation logic for the query,
//   /// checking that all required parameters are present and valid.
//   ///
//   /// Parameters:
//   /// - [query]: The query to validate
//   ///
//   /// Returns:
//   /// True if the query is valid, false otherwise
//   bool validateQuery(Q query);
//
//   /// Authorizes the execution of a query.
//   ///
//   /// This method should check whether the current user or context
//   /// is authorized to execute the query.
//   ///
//   /// Parameters:
//   /// - [query]: The query to authorize
//   ///
//   /// Returns:
//   /// True if execution is authorized, false otherwise
//   bool authorizeExecution(Q query);
// }

========================================

=== queries/query_result.dart ===

// part of ednet_core;
//
// /// Represents the result of a query operation in the application layer.
// ///
// /// The [QueryResult] class extends the domain model's query result class,
// /// providing application-specific enhancements like pagination, filtering,
// /// and performance metrics.
// ///
// /// Example usage:
// /// ```dart
// /// // Create a successful result with pagination metadata
// /// final tasks = await repository.findByCriteria(criteria);
// /// return QueryResult.success(
// ///   tasks,
// ///   metadata: {
// ///     'totalCount': await repository.countByCriteria(criteria),
// ///     'page': page,
// ///     'pageSize': pageSize,
// ///     'executionTimeMs': stopwatch.elapsedMilliseconds,
// ///   }
// /// );
// /// ```
// class QueryResult<T> extends model.QueryResult<T> implements IQueryResult<T> {+
//   /// Creates a new query result.
//   ///
//   /// Parameters:
//   /// - [isSuccess]: Whether the query was successful
//   /// - [data]: The result data (null if the query failed)
//   /// - [errorMessage]: Error message (null if the query succeeded)
//   /// - [metadata]: Additional metadata for the result
//   QueryResult({
//     required bool isSuccess,
//     T? data,
//     String? errorMessage,
//     Map<String, dynamic> metadata = const {},
//   }) : super(
//     isSuccess: isSuccess,
//     data: data,
//     errorMessage: errorMessage,
//     metadata: metadata,
//   );
//
//   /// Creates a successful query result.
//   ///
//   /// Parameters:
//   /// - [data]: The result data
//   /// - [metadata]: Additional metadata for the result
//   factory QueryResult.success(T data, {Map<String, dynamic> metadata = const {}}) {
//     return QueryResult(
//       isSuccess: true,
//       data: data,
//       metadata: metadata,
//     );
//   }
//
//   /// Creates a failed query result.
//   ///
//   /// Parameters:
//   /// - [errorMessage]: The error message
//   /// - [metadata]: Additional metadata for the result
//   factory QueryResult.failure(String errorMessage, {Map<String, dynamic> metadata = const {}}) {
//     return QueryResult(
//       isSuccess: false,
//       errorMessage: errorMessage,
//       metadata: metadata,
//     );
//   }
//
//   /// Creates an empty successful result.
//   ///
//   /// This is useful for queries that don't return data but need to indicate success.
//   ///
//   /// Parameters:
//   /// - [metadata]: Additional metadata for the result
//   factory QueryResult.empty({Map<String, dynamic> metadata = const {}}) {
//     return QueryResult(
//       isSuccess: true,
//       metadata: metadata,
//     );
//   }
//
//   /// Adds pagination metadata to the result.
//   ///
//   /// Parameters:
//   /// - [page]: The current page number
//   /// - [pageSize]: The number of items per page
//   /// - [totalCount]: The total number of items
//   ///
//   /// Returns:
//   /// A new query result with updated metadata
//   QueryResult<T> withPagination({
//     required int page,
//     required int pageSize,
//     required int totalCount,
//   }) {
//     final newMetadata = Map<String, dynamic>.from(metadata)
//       ..addAll({
//         'page': page,
//         'pageSize': pageSize,
//         'totalCount': totalCount,
//         'totalPages': (totalCount / pageSize).ceil(),
//       });
//
//     return QueryResult(
//       isSuccess: isSuccess,
//       data: data,
//       errorMessage: errorMessage,
//       metadata: newMetadata,
//     );
//   }
// }
//
// /// Interface for application-level query results.
// ///
// /// This interface extends the domain model query result interface,
// /// providing a contract for application-specific result capabilities.
// abstract class IQueryResult<T> implements model.IQueryResult<T> {
//   /// Creates a new query result with updated pagination information.
//   ///
//   /// Parameters:
//   /// - [page]: The current page number
//   /// - [pageSize]: The number of items per page
//   /// - [totalCount]: The total number of items
//   ///
//   /// Returns:
//   /// A new query result with updated metadata
//   IQueryResult<T> withPagination({
//     required int page,
//     required int pageSize,
//     required int totalCount,
//   });
// }

========================================

=== reference.dart ===

part of ednet_core;

/// A class representing a reference to a parent entity in the domain model.
///
/// The [Reference] class is used to maintain relationships between entities by storing:
/// - The parent entity's OID (Object Identifier)
/// - The parent entity's concept code
/// - The entry concept code of the parent entity
///
/// This class is particularly useful in:
/// - Maintaining entity relationships
/// - Navigating between related entities
/// - Persistence and serialization scenarios
/// - Cross-aggregate references
///
/// Example usage:
/// ```dart
/// final reference = Reference(
///   '1234567890',  // parent OID timestamp
///   'Product',     // parent concept code
///   'Entry'        // entry concept code
/// );
///
/// final parentOid = reference.oid;
/// ```
class Reference {
  /// The string representation of the parent entity's OID timestamp.
  final String parentOidString;

  /// The code identifying the parent entity's concept.
  final String parentConceptCode;

  /// The code identifying the entry concept of the parent entity.
  final String entryConceptCode;

  /// Creates a new [Reference] instance.
  ///
  /// [parentOidString] is the string representation of the parent entity's OID timestamp.
  /// [parentConceptCode] is the code identifying the parent entity's concept.
  /// [entryConceptCode] is the code identifying the entry concept of the parent entity.
  Reference(
    this.parentOidString,
    this.parentConceptCode,
    this.entryConceptCode,
  );

  /// Creates a reference from an entity.
  ///
  /// This factory method creates a reference directly from an entity,
  /// making it easier to establish relationships between entities.
  ///
  /// [entity] is the entity to create a reference to.
  /// Returns a new [Reference] to the entity.
  factory Reference.fromEntity(Entity entity) {
    return Reference(
      entity.oid.toString(),
      entity.concept.code,
      entity.concept.entryConcept.code,
    );
  }

  /// Gets the [Oid] object from the parent OID string.
  ///
  /// Converts the string timestamp to an integer and creates a new [Oid] instance.
  /// Throws [TypeException] if the OID string cannot be parsed as an integer.
  Oid get oid {
    int parentTimeStamp;
    try {
      parentTimeStamp = int.parse(parentOidString);
    } on FormatException catch (e) {
      throw TypeException('$parentConceptCode parent oid is not int: $e');
    }
    return Oid.ts(parentTimeStamp);
  }

  /// Returns a string representation of this reference.
  ///
  /// Returns a more detailed string representation that includes
  /// both the parent concept code and the OID.
  @override
  String toString() {
    return '$parentConceptCode:$parentOidString';
  }

  /// Compares this reference with [other] for equality.
  ///
  /// Two references are considered equal if they have:
  /// - The same parent OID string
  /// - The same parent concept code
  /// - The same entry concept code
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Reference) return false;

    return parentOidString == (other as Reference).parentOidString &&
        parentConceptCode == other.parentConceptCode &&
        entryConceptCode == other.entryConceptCode;
  }

  /// Computes the hash code for this reference.
  ///
  /// Uses all fields for hash code calculation to ensure proper distribution.
  @override
  int get hashCode =>
      Object.hash(parentOidString, parentConceptCode, entryConceptCode);

  /// Converts this reference to a JSON map.
  ///
  /// This method implements the [Serializable] interface and provides
  /// a standardized way to serialize references for persistence or
  /// communication purposes.
  @override
  Map<String, dynamic> toJson() {
    return {
      'oid': parentOidString,
      'concept': parentConceptCode,
      'entry': entryConceptCode,
    };
  }

  /// Creates a reference from a JSON map.
  ///
  /// This static method provides a standardized way to deserialize
  /// references from JSON data.
  ///
  /// [json] is the JSON map to deserialize.
  /// Returns a new [Reference] instance.
  static Reference fromJson(Map<String, dynamic> json) {
    return Reference(
      json['oid'] as String,
      json['concept'] as String,
      json['entry'] as String,
    );
  }

  /// Converts this reference to a graph structure.
  ///
  /// Returns a map containing all the reference's properties, which can be
  /// useful for serialization or visualization purposes.
  Map<String, dynamic> toGraph() {
    return {
      'parentOidString': parentOidString,
      'parentConceptCode': parentConceptCode,
      'entryConceptCode': entryConceptCode,
    };
  }

  /// Returns true if this reference can be resolved in the given model entries.
  ///
  /// This method attempts to find the referenced entity in the model entries.
  ///
  /// [modelEntries] is the collection of model entries to search in.
  /// Returns true if the referenced entity exists, false otherwise.
  bool isResolvable(IModelEntries modelEntries) {
    var entity = modelEntries.internalSingle(entryConceptCode, oid);
    return entity != null;
  }

  /// Resolves this reference to the actual entity in the given model entries.
  ///
  /// This method retrieves the referenced entity from the model entries.
  ///
  /// [modelEntries] is the collection of model entries to search in.
  /// Returns the referenced entity if found, null otherwise.
  Entity? resolve(IModelEntries modelEntries) {
    return modelEntries.internalSingle(entryConceptCode, oid) as Entity?;
  }
}


========================================

=== transfer/json.dart ===

part of ednet_core;

Model fromJsonToModel(String json, Domain domain, String modelCode, Map? yaml) {
  Iterable jsonConcepts = [];
  Iterable relations = [];
  Map? schemaExtensions;

  if (yaml == null || yaml.isEmpty) {
    if (json.trim() == '') {
      throw EDNetException('Empty JSON string for Model parse');
    }
    var boardMap = jsonDecode(json);
    jsonConcepts = boardMap["concepts"];
    relations = boardMap["relations"];
    schemaExtensions = boardMap["schemaExtensions"];
  } else {
    jsonConcepts = yaml["concepts"] as Iterable;
    if (yaml.containsKey("relations")) {
      relations = yaml["relations"] as Iterable;
    }
    if (yaml.containsKey("schemaExtensions")) {
      schemaExtensions = yaml["schemaExtensions"] as Map;
    }
  }

  Model model = Model(domain, modelCode);

  // Parse concepts
  for (var jsonConcept in jsonConcepts) {
    String? conceptCode = jsonConcept["name"];
    assert(
      conceptCode != null,
      'Concept code is missing for the jsonConcept. For ${domain.code}.$modelCode',
    );
    bool conceptEntry = jsonConcept["entry"] ?? false;
    bool aggregateRoot = jsonConcept["aggregateRoot"] ?? false;

    Concept concept = Concept(model, conceptCode!);
    concept.entry = conceptEntry;

    // Add aggregateRoot marker if present
    if (aggregateRoot) {
      concept.category = "AggregateRoot";
    }

    // Process attributes
    var items = jsonConcept["attributes"] ?? [];
    for (var item in items) {
      String attributeCode = item["name"];
      if (attributeCode != 'oid' && attributeCode != 'code') {
        Attribute attribute = Attribute(concept, attributeCode);
        String itemCategory = item["category"] ?? '';
        if (itemCategory == 'guid') {
          attribute.guid = true;
        } else if (itemCategory == 'identifier') {
          attribute.identifier = true;
        } else if (itemCategory == 'required') {
          attribute.minc = '1';
        }
        int itemSequence = item["sequence"] as int? ?? 0;
        attribute.sequence = itemSequence;
        String itemInit = item["init"] ?? '';
        if (itemInit.trim() == '') {
          attribute.init = null;
        } else if (itemInit == 'increment') {
          attribute.increment = 1;
          attribute.init = null;
        } else if (itemInit == 'empty') {
          attribute.init = '';
        } else {
          attribute.init = itemInit;
        }
        bool itemEssential = item["essential"] ?? true;
        attribute.essential = itemEssential;
        bool itemSensitive = item["sensitive"] ?? false;
        attribute.sensitive = itemSensitive;
        String itemType = item["type"] ?? 'String';
        AttributeType? type = domain.types.singleWhereCode(itemType);
        if (type != null) {
          attribute.type = type;
        } else {
          attribute.type = domain.getType('String');
        }
      }
    }

    // Process commands
    processCommands(jsonConcept, concept);

    // Process events
    processEvents(jsonConcept, concept);

    // Process policies
    processPolicies(jsonConcept, concept);
  }

  // Process relations
  for (var relation in relations) {
    String from = relation["from"];
    String to = relation["to"];

    Concept? concept1 = model.concepts.singleWhereCode(from);
    Concept? concept2 = model.concepts.singleWhereCode(to);
    if (concept1 == null) {
      throw ConceptException(
        'Line concept is missing for the $from jsonConcept. For ${domain.code}.$modelCode',
      );
    }
    if (concept2 == null) {
      throw ConceptException(
        'Line concept is missing for the $to jsonConcept. For ${domain.code}.$modelCode',
      );
    }

    String fromToName = relation["fromToName"];
    String fromToMin = '${relation["fromToMin"]}';
    String fromToMax = '${relation["fromToMax"]}';
    bool fromToId = relation["fromToId"] ?? false;
    String toFromName = relation["toFromName"];
    String toFromMin = '${relation["toFromMin"]}';
    String toFromMax = '${relation["toFromMax"]}';
    bool toFromId = relation["toFromId"] ?? false;
    bool lineInternal = relation["internal"] ?? false;
    String lineCategory = relation["category"] ?? 'rel';

    bool d12Child;
    bool d21Child;
    bool d12Parent;
    bool d21Parent;

    if (fromToMax != '1') {
      d12Child = true;
      if (toFromMax != '1') {
        d21Child = true;
      } else {
        d21Child = false;
      }
    } else if (toFromMax != '1') {
      d12Child = false;
      d21Child = true;
    } else if (fromToMin == '0') {
      d12Child = true;
      d21Child = false;
    } else if (toFromMin == '0') {
      d12Child = false;
      d21Child = true;
    } else {
      d12Child = true;
      d21Child = false;
    }

    d12Parent = !d12Child;
    d21Parent = !d21Child;

    if (d12Child && d21Child) {
      throw Exception('$from -- $to relation has two children.');
    }
    if (d12Parent && d21Parent) {
      throw Exception('$from -- $to relation has two parents.');
    }

    Neighbor neighbor12;
    Neighbor neighbor21;

    if (d12Child && d21Parent) {
      neighbor12 = Child(concept1, concept2, fromToName);
      neighbor21 = Parent(concept2, concept1, toFromName);

      neighbor12.opposite = neighbor21;
      neighbor21.opposite = neighbor12;

      neighbor12.minc = fromToMin;
      neighbor12.maxc = fromToMax;
      neighbor12.identifier = fromToId;

      neighbor21.minc = toFromMin;
      neighbor21.maxc = toFromMax;
      neighbor21.identifier = toFromId;

      neighbor12.internal = lineInternal;
      if (lineCategory == 'inheritance') {
        neighbor12.inheritance = true;
      } else if (lineCategory == 'reflexive') {
        neighbor12.reflexive = true;
      } else if (lineCategory == 'twin') {
        neighbor12.twin = true;
      } else if (lineCategory == 'association') {
        neighbor12.category = 'association';
      }

      neighbor21.internal = lineInternal;
      if (lineCategory == 'inheritance') {
        neighbor21.inheritance = true;
      } else if (lineCategory == 'reflexive') {
        neighbor21.reflexive = true;
      } else if (lineCategory == 'twin') {
        neighbor21.twin = true;
      } else if (lineCategory == 'association') {
        neighbor21.category = 'association';
      }
    } else if (d12Parent && d21Child) {
      neighbor12 = Parent(concept1, concept2, fromToName);
      neighbor21 = Child(concept2, concept1, toFromName);

      neighbor12.opposite = neighbor21;
      neighbor21.opposite = neighbor12;

      neighbor12.minc = fromToMin;
      neighbor12.maxc = fromToMax;
      neighbor12.identifier = fromToId;

      neighbor21.minc = toFromMin;
      neighbor21.maxc = toFromMax;
      neighbor21.identifier = toFromId;

      neighbor12.internal = lineInternal;
      if (lineCategory == 'inheritance') {
        neighbor12.inheritance = true;
      } else if (lineCategory == 'reflexive') {
        neighbor12.reflexive = true;
      } else if (lineCategory == 'twin') {
        neighbor12.twin = true;
      } else if (lineCategory == 'association') {
        neighbor12.category = 'association';
      }

      neighbor21.internal = lineInternal;
      if (lineCategory == 'inheritance') {
        neighbor21.inheritance = true;
      } else if (lineCategory == 'reflexive') {
        neighbor21.reflexive = true;
      } else if (lineCategory == 'twin') {
        neighbor21.twin = true;
      } else if (lineCategory == 'association') {
        neighbor21.category = 'association';
      }
    }
  }

  return model;
}

void processCommands(Map jsonConcept, Concept concept) {
  var commands = jsonConcept["commands"] ?? [];
  for (var command in commands) {
    String commandName = command["name"];
    String description = command["description"] ?? '';
    String successEvent = command["successEvent"] ?? '';
    String failureEvent = command["failureEvent"] ?? '';
    List<String> roles = [];

    if (command.containsKey("roles")) {
      var rolesList = command["roles"] as List;
      roles = rolesList.map((role) => role.toString()).toList();
    }

    // Add command metadata to the concept
    if (!concept.metadata.containsKey('commands')) {
      concept.metadata['commands'] = {};
    }

    concept.metadata['commands'][commandName] = {
      'description': description,
      'successEvent': successEvent,
      'failureEvent': failureEvent,
      'roles': roles,
    };
  }
}

void processEvents(Map jsonConcept, Concept concept) {
  var events = jsonConcept["events"] ?? [];
  for (var event in events) {
    String eventName = event["name"];
    String description = event["description"] ?? '';
    List<String> triggers = [];

    if (event.containsKey("triggers")) {
      var triggersList = event["triggers"] as List;
      triggers = triggersList.map((trigger) => trigger.toString()).toList();
    }

    // Add event metadata to the concept
    if (!concept.metadata.containsKey('events')) {
      concept.metadata['events'] = {};
    }

    concept.metadata['events'][eventName] = {
      'description': description,
      'triggers': triggers,
    };
  }
}

void processPolicies(Map jsonConcept, Concept concept) {
  var policies = jsonConcept["policies"] ?? [];
  for (var policy in policies) {
    String policyName = policy["name"];
    String description = policy["description"] ?? '';
    String expression = policy["expression"] ?? '';
    List<String> eventTriggers = [];
    List<Map<String, String>> actions = [];

    if (policy.containsKey("events")) {
      var eventsList = policy["events"] as List;
      eventTriggers = eventsList.map((event) => event.toString()).toList();
    }

    if (policy.containsKey("actions")) {
      var actionsList = policy["actions"] as List;
      for (var action in actionsList) {
        actions.add({
          'command': action["command"] ?? '',
          'target': action["target"] ?? '',
        });
      }
    }

    // Add policy metadata to the concept
    if (!concept.metadata.containsKey('policies')) {
      concept.metadata['policies'] = {};
    }

    concept.metadata['policies'][policyName] = {
      'description': description,
      'expression': expression,
      'events': eventTriggers,
      'actions': actions,
    };
  }
}


========================================

