part of ednet_core;

/// A class that manages and executes domain policies.
///
/// The [PolicyEngine] class is responsible for:
/// - Managing a collection of domain policies
/// - Determining which policies apply to a given entity
/// - Executing applicable policies in the correct order
/// - Handling event-triggered policies
/// - Managing the policy-command-event cycle
///
/// The engine can be associated with a [DomainSession] to provide context
/// for policy execution and access to domain services.
///
/// Example usage:
/// ```dart
/// final engine = PolicyEngine(session);
///
/// // Add policies
/// engine.addPolicy(PricePolicy());
/// engine.addPolicy(OrderShippedNotificationPolicy());
///
/// // Execute policies for an entity
/// engine.executePolicies(product);
///
/// // Process an event through policies
/// engine.processEvent(orderShippedEvent);
/// ```
class PolicyEngine {
  /// The list of policies managed by this engine.
  final List<Policy> _policies = [];

  /// The domain session associated with this engine.
  /// Provides context and access to domain services.
  final dynamic _session;

  /// Creates a new [PolicyEngine] instance.
  ///
  /// [session] is the domain session to associate with this engine.
  /// If null, the engine will operate without session context.
  PolicyEngine(this._session);

  /// Gets the domain session
  dynamic get session => _session;

  /// Adds a policy to this engine.
  ///
  /// [policy] is the policy to add.
  /// The policy will be evaluated when [executePolicies] is called.
  void addPolicy(Policy policy) {
    _policies.add(policy);
  }

  /// Adds multiple policies to this engine.
  ///
  /// [policies] is the list of policies to add.
  void addPolicies(List<Policy> policies) {
    _policies.addAll(policies);
  }

  /// Remove a policy from this engine.
  ///
  /// [policy] is the policy to remove.
  void removePolicy(Policy policy) {
    _policies.remove(policy);
  }

  /// Gets all policies registered with this engine.
  List<Policy> get policies => List.unmodifiable(_policies);

  /// Gets all policies that apply to the given entity.
  ///
  /// [entity] is the entity to check policies against.
  /// Returns a list of policies that evaluate to true for the entity.
  List<Policy> getApplicablePolicies(Entity entity) {
    return _policies.where((policy) => policy.evaluate(entity)).toList();
  }

  /// Helper method to check if a policy supports event triggering
  bool _isEventTriggeredPolicy(Policy policy) {
    return policy != null &&
        policy is Policy &&
        (policy as dynamic).shouldTriggerOnEvent != null &&
        (policy as dynamic).executeActions != null &&
        (policy as dynamic).generateCommands != null;
  }

  /// Gets all event-triggered policies that apply to the given entity and should
  /// trigger on the specified event.
  ///
  /// [entity] is the entity to check policies against.
  /// [event] is the event to check triggering conditions against.
  /// Returns a list of event-triggered policies that apply.
  List<Policy> getTriggeredPolicies(Entity entity, Event event) {
    return _policies
        .where(
          (policy) =>
              _isEventTriggeredPolicy(policy) &&
              policy.evaluate(entity) &&
              (policy as dynamic).shouldTriggerOnEvent(event),
        )
        .toList();
  }

  /// Executes all applicable policies for the given entity.
  ///
  /// [entity] is the entity to execute policies for.
  /// This method:
  /// 1. Gets all applicable policies using [getApplicablePolicies]
  /// 2. Executes each policy in sequence
  /// 3. Collects commands generated by policies
  /// 4. Returns the list of generated commands
  ///
  /// Returns a list of commands generated by executed policies
  List<dynamic> executePolicies(Entity entity) {
    final List<dynamic> generatedCommands = [];

    final applicablePolicies = getApplicablePolicies(entity);
    for (var policy in applicablePolicies) {
      // Standard policies don't generate commands
      if (!_isEventTriggeredPolicy(policy)) continue;

      // For event-triggered policies, we need an event
      // Here we're creating a synthetic event for demonstration
      final event = Event(
        'PolicyEvaluation',
        'Policy evaluation triggered by direct execution',
        [],
        entity,
      );

      // Skip if policy shouldn't trigger on this synthetic event
      if (!(policy as dynamic).shouldTriggerOnEvent(event)) continue;

      // Execute policy actions
      (policy as dynamic).executeActions(entity, event);

      // Collect commands
      final commands = (policy as dynamic).generateCommands(entity, event);
      generatedCommands.addAll(commands);
    }

    return generatedCommands;
  }

  /// Processes an event through applicable policies and returns generated commands.
  ///
  /// This method:
  /// 1. Finds policies that apply to the entity and should trigger on the event
  /// 2. Executes policy actions
  /// 3. Collects commands generated by policies
  /// 4. Returns the list of generated commands
  ///
  /// [entity] is the entity associated with the event
  /// [event] is the event to process
  ///
  /// Returns a list of commands generated by triggered policies
  List<dynamic> processEvent(Entity entity, Event event) {
    final List<dynamic> generatedCommands = [];

    final triggeredPolicies = getTriggeredPolicies(entity, event);
    for (var policy in triggeredPolicies) {
      if (!_isEventTriggeredPolicy(policy)) continue;

      // Execute policy actions
      (policy as dynamic).executeActions(entity, event);

      // Collect commands
      final commands = (policy as dynamic).generateCommands(entity, event);
      generatedCommands.addAll(commands);
    }

    return generatedCommands;
  }

  /// Executes commands generated by policies.
  ///
  /// This method executes commands on aggregate roots,
  /// resulting in new events that can trigger more policies,
  /// continuing the command-event-policy cycle.
  ///
  /// [commands] is the list of commands to execute
  /// [aggregateRoot] is the aggregate root to execute commands on
  ///
  /// Returns a list of results from command execution
  List<dynamic> executeGeneratedCommands(
    List<dynamic> commands,
    dynamic aggregateRoot,
  ) {
    final List<dynamic> results = [];

    for (var command in commands) {
      // Check if the aggregateRoot has the executeCommand method
      if (aggregateRoot.executeCommand == null) {
        continue;
      }

      final result = aggregateRoot.executeCommand(command);
      results.add(result);

      // If command succeeded, process events it generated
      if (result.isSuccess == true &&
          aggregateRoot.pendingEvents != null &&
          aggregateRoot.pendingEvents.isNotEmpty) {
        for (var event in aggregateRoot.pendingEvents) {
          // Process event through policies, potentially generating more commands
          final newCommands = processEvent(aggregateRoot, event);

          // Recursively execute those commands if there are any
          if (newCommands.isNotEmpty) {
            executeGeneratedCommands(newCommands, aggregateRoot);
          }
        }

        // Mark events as processed if method exists
        if (aggregateRoot.markEventsAsProcessed != null) {
          aggregateRoot.markEventsAsProcessed();
        }
      }
    }

    return results;
  }
}
