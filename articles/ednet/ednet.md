Roadmap for Transforming EDNet CMS into a Direct Democracy Platform

Introduction

EDNet.dev (Explicit Democracy Network) provides a Dart/Flutter-based ecosystem for domain-driven content management ￼. It combines EDNet Core - a meta-framework for defining rich domain models in Dart - with EDNet CMS, a headless content management system that emphasizes low-code configuration and UI scaffolding ￼ ￼. The current stack empowers developers to model complex data domains via YAML or code and generate Flutter applications with minimal boilerplate ￼ ￼. The EDNet toolkit was conceived with “democracy in design” principles in mind ￼, yet evolving it into a global digital direct democracy platform will require extending its feature set and architecture. This document presents a comprehensive technical analysis of the EDNet ecosystem and a detailed roadmap to transform EDNet CMS into a foundational platform for direct democracy. It compares EDNet’s current capabilities with the requirements of a full-fledged civic CMS - including voting, deliberation, petitioning, proposal workflows, hierarchical governance, and multi-tenancy - and then recommends architectural additions, modular reorganization, and implementation phases to achieve this vision.

EDNet Ecosystem Architecture Overview

EDNet Core is the backbone of the system. It provides an idiomatic framework for domain-driven design (DDD) and Event Storming in Dart ￼. Developers define Domains containing one or more Models, which in turn encapsulate Concepts (Entities, Value Objects) with Attributes and Relationships. EDNet Core abstracts away boilerplate by offering base classes for Entities and typed collections, repository patterns, and constraint hooks ￼. For example, a Domain might contain models like “User” or “Proposal”, each managing its entities, and a Core Repository holds multiple domains for an application ￼. EDNet Core emphasizes a no-code/low-code approach: domain models can be specified in a structured YAML/JSON DSL, which allows non-programmers to contribute ￼. These definitions feed into EDNet Code Generation, which transforms domain specs into Dart code for model classes, strongly-typed repositories, event handlers, and basic UI scaffolds ￼. This design enables rapid iteration - update the YAML, regenerate, and the system’s semantic backbone is updated without hand-writing boilerplate.

EDNet CMS builds on EDNet Core to provide higher-level content management and integration into Flutter apps ￼. It treats “content as king”, modeling content structures in an extensible, recursive way ￼. EDNet CMS’s philosophy is to orchestrate content in a user-centric manner, mapping how users interact with content across contexts ￼. In practice, EDNet CMS merges the domain modeling power of EDNet Core with features needed for a CMS, including dynamic content definitions, runtime editing, and headless access. It includes a powerful interpreter application, EDNet One, which serves as a domain model navigator and editor ￼. EDNet One is a Flutter app (located in the monorepo’s apps/one) that lets developers and domain experts visualize the domain’s structure and data in real time. It provides a master-detail UI to drill down from domains to models to individual entities ￼. Impressively, EDNet One supports in-vivo domain model editing - you can modify the domain schema on the fly through the app’s UI, and see changes reflected immediately ￼. This facilitates collaborative modeling and rapid prototyping. EDNet One also showcases integrations that hint at EDNet’s extensibility: for example, it can enrich data via DBpedia semantic lookups (SPARQL) and even leverage generative AI to suggest model or UI improvements ￼. These features are not directly related to democracy workflows, but they underscore the flexible, extensible nature of the platform.

Monorepo and Modules: The EDNet project is organized as a monorepo (ednet-dev/cms) containing multiple Dart packages for modularity ￼. Key packages include:
 • ednet_core (packages/core): The core modeling framework (discussed above).
 • ednet_cms (packages/cms): The CMS orchestration layer binding core models to Flutter UI and content management features.
 • ednet_content (packages/content): Likely houses default content domain implementations or content-specific utilities (for example, handling of rich text, media types, etc.). The EDNet roadmap explicitly lists plans to support images, video, audio, and complex text content in upcoming versions ￼ ￼.
 • ednet_core_types (packages/types): Common data types or example domain definitions using EDNet Core (possibly including generic models or semantic types).
 • ednet_code_generation (packages/code_generation): The build-runner generators that convert .ednet.yaml specs into Dart code ￼.
 • ednet_one_interpreter and ednet_event_storming: Tools for interpreting models at runtime and capturing event storming diagrams (these hint at visual modeling and design capabilities).

All these packages interoperate closely. The monorepo approach ensures a single source of truth and tight integration between modeling, content, and UI layers ￼. EDNet’s design principles include raising the abstraction (model-first), being user-centric, and “Democracy in Design” - stressing transparency and adaptability in the software architecture ￼.

Storage and Headless Operation: As a Flutter-native stack, EDNet currently runs primarily on the client side (mobile, web, desktop). Data persistence in present demos is file or browser-local. For example, the ednet_core_tasks example app uses a local JSON stored in window.localStorage to save and load the model state ￼ ￼. EDNet Core provides JSON serialization of the model (entire domain or individual model entries) for persistence ￼. However, no dedicated server or database backend is yet integrated in the open-source release - EDNet is effectively a headless CMS library meant to be embedded in Flutter apps, and it’s up to developers to connect it to a backend if needed. There is also not yet an out-of-the-box networking or synchronization mechanism for multiple users. These are important gaps to address for a multi-user democracy platform (discussed below). The roadmap acknowledges this: future milestones include “Authorization and Principals” for user management ￼ and “Scalability” targets like APIs, Docker/Kubernetes deployment, and robust logging ￼ to support server-side and large-scale use.

Current Features Summary: In summary, EDNet’s existing features that we can leverage for a democracy platform include:
 • Flexible Domain Modeling: The ability to define custom concepts (e.g., proposals, votes, users) as first-class entities with relationships and constraints ￼ ￼. This is critical for modeling complex civic processes.
 • Low-Code Definitions: Use of YAML/JSON to define models ￼, enabling domain experts to describe governance structures (like a legislation model, direct democracy model) without writing Dart code. (Notably, early EDNet CMS versions even included example contexts named “authentication”, “direct_democracy”, and “legislation” as proof-of-concept domain models ￼.)
 • Code Generation and UI Scaffolding: Automatic generation of Dart classes, repositories, and basic UI forms from the model ￼. This drastically reduces development effort when adding new modules (e.g., if we add a “Voting” model, EDNet can generate starting point classes and maybe basic screens to list and edit votes).
 • Runtime Model Interpretation: EDNet One allows us to load and interact with models at runtime, which could be extended for administrative interfaces or for configuring workflows on the fly. It also demonstrates a plug-in style architecture (e.g., integrating external data via SPARQL, AI) showing that EDNet can be extended with new functionality without modifying the core ￼.
 • Planned User Auth and Roles: Although not implemented yet, EDNet’s roadmap v0.6.0 includes introducing users, roles, and permissions ￼. This indicates the architecture will soon account for principal authentication, which we can build upon for roles like citizens, moderators, administrators, etc.
 • Planned Plugin System: Roadmap v0.10.0 targets a plugin architecture for extensibility ￼. This is crucial for a long-term sustainable platform - it would allow third-party or community-developed modules (for example, a specific voting method or a new deliberation tool) to integrate cleanly without forking the core.
 • Semantic UI Generation: The EDNet Semantics package auto-generates Flutter widgets for standard data types based on the domain model ￼, and EDNet Design System integrates with Figma to produce consistent UI components ￼. This means the platform can provide default forms and UIs for content management (for example, automatically generating a form for submitting a proposal or an interface for browsing proposals) which developers can then customize. Users get a working UI out-of-the-box for new domain entities.

Leveraging these capabilities, we can avoid reinventing the wheel for the core modeling and content editing aspects. However, several mission-critical features are missing or underdeveloped for a full direct democracy platform. We will now examine these gaps.

Direct Democracy Platform Requirements vs EDNet Features

A global digital direct democracy system must support a broad set of features and non-functional requirements. Below we outline the universal requirements in this domain and assess EDNet’s current support:
 • Proposals & Petitioning: At the heart of direct democracy are proposals - ideas or drafts submitted by citizens. Often there’s an initial petition phase where a proposal must gather a certain number of supporters (signatures) to advance. EDNet does not have a built-in concept of a proposal or petition, but it can certainly model them as Entities (e.g., a Proposal class with fields like title, description, author, etc., and maybe a collection of Endorsement or signatures). The logic of thresholds and status changes (from proposal to official ballot) would have to be implemented as business rules or generated code (possibly using EDNet’s event hooks or a custom controller). In the current EDNet CMS, such workflow logic isn’t pre-built - it focuses on content CRUD and modeling, not on conditional state transitions. Recommendation: Use EDNet’s modeling to define a Proposal domain with states (Draft, In Petition, In Voting, Closed, etc.), and add an engine to evaluate petition counts and trigger state transitions. This could be done via a new “Workflow” module that listens to events (e.g., each time a signature is added, if count > threshold, advance state). Without such a module, developers would manually write code or use the generated model’s events to handle it.
 • Voting System: A democracy platform must allow users to vote on proposals (or elections, polls) and securely tally results. EDNet currently has no voting mechanism - no concept of a ballot, vote casting, or result calculation. One could model a Vote entity (with perhaps attributes like choice, timestamp, voter id, etc.), but implementing a proper voting system involves more than just storing votes:
 • Ensuring one person, one vote (ties into user identity and eligibility verification).
 • Possibly supporting secret ballots (so votes are private, requiring cryptographic techniques or at least restricting data visibility).
 • Handling different voting methods (yes/no, multiple choice, ranked choice, etc.).
 • Tallying and publishing results in a trustworthy manner.
EDNet’s infrastructure would need to be extended for these. Currently, EDNet Core’s repository could store Vote entities, but preventing double voting might require a uniqueness constraint or check in code. There’s no built-in cryptography or anonymization - that would have to be an extension or external integration (perhaps the “Blockchain” item on the roadmap hints at future capability to secure votes via distributed ledger ￼). Recommendation: Introduce a Voting Module in the architecture:
 • Define models like Ballot (linking to a Proposal or issue), VoteOption (possible choices), and VoteRecord (linking a user to their choice).
 • Implement vote casting logic either in a backend service or via EDNet event handlers that mark a user as voted and store the vote.
 • For secrecy, consider storing votes in an anonymized way (e.g., hashing voter IDs, or using a separate service to tally).
 • This module should also handle result computation once voting ends.
The EDNet plugin system could allow plugging in alternative vote counting algorithms or verification mechanisms in the future. For initial implementation, a simple majority vote with open votes might suffice, but the design should allow later enhancements (like Helios-style crypto voting, or integration with a blockchain for auditability in a “Phase 4/5” scenario).
 • Deliberation & Debate: Before and during voting, citizens need to deliberate - discuss proposals, debate options, ask questions. This typically requires forum or commenting functionality attached to each proposal ￼. EDNet CMS does not natively provide forums or comments (no social or discussion features exist yet). However, one could model a Comment entity linked to Proposal, with fields for author, text, timestamp. The challenge is implementing a threaded discussion UI and notification system to alert users to new comments or replies. EDNet’s UI scaffolds can generate simple list/detail views for comments, but for a truly user-friendly deliberation feature, custom UI work is needed (e.g., nested comments, markdown support, moderation tools). Recommendation: Develop a Discussion Module that provides:
 • A DiscussionThread or Comment model (perhaps hierarchical or with parent-child relations for threads).
 • UI components for rendering discussions (this might leverage Flutter’s widgets, potentially building on EDNet Semantics for text fields but extended for a rich text editor).
 • Moderation capabilities (like the ability for admins to remove inappropriate content, which implies adding fields like flagged or linking to a moderation queue).
 • Real-time updates (discussed below under real-time collaboration) so that new comments appear for others without a page refresh.
EDNet’s architecture can incorporate this by either treating discussions as just another domain model (leveraging the same persistence and codegen) or by integrating an external discussion system if needed. Given the autonomy requirement, an in-house solution is preferred. In essence, EDNet should evolve from a pure CMS to also include elements of a social platform (because democratic deliberation is a social process).
 • Proposal Lifecycle & Workflow: In a full-featured platform, proposals go through a lifecycle - e.g., Draft -> Petition (gathering support) -> Voting -> Result -> Implementation (or archived). Additionally, there might be review stages (some proposals may require validation by moderators or legal review). These processes amount to a state machine or workflow for each proposal. Right now, EDNet has no explicit workflow engine. It does have the concept of domain events and could allow us to write code that transitions states, but those transitions and rules are not declaratively modeled. We would likely represent the state as an attribute on the Proposal entity (or separate status entities), and then enforce transitions via code. This is workable but not ideal for flexibility. Recommendation: Introduce a general Workflow/Process Engine component:
 • This could be as simple as a set of classes enumerating allowed states and transitions for key entities (like Proposal), with methods to advance state if conditions are met.
 • More powerfully, it could be a workflow definition DSL (perhaps also YAML-based) that allows administrators to configure processes (for example, to customize how a petition becomes a referendum, or to add an intermediate “expert review” step).
 • Initially, focus on the direct democracy use case: implement the standard lifecycle (petition threshold -> vote -> decide -> done) in code. Ensure EDNet’s event system or generated code can trigger logic on state changes (e.g., when a proposal enters “Voting” state, automatically create a Ballot and notify eligible voters).
 • Later, this could evolve into a pluggable workflow module where new processes (participatory budgeting, law drafting, etc.) can be added.
By capturing the proposal lifecycle within the platform, we ensure that governance rules (like quorum requirements or time windows for voting) are enforced consistently, not left to manual intervention.
 • Governance Workflows & Complex Processes: Beyond simple proposals, a direct democracy platform may support specialized processes:
 • Participatory Budgeting: citizens propose and vote on budget allocations (involves proposals with cost attributes and an overall budget cap) ￼.
 • Collaborative Drafting of Laws: multiple users co-edit a document (law text) and iteratively refine it ￼.
 • Delegation (Liquid Democracy): users optionally delegate their vote to someone on certain topics.
These features represent more complex or distinct workflows. EDNet doesn’t specifically cater to these yet, but its flexible modeling means we can represent them (e.g., a BudgetProposal entity with a cost field, or a delegation model linking users). The bigger challenge is real-time collaboration for law drafting and ensuring consistency. Collaborative drafting might require an operational transform or CRDT approach to let multiple users edit a text concurrently - far outside EDNet’s current capabilities. Such an advanced feature could be deferred to a later phase, leveraging external libraries or services if needed. Recommendation: Plan these as extensions in later phases (phase 3+):
 • Implement participatory budgeting as a specialization of proposals (maybe a flag or subtype of Proposal with cost, and a budget allocation workflow). The system can summate costs of approved items against a budget limit.
 • Explore a document collaboration service for co-editing (perhaps integrating something like Markdown or Quill editors with a backend sync). This might be a candidate for a plugin rather than core feature, due to its complexity.
 • Consider adding a Delegation model: e.g., a mapping of User -> Representative for a topic area, and adjust vote counting to incorporate delegated votes. This again could be a later addition once the basic voting is in place.
 • Organizational Hierarchies & Jurisdictions: The platform must represent different levels of governance - from a building council or local community up to national or international bodies. Each level may have its own proposals and votes, and users belong to one or multiple jurisdictions. EDNet’s domain modeling can naturally represent hierarchical relationships (for instance, an Organization entity with a parent-child self-relation to form a tree, or separate entity types for City, State, Country with containment relationships). However, multilevel jurisdiction logic means:
 • Users have permissions scoped to certain jurisdictions (e.g., a city resident can vote on city issues but not in another city).
 • Proposals are associated with a scope (an organization or geographic unit).
 • Possibly, some proposals cascade upward (e.g., a petition in a city that calls for action at the national level).
Currently, EDNet has none of this structure built-in. We will need to design a schema for jurisdictions and membership. Recommendation: Establish an Organization/Jurisdiction Module:
 • Define entities for organizational units (could be generic OrgUnit with a type or a hierarchy of classes like Building, District, City, etc., depending on how explicit we want it).
 • Link Users to the smallest unit they belong to (and possibly allow multiple memberships for those who are in several communities).
 • Ensure that every Proposal is linked to a jurisdiction (or defaults to a base level). The hierarchy can be used to filter content (so users see relevant proposals) and enforce voting eligibility.
 • Implement logic so that certain proposals might require multi-level approval (for example, a constitutional amendment might need both citizen vote and legislative approval - a complex case that might be encoded as two linked proposals in different domains).
EDNet’s multi-domain capability could be used here: one could conceive each jurisdiction as a separate domain in EDNet Core, each with the same model schema but different data sets. The CoreRepository can hold multiple domains, so in theory, one could load a “CityX Domain” and “CityY Domain” concurrently, isolating their data. However, managing potentially hundreds or thousands of domains (for each city, etc.) might not be efficient. A simpler approach is to have one domain and include the jurisdiction as part of the data model (as an attribute or foreign key on content). This is a key design choice for multi-tenancy which we discuss below.
 • Multi-Tenancy and Data Isolation: Global direct democracy implies many communities or units using the platform. We need the ability to either host multiple tenants on one deployment or at least cleanly segregate data between jurisdictions. EDNet CMS is not inherently multi-tenant as of now - it’s more geared to powering one integrated app. But to support, say, several cities each running their own democratic processes on the same server (and potentially even sharing some overarching processes at higher levels), we require multitenancy. Considerations:
 • Isolation: One tenant’s data (proposals, votes, users) should not be accessible to others, except by design (like a higher-level admin or if a proposal crosses jurisdictions).
 • Configurability: Each tenant might want to configure certain settings (e.g., petition threshold numbers, or UI branding).
In EDNet’s context, we could implement multi-tenancy in two ways:
 1. Multiple Domain Instances: Use EDNet Core’s ability to have multiple domains in the repository. Each tenant (e.g., each city) could be a separate Domain object with the same Models (Proposal, Vote, etc.). The core code would treat them separately, and EDNet One could list multiple domains. This approach aligns with EDNet’s structure (since Domain is meant to encapsulate a bounded context), but we must ensure that the number of domains can scale and that cross-domain queries (like “show all proposals I can vote on across domains I belong to”) are handled. Also, code generation might produce classes per domain which are identical in structure - not DRY, but perhaps manageable via generics.
 2. Single Domain with Tenant IDs: Add a field like tenantId or jurisdictionId to relevant entities and design all queries/collections to filter by that. This is more like how a typical web app handles multi-tenancy in a single database (e.g., using a tenant column). It simplifies code (one set of classes) but puts the onus on every query to enforce isolation. EDNet’s repository could be extended or wrapped to automatically partition data by tenant when performing operations.
Recommendation: Initially, implement a simpler form of multi-tenancy by including a Jurisdiction field on content and filtering by it, since that can be achieved with minimal changes (just treat jurisdiction as another attribute constraint). In parallel, design the system such that if we later decide to spin off separate instances or domains per tenant, it’s not a huge refactor (perhaps by using a common interface so that whether data comes from one domain or multiple is abstracted). Also, incorporate a tenant/organization management UI for superadmins to add new communities, set their configurations, etc. Data isolation must be verified in all APIs and queries (this becomes a security concern as well - ensure one tenant cannot fetch another’s data).
 • User Management and Roles: Any multi-user platform requires robust user authentication, profile management, and role-based access control (RBAC). EDNet’s current state has no user management (though an “authentication” context was mentioned in early plans ￼, it’s not implemented). The roadmap’s Authorization and Principals milestone (0.6.0) will introduce “users, roles, and permissions” ￼, which is exactly what we need:
 • We’ll need a User entity (with fields for identity info, possibly verification status, etc.).
 • A system for authentication (likely username/password or federated login, but since we aim for autonomy from third-parties, an internal authentication system or integration with open standards like OAuth2 self-hosted server can be used).
 • Roles and permissions: define roles such as Citizen, Moderator, Administrator, Guest, etc. EDNet will need to enforce permissions in the UI and possibly at the data layer (for example, only Moderators can remove a comment, only Admins can configure a new organization, only Citizens of a jurisdiction can vote in it, etc.). This could be done via a permission matrix or by attaching allowed actions to roles in each context.
 • Possibly group membership: linking users to organizations/jurisdictions as noted.
Recommendation: Make the Authentication & RBAC module one of the first priorities (Phase 1). Implement a user login system (Dart can handle authentication; on web it might use cookies/jwt, on mobile store tokens securely). Integrate this with the Flutter app (for client-side) and any backend (for verification). Use EDNet’s modeling to represent roles and link them to users and possibly to domain actions. For instance, if EDNet is extended to a server, the server API endpoints will check the user’s role before allowing certain operations (like creating a proposal or casting a vote). On the client side, EDNet One (or a new app) can hide or show admin functionalities based on the logged-in user’s role. Because EDNet is Flutter-based, we might also integrate with Flutter’s navigation to guard routes by role. Ensuring a secure auth mechanism (password hashing, etc.) is beyond EDNet’s current scope but must be added (likely by using an existing Dart package or writing a simple auth service).
 • Real-Time Collaboration and Updates: Democracy is dynamic - as people cast votes or add comments, others should see these updates promptly. Real-time features include:
 • Live results as votes come in (or at least at the close of polls).
 • Instant notification of new proposals or comments to interested users.
 • Potentially, live collaborative editing (as discussed for drafting).
EDNet’s Flutter apps currently do not include a real-time backend or push mechanism. Flutter can use WebSockets, Firebase, or other streaming solutions, but to remain autonomous from third parties, we’d likely implement a WebSocket server or use a protocol like MQTT or an open-source real-time database. Since EDNet is written in Dart, one idea is to run a Dart server (using dart:io WebSocket or a framework like Aqueduct/Shelf) that the Flutter app can connect to for updates. Alternatively, if we choose a simpler approach, periodic polling could retrieve updates (less efficient but easier initially). Recommendation: Plan for a Real-Time Communication Service as part of the architecture:
 • In early phases, implement a basic notification system: e.g., after a user votes or comments, update a last-modified timestamp on the proposal so clients can poll and see changes.
 • By Phase 3, introduce WebSocket channels (perhaps using a package like web_socket_channel or socket.io-equivalent in Dart) to push events: e.g., “comment added on Proposal #123” or “Proposal #123 status changed to Voting”.
 • Utilize EDNet’s domain events on the server side to broadcast changes. If EDNet’s models are used on the server, when Proposal.status changes or a new VoteRecord is added, an event can trigger a message to all subscribers of that domain or proposal.
 • Also consider presence and conflict resolution for collaboration (if two admins try to edit the proposal text simultaneously). We might implement a locking mechanism (only one editor at a time) initially to avoid overwrites, then evolve to finer collaboration tools later.
 • This real-time layer will improve the user experience dramatically, making the platform feel responsive and alive, which is important for engagement.
 • Scalability and Performance: A global platform may have to handle millions of users and records, so scalability is vital. EDNet being Flutter-centric suggests a client-heavy approach, but for large scale, a robust backend is needed for centralized data storage, coordination, and heavy computations (like aggregating vote counts across many votes). The roadmap’s later milestones (0.13.0 “Scalability” ￼) indicate plans for Dockerization, Kubernetes, and CI/CD, implying EDNet CMS will evolve to be deployable on servers and scalable infrastructure. Our roadmap should incorporate:
 • Persistent Database: Instead of (or in addition to) the in-memory + JSON storage, integrate an ACID-compliant database (SQL or NoSQL). For example, a PostgreSQL database for structured data (users, proposals, votes) or a document DB if we prefer schema flexibility. Dart can connect to Postgres via packages, or use an ORM like aqueduct or postgres library. Alternatively, use an embedded database like SQLite for smaller deployments. The key is to move beyond local storage to a multi-user database.
 • Server-side Application: Implement a Dart server that uses EDNet Core models to handle requests (essentially turning EDNet into a true headless CMS with a network API). This server can expose REST or GraphQL endpoints for the front-end Flutter app or any other clients. A GraphQL API would fit well because the domain model can translate to a schema, and clients can query exactly the data needed (for instance, fetch all proposals in my city with their current vote counts).
 • Horizontal scaling: The architecture should allow running multiple server instances behind a load balancer. That means making sure the system is stateless or uses centralized state (database, or caching layer) for coordination. If we use WebSockets for real-time, we might need a message broker (like Redis Pub/Sub) to broadcast messages between server instances. These are advanced considerations likely for Phase 4.
 • Caching and Search: As data grows, searching proposals by keyword or filtering by categories becomes important. We might integrate a search engine (maybe Elasticsearch or an open-source alternative) to index proposal texts and comments. This can be added as a side-service that syncs with the database. Caching layers (like in-memory caches for frequent reads, or using CDN for static content) could also be considered, though at the Flutter app level, a lot of state might be cached locally anyway.
 • Testing at scale: We will need to test the system’s performance with large numbers of concurrent users and large datasets to identify bottlenecks (whether in the Dart code, database, or network).
 • Security & Privacy: Autonomy from third-party services doesn’t eliminate security needs - in fact, it heightens them because we cannot offload security to external providers. The platform must ensure:
 • Data Privacy: All user data and votes must be stored securely. Use encryption where appropriate (for example, password hashing for auth, and potentially end-to-end encryption for votes if secrecy is required).
 • Secure Communications: Use TLS for client-server communication. If we run Flutter web, ensure it’s served over HTTPS. WebSockets should be WSS.
 • Authentication security: Prevent common vulnerabilities (injection, XSS if any webviews, etc.). EDNet being strongly typed helps avoid some injection issues, but if we allow user-generated content (comments, proposals), we need to sanitize or limit formatting to prevent script injection in a web context.
 • Audit Trails: For transparency and trust, keep logs of important actions (proposal created, vote tallied) which can be audited. Possibly even expose these logs to the public or at least to overseers to ensure the process integrity (this ties into “visibility and transparency” in the EDNet roadmap ￼).
 • Resilience against attacks: Large democracy platforms can be targets of DDoS or malicious actors (like spamming proposals or fraudulent votes). We should plan for rate limiting, spam detection (captcha or other means for signup and proposal submission), and maybe peer review of content to flag abuse.
 • Blockchain option: In the future, leveraging blockchain for certain aspects (like vote verification) could enhance security and decentralization. EDNet’s roadmap (0.14.0) mentions investigating blockchain for content management ￼. While not a near-term requirement, we keep this in mind: the architecture should be open to integrating a blockchain module, perhaps for an opt-in transparent vote ledger. This could ensure full autonomy and trust (no single server controlling all votes), at the cost of complexity and performance. For now, we plan a traditional secure DB approach, but design modularity to allow plugging in a distributed ledger or cryptographic verification component later.
 • Internationalization & Localization: A global platform will be used by people of many languages. EDNet’s content is user-generated mostly, but the UI should support multiple languages. Flutter has i18n capabilities; we should ensure all interface strings can be translated. Additionally, supporting content translations (e.g., a proposal written in English that someone translates to Spanish within the platform) might be a desired feature for global deliberation. EDNet doesn’t specifically cover this, but we can use the data model to allow multiple text fields per language or separate “Translation” entities linked to a proposal. This is more of a feature addition than architecture, but important for inclusivity.
 • Accessibility: Since EDNet’s roadmap emphasizes accessible UI and content (for differently-abled users) in early milestones ￼ ￼, we should continue that focus. Ensure the Flutter app meets a11y guidelines (screen reader compatibility, high-contrast modes, etc.), especially since civic tech must be accessible to all citizens.

To summarize the gap analysis: EDNet provides an excellent foundation for modeling data and generating a Flutter-based CMS, but it lacks nearly all of the domain-specific features for direct democracy out-of-the-box. Platforms like CONSUL or DemocracyOS had to implement debate forums, proposal tracking, voting mechanisms, etc., to fulfill their mission ￼ ￼. We will need to build those atop EDNet. Fortunately, EDNet’s architecture is extensible and was envisioned as a generic “domain model of direct democracy” toolkit ￼, which means we can align our extensions with the existing style (i.e., create new domain models for the new features, use EDNet’s upcoming plugin system to keep them modular, and possibly contribute back to EDNet so it becomes a reference implementation for civic tech).

In the next sections, we propose concrete additions and architectural changes to implement the above capabilities, an ideal modular architecture breaking the system into logical components, and phased priorities for development.

Architectural Enhancements and Module Additions

To evolve EDNet CMS into a direct democracy platform, we recommend the following key additions and modifications to its architecture:
 • Introduce a Backend Service Layer: Currently, EDNet primarily runs in the client (Flutter) environment. We should create a headless CMS server component (written in Dart for coherence) that will host the central data and business logic. This backend will use EDNet Core for the data model and enforce rules (like vote validation, permissions) server-side. It will expose an API (likely REST/JSON to start, and GraphQL for flexibility). The Flutter front-end (EDNet One or a new app) will communicate with this server to load and modify data. This is a shift from EDNet’s current offline, single-user orientation to a client-server architecture, but it’s crucial for multi-user scenarios, consistency, and security. The EDNet Core being platform-agnostic Dart makes this feasible ￼ ￼. The server can reuse the same generated model classes (since Dart can run on the server VM) and even the same validation logic, ensuring parity between front-end and back-end understanding of the domain. If needed, EDNet’s repository can be extended to use a database adapter on the server (for example, override the repository’s storage to read/write to an SQL database instead of in-memory JSON). This change also sets the stage for scalability via cloud infrastructure.
 • Persistent Database Integration: As part of the backend, integrate an open-source database. A relational database (PostgreSQL or MariaDB) is recommended for structured data with relations (users, roles, proposals, votes). We can design the schema to mirror EDNet’s domain models. EDNet Code Generation might be extended to produce SQL table definitions or at least we can manually maintain a migration script. Alternatively, we could use a NoSQL store (MongoDB, for instance) to store JSON representations of models - EDNet can already serialize entire model instances to JSON ￼, which could directly go into a document store. However, querying and aggregating (like counting votes, or filtering proposals by status) is easier with a relational model. The database adds complexity (deployment, migrations) but is essential for reliability and multi-session data. All critical data (accounts, proposals, votes, comments) should reside in the DB; the Flutter clients become stateless UI on top of it. Ensure that the database choice doesn’t violate the “no third-party” autonomy - using an open-source DB is fine as it can be self-hosted. For small communities or development, a local embedded DB (SQLite via sqflite in Dart) could be used; for global scale, a dedicated DB server cluster is needed. The architecture should allow swapping the storage backend (perhaps through an abstract repository interface) to accommodate different deployments.
 • User Authentication Module: Implement a user auth module as a priority. We can integrate a package for authentication or build a simple JWT-based system. Likely steps: create a login API (and corresponding UI screens for login/register), secure password storage (using a strong hashing algorithm), and session management (e.g., JWT tokens stored in app). Because Flutter can target web, mobile, etc., we might use OAuth2 flows for web (with the Dart server acting as OAuth provider). But given the autonomy requirement, it may be simplest to have the Flutter app talk to the EDNet backend for login, and the backend issues a token that the app uses for subsequent requests. Also support password reset flows, email verification (if emails are collected - which implies needing an email server integration, though that could be optional). The user model should include fields like username, hashed password, email, etc., and possibly flags for verification. The roles can be an attribute or a separate relationship (user->roles table). EDNet’s forthcoming implementation might give us a head start here, but we should not wait on it. By making auth central, we also allow future integration of single sign-on if needed (for instance, if a government identity provider is available, or to let users use their own OpenID Connect servers in a decentralized fashion).
 • Role-Based Access Control (RBAC): Once users and roles are in place, incorporate permission checks across the app:
 • UI-level: Hide or disable functions the user shouldn’t use (e.g., only show “Delete Proposal” button to an admin). Flutter’s reactive nature makes it easy to conditionally display widgets based on a user’s role stored in app state.
 • API-level: Double enforce on the server - each API endpoint should verify the user’s role or ownership. For example, a user can only vote if they are authenticated and belong to the proposal’s jurisdiction; only a moderator can delete a comment, etc. We should define a permissions matrix for each operation and encode it in middleware on the server.
 • Data-level: If we allow offline or local usage (e.g., EDNet One running without a server for modeling), enforcement is lighter. But in the multi-user case, ensure the server never allows forbidden data changes (even if a malicious client tried). This might involve adding fields like ownerId on proposals to check if editing is by the owner, etc.
 • Provide a way to manage roles: an admin interface where an admin can grant someone moderator privileges in a given community, etc. This could be a simple screen listing users with toggles for roles.
 • Direct Democracy Domain Models: Leverage EDNet’s modeling to create the specific domain constructs:
 • Proposal Model: Include attributes like title, description (possibly rich text), status, creation date, author (link to User), target jurisdiction, category or tags, etc. It may also have relationships like a list of attached files or links (if people attach documents in proposals). Generate this via EDNet’s YAML for consistency.
 • Petition/Endorsement Model: Could be as simple as a list of User IDs (or references) on a Proposal who support it. But to allow tracking and maybe comments with support, a separate Endorsement entity (with proposalId, userId, maybe a statement of support) can be used. The count of endorsements determines progression.
 • Vote Model: As discussed, define Ballot (the thing to vote on, which might be essentially the Proposal once it enters voting phase) and VoteRecord (with voter ref, choice, etc.). If secret ballot is required, we might not store the voter reference directly with the vote - instead perhaps mark in a separate table that “user X has voted” without linking to which choice, to prevent double voting but not reveal their choice. For now, an open vote (or at least an internal record) is acceptable; later encryption could be added.
 • Comment/Discussion Model: A Comment entity with parent (for threads) or a Thread entity grouping them. Keep fields for content, author, timestamp, and maybe a reference if it’s replying to another comment. Also a flag if a comment is hidden/deleted by moderation (so we don’t lose data but stop showing it).
 • Notification Model (optional): For internal tracking of notifications (like an inbox of notifications per user), we could have an entity, but we might handle notifications externally via push, so maybe not needed as a stored entity.
 • Organization/Jurisdiction Model: As described, either a hierarchical Org structure or just a simple table of communities. Given the global scope, a tree of jurisdictions is likely: e.g., World contains Countries, which contain States, which contain Cities, etc. We might pre-populate this tree from known data or allow dynamic creation. A simpler approach is to treat any community unit as a generic Organization with a parent pointer and a type (type could be “city”, “country”, “organization”, etc.). Then the UI can present them accordingly. Users would have a membership relation to these Org units. In EDNet YAML, this might be a Organization concept with a self-referential relation (parent) and a UserMembership concept linking user and org with a role (like “member” or “admin of that org”).
By formally modeling these as EDNet concepts, we let EDNet Code Generation produce initial classes and perhaps some repository code. We must then implement custom logic (likely by extending the generated classes or using partial classes if EDNet supports it) for things like: when a Proposal status changes to Voting, create associated Ballot and set a voting deadline; or when an Endorsement is added, check threshold. EDNet might generate event stubs that we can fill in, or we may weave this logic into the server controller.
 • Workflow Engine / State Management: We touched on it but to reiterate in architecture terms: implement a State Machine utility or use an existing one (there are state machine libraries in Dart). For each major entity (Proposal, perhaps also something like Petition if separate), define an enum of states and allowed transitions. The engine should allow triggers:
 • Time-based triggers (e.g., voting phase lasts 2 weeks then closes automatically).
 • Event-based (e.g., reaching X endorsements triggers transition).
 • Manual triggers (admin forces a move, or maybe a successful vote moves a proposal into a “Approved” state automatically).
We can incorporate this by having an asynchronous job scheduler on the backend (for time triggers) and event listeners for others. Since Dart on the server can use Timer or scheduling packages, we can schedule a task when a voting phase starts to close it at deadline. For endorsement count, either check on each addition or periodically evaluate. The state transitions themselves can be methods that update the Proposal.status and emit events/notifications.
 • Extensibility via Plugins: When adding all these modules, we should keep the architecture modular. That means each major feature (auth, proposals, voting, discussion, etc.) should ideally live in its own Dart library or at least be loosely coupled. EDNet’s plugin system (once available) can help: for example, the “Voting” module might be a plugin that attaches to EDNet CMS, adding new model definitions and UI components for ballots. The benefits of a plugin approach:
 • Contributors can develop new features in isolation.
 • Unneeded features can be disabled to keep an installation lightweight. (For instance, a community might want petitions and discussions but decide to use an external voting service - they could disable the internal voting module).
 • Upgrades to one module don’t tightly affect others if interfaces are respected.
Concretely, since our development will likely precede EDNet’s full plugin infrastructure, we can simulate it by designing each module as a separate Dart package in the monorepo (e.g., packages/voting, packages/forum, packages/auth) that depend on core and maybe CMS. The main app then pulls these together. Later, when EDNet implements dynamic plugin loading, these can be refactored to true plugins. Also, define clear extension points in EDNet CMS code where plugins can hook in (for example, a registry for new content types or a callback list for when new domain events occur). This way, adding say a “BlockchainAudit” plugin later is straightforward - it just registers to listen to VoteRecord creation events and writes to a blockchain, without altering core logic.
 • Headless API (GraphQL/REST): As part of the backend, choose an API approach. A GraphQL API aligns well with EDNet’s domain-centric design, allowing clients to query the data graph (proposals, with their comments and votes, etc.) in flexible ways. We could use a Dart GraphQL server library and auto-generate schema from the models. However, GraphQL might be overkill initially and add complexity. A simpler REST/JSON API with well-defined endpoints (e.g., GET /proposals, POST /votes, etc.) is easier to implement and test early on. Possibly do both: maybe implement core reads via GraphQL and actions via mutations or REST endpoints. The API should be documented for open-source contributors and also to allow other front-ends (not just Flutter) to interact. Because EDNet’s strength is Flutter, we expect the primary client to be Flutter (web app or mobile app), but having a headless API means you could also integrate with other systems (for example, an official government site could pull data from the platform via API). Ensuring the API design is stateless and RESTful will help with caching and scalability.
 • Client Application(s): We have EDNet One as a developer tool. For end-user facing functionality, we might create a new Flutter app (or repurpose EDNet One with different modes). Perhaps call it EDNet Civic or similar - an app tailored to citizen users: it would have screens for browsing proposals by jurisdiction, discussing them, voting, etc., with a more polished UI/UX for the general public. EDNet One’s interface is more for exploring data and might not be intuitive for ordinary citizens. So, plan to build a dedicated UI (in Flutter) for participants. This can reuse EDNet CMS under the hood (for content management) but will present it differently. Flutter’s design flexibility plus EDNet’s design system (the Figma integration, etc.) can be utilized to create an accessible, attractive interface (this addresses usability which is key for public adoption). Meanwhile, EDNet One can be repurposed as an admin console where admins or developers configure the domain (like adding new fields or new content types on the fly), manage the system (moderate content, etc.), and visualize data. The existence of these two apps (citizen portal and admin tool) is similar to how many CMS have a front-end site and a back-end admin UI.
 • Logging and Analytics: Incorporate comprehensive logging on the server - every significant action (login attempts, proposal submissions, votes) should be logged (with appropriate privacy for sensitive data). These logs can feed into analytics to measure engagement (how many proposals submitted, turnout in votes, etc.). For transparency, some aggregated analytics might be shared publicly (like turnout percentage per vote, number of proposals this month, etc.). EDNet’s roadmap item 0.11.0 “Visibility and Transparency” hints at adding analytics ￼, which aligns with this. We can plan an Analytics module that tracks metrics and possibly provides dashboards. For example, integrate an open-source analytics tool or just output JSON stats periodically that could be visualized.
 • Testing and Quality: Ensure each new module has thorough unit and integration tests. EDNet Core itself likely has tests for modeling; we must test things like: does the vote counting logic correctly handle edge cases? Are unauthorized actions properly blocked? Does the state machine prevent invalid transitions? Given the critical nature of voting systems, simulation tests with various scenarios should be automated. Also, user acceptance testing for the UI, since we target potentially non-technical users, to ensure the design is understandable.

By implementing the above enhancements, we effectively transform EDNet from a generic CMS toolkit into a modular civic platform. The architecture will consist of clearly defined layers: a data/model layer (EDNet Core + DB), a service layer (workflow, rules, auth), and a presentation layer (Flutter apps, potentially web widgets). We maintain EDNet’s principle of model-driven architecture - every new feature is first a data model with relationships, and then we generate or write logic around it. This keeps the design consistent and easier to manage as it grows.

Below is an outline of the ideal modular architecture incorporating these changes:

Proposed Modular Architecture

The evolved platform can be thought of as a collection of modules, each responsible for specific functionality, all built around the EDNet Core foundation. Here is an ideal breakdown:
 • EDNet Core (Domain Engine) - Existing: Defines the fundamental patterns (Domain, Model, Entity, Repository) ￼. Unmodified at core, but extended with new domain definitions for our use case. Provides serialization, in-memory management, and the substrate on which other modules build.
 • EDNet Code Generation - Existing: Still used to generate code from domain specs (including our new Proposal, Vote, etc. models). Might be extended to also generate API boilerplate or database schema helpers for those models.
 • Auth & Identity Module - New: Manages User accounts and authentication. Contains:
 • User model (perhaps in ednet_auth package).
 • Services for login/logout, password hashing, token issuance.
 • Role definitions and assignment functions. Possibly a sub-entity for Role or just attributes on User.
 • (If needed, integration hooks for external identity verification, e.g., government ID verification, but that can be plugin territory.)
 • This module would likely run on the server side and also provide UI components (login screen) on the client side.
 • Organization & Multitenancy Module - New: Handles jurisdictions and organizational hierarchy.
 • Organization (or Jurisdiction) entity and maybe Membership entity linking User to Org with a role (for local admins etc.).
 • Functions to add/edit organizations, define parent-child relations.
 • Likely mostly backend logic plus some admin UI to manage (e.g., a tree view of communities).
 • Influences the rest of the system by scoping data queries using organization context.
 • Proposal & Petition Module - New: Implements the core democratic content type.
 • Proposal entity and related operations.
 • Endorsement or PetitionSignature entity if separate.
 • Business logic for submitting proposals (e.g., maybe limit how many active proposals a single user can submit at once to prevent spam, etc.).
 • Ties into the workflow engine (below) for status changes.
 • UI: forms to create proposals, list views filtered by jurisdiction or category, detail view showing content and current support status.
 • Voting Module - New: Enables voting processes.
 • Ballot concept (maybe not stored if identical to proposal, but could be used for things like elections or multiple-choice polls which are not exactly proposals).
 • VoteRecord entity representing a vote.
 • Logic to open/close voting, tally votes.
 • If needed, sub-components for different methods (the default can be simple majority vote; others like ranked choice could be plugins in future).
 • This module also would include the vote casting UI - e.g., a screen with the proposal info and choices, and a button to cast vote (with confirmation).
 • After voting, it could show real-time results if appropriate (or hide until closed if that’s a rule).
 • Discussion/Comment Module - New: Facilitates deliberation.
 • Comment entity (with self-relation for threads or a separate Thread grouping).
 • Functions for posting, editing (maybe allow editing own comment within a time window?), deleting (or flagging).
 • Moderation tools (could be integrated here or in a separate Moderation module).
 • UI components: comment thread view, input boxes, etc. This could integrate with Flutter’s widget tree easily and use state management to update when new comments arrive (via real-time events).
 • Workflow & Notification Engine - New: Overarches proposals and voting for process management.
 • Not necessarily exposed as a separate package to users, but internally a service that modules like Proposal and Voting use.
 • Could utilize EDNet’s EventStorming concepts - perhaps define certain domain events (e.g., ProposalSubmitted, ThresholdReached, VoteStarted, VoteEnded) and then have handlers (somewhat analogous to event sourcing or domain events in DDD) that react to these events. EDNet Core likely can emit events when repository changes occur, which we can hook into ￼.
 • The workflow engine can schedule tasks (like end of voting) and send out notifications (e.g., notify author when their proposal reaches threshold, notify all users in a jurisdiction when a new vote starts - though the latter might be more of a subscription system).
 • The Notification part can simply be: compile relevant events and either email them or show them in the app (e.g., push notifications on mobile, or an in-app notification center). Initially, even an email system (using an SMTP server or integration) might be desirable for critical alerts (but that edges towards third-party - unless we include an email server; however, using open-source email server is still autonomous if self-hosted).
 • If realtime WebSocket is implemented, notifications can just be a type of message the server pushes to the client (the client then maybe displays a pop-up or updates a notification badge).
 • Moderation & Admin Module - New: Provides oversight functions.
 • Tools for moderators/admins to manage content: remove or hide inappropriate proposals/comments, ban users who violate terms, etc. This module ensures the system isn’t abused, which is crucial in global platforms.
 • It might include a Report entity for users to flag content, and an interface for moderators to review reports.
 • Also may include system admin functions like backing up data, managing configurations for an instance, etc.
 • UI likely integrated into EDNet One (the admin interface).
 • API/Integration Module - New: Handles external interfacing.
 • GraphQL/REST controllers that map HTTP requests to EDNet operations.
 • Could also include integration points like webhooks or data export (for example, publishing results data for others to consume).
 • Ensures API security (checking auth tokens, preventing abuse with rate limiting perhaps).
 • Might incorporate an open data API to allow transparency (e.g., an endpoint to fetch all proposals and their outcomes in machine-readable form for civic tech researchers).
 • Frontend Apps:
 • Citizen App (Flutter web + mobile): Presents the above modules to end users in a cohesive UI. Likely includes navigation by jurisdiction (choose your city or auto-select if profile set), browsing proposals, casting votes, and participating in discussions. Needs to be intuitive and performant.
 • Admin App (could be EDNet One evolved or a separate admin panel): Used by administrators and moderators to configure and supervise. This could even be locked down to desktop usage if certain features (like model editing) aren’t needed on mobile.
 • Both apps would share a lot of underlying libraries (the modules above), just different UX layer.
 • Core EDNet CMS - Modified: The existing EDNet CMS package would itself be adjusted to accommodate these modules:
 • It will incorporate the plugin architecture to register new models from modules.
 • It might provide base classes or services that modules extend (for example, a base “Content” class for proposals to inherit common properties, or a common “Service” class for all API handlers).
 • EDNet CMS also currently has features like integration with external knowledge graphs and AI ￼; these can be optional but potentially useful (imagine AI summarizing a lengthy proposal or suggesting similar past proposals - a nice-to-have feature that could improve usability). We can keep these features in the architecture as optional add-ons that enhance the user experience but are not critical path.

This modular layout ensures separation of concerns. Each piece can be developed, tested, and scaled relatively independently. For instance, if the discussion feature becomes too heavy in traffic, we could scale the discussion service separately or optimize it without affecting the voting component. With clear APIs between modules, we can even replace parts (for example, swap out the internal comment system with integration to an existing forum software if desired by a community, or use an external identity provider instead of built-in auth).

Moreover, contributors can work on different modules in parallel: UI/UX designers can focus on the front-end, security experts on the auth module, policy experts might help define the workflow rules, etc. The EDNet domain model acts as the common language between them (ubiquitous language in DDD terms).

The ideal architecture would allow a deployment to pick and choose modules. For a minimal use case, one could run just the proposals, voting, auth, and basic discussion modules. For a fuller experience, all modules run together. The plugin system can enforce dependencies (e.g., Voting module might require Auth module).

Finally, extensibility is built in: for example, if a new form of civic engagement emerges (say, citizen juries or a new voting algorithm), it can be introduced as an additional module without disturbing the rest. Likewise, if integration with government systems (like automatically turning an approved proposal into a draft legislation in a legislative tracking system) is needed, it can be added via the integration module or a new plugin.

With the architecture laid out, we turn to the incremental implementation plan, which prioritizes these components to deliver a working platform in stages.

Implementation Phases and Milestones

Building this platform is a significant effort. We propose breaking it into phased milestones, each delivering part of the functionality in a logical order, so that at the end of each phase we have a usable (if limited) system. This also aligns with building confidence and gathering community feedback early. Below are the priority phases:

Phase 1: Establish the Foundation (Core + Auth + Basic CMS)
Goal: Get the fundamentals in place so multiple users can log in and basic content can be created/persisted.
 • User Management: Implement the user model, registration/login flows, and role system. This includes a simple login UI and server-side auth checks. Initially, have at least two roles: Admin (for system admins) and User (normal participant). Password-based auth is fine to start.
 • Backend Infrastructure: Set up the project as a client-server app. Create a Dart server application that uses EDNet Core. Connect a database (choose a lightweight DB for now, even a JSON file or SQLite for initial testing). Implement a few REST endpoints (e.g., /api/login, /api/logout, /api/ping to test auth).
 • Content Modeling in EDNet: Using EDNet’s YAML DSL, define an initial version of the Proposal model (with minimal fields) and perhaps an Organization model if we decide to include jurisdictions early. Generate code and ensure the server and client can both use it. For now, we might not enforce org membership - all users see all proposals - unless jurisdictions are trivial to include.
 • Basic Proposal CRUD: Create a simple UI in Flutter to create a proposal (just title & description) and list all proposals. This is the simplest “CMS” functionality - essentially EDNet CMS’s default behavior. Tie it into the backend: e.g., on submit, send to API to save in DB, then refresh list. At this stage, no complex workflow, just ensure that the path from front-end form to storing data and retrieving it works, and that only logged-in users can create.
 • Testing & Hardening Phase 1: Write tests for user registration, login, and proposal creation. Ensure unauthorized requests are rejected. This phase delivers a working skeleton: users can register and propose ideas. There’s no voting or discussion yet, but it’s a multi-user environment.

Outcome of Phase 1: A basic multi-user EDNet CMS instance where people can submit and view proposals. It demonstrates the integrated stack (Flutter app + Dart server + DB). This sets the stage for adding democracy-specific features.

Phase 2: Core Democracy Features (Proposals Workflow and Voting)
Goal: Introduce petition thresholds and voting capability - making the platform actually useful for decision-making.
 • Proposal Lifecycle & Petition: Expand the Proposal model to include status and support count. Implement the logic for endorsements: allow users to “support” a proposal. If threshold logic is simple (e.g., a fixed number or percentage of users), implement that check. When threshold is reached, mark proposal as “Accepted for Voting”. This could trigger an event. For UI, add a “Support this proposal” button on proposals that are in petition phase. Show support count and maybe a progress bar towards the threshold.
 • Voting Mechanism: Introduce the Vote entity/model. When a proposal enters voting status, create a Ballot (or reuse proposal id) and allow users to cast votes. Implement a vote submission API (ensuring one vote per user per proposal). If anonymity is not yet addressed, just record the user link; we can decide on secrecy later, perhaps by not exposing the votes publicly. Also include a voting deadline mechanism: each vote could automatically close after X days (configurable). Implement tallying - when closed, compute results (for yes/no, count yes vs no; if other type, tally accordingly). Mark the proposal as Approved or Rejected based on result (for example, if majority yes). The rules can be simple majority for now.
 • User Interface for Voting: On proposals in voting phase, show voting options (for a yes/no, two buttons; for multi-choice, list choices). After voting, show a confirmation and possibly the interim result (if we choose to display running totals). On closed votes, display the outcome (e.g., “Approved: 120 Yes vs 45 No”).
 • Roles & Permissions in Voting: Ensure only eligible users can vote: if we have jurisdictions in place now, check the user is part of the proposal’s org; also ensure user hasn’t already voted (the API can track that). If delegation (proxy voting) were in scope now (likely not yet), skip it for later.
 • Begin Real-time Basics: Implement a simple way for clients to refresh data after actions. Perhaps long-poll or auto-refresh the proposal detail page to show new support or vote counts. If comfortable, start a WebSocket service now: e.g., notify all clients when a proposal changes status or when a vote is closed. This could be as small as broadcasting a message “proposal X updated” and clients decide to refetch. Real-time full collaboration can wait, but it’s good to lay down a channel now for updates.
 • Persistence and Consistency: At this stage, refine the database structure for proposals and votes. Use transactions if needed (especially in counting votes to avoid race conditions). We might add indexes (like on proposal status or org) to query efficiently. Also implement data migration if the models changed since phase 1.
 • Testing Phase 2: Simulate the lifecycle: create proposal, have multiple users support it (maybe write a test that directly adds endorsements up to threshold), ensure it moves to voting, then simulate votes and closing. Test edge cases: exactly threshold, no one voting, all users vote, etc. Also test permissions: user cannot vote twice, cannot support twice, cannot vote on a proposal in petition phase, etc.

Outcome of Phase 2: The platform can handle proposals from inception through voting and provide a decision. This is the essence of direct democracy functionality. Citizens can raise an issue and collectively vote on it. The system will be rudimentary (e.g., one big pool of users or basic threshold rules), but functional. This is a major milestone that could even be pilot-tested in a small community setting.

Phase 3: Deliberation and Collaboration Tools
Goal: Add the social dimension - discussion forums for proposals, notifications, and improve real-time interactivity.
 • Discussion Module Implementation: Add the Comment model and link it to proposals. Build a thread UI below each proposal detail where users can post comments, reply to others, etc. Include basic features like Markdown support or at least paragraph breaks, since discussions can be long. Also add the ability to edit one’s own comment (within certain time) and delete (maybe just mark deleted for moderation transparency).
 • Moderation Tools: Along with comments, introduce a way for moderators to remove inappropriate content. Possibly allow users to flag comments/proposals. For now, a simple approach: give Admin role a “Delete” button on any comment or proposal. Implement the backend logic to either delete or better, mark as removed (to keep record). Ensure that the UI hides removed content for normal users (maybe show “[Removed by moderator]”). Logging these actions is important for accountability.
 • Notification System: Enable notifications for key events:
 • When someone replies to your comment, you get a notification.
 • When your proposal advances to voting or gets approved/rejected, you get notified.
 • Possibly when new proposals in your jurisdiction are submitted, notify all users in that jurisdiction (this must be configurable to avoid spamming; could be opt-in subscriptions).
 • Notification delivery: If the user is online, use the real-time channel to push a notification event that the app displays (e.g., in-app banner or update a notification list). Also consider sending email notifications for important events (especially votes starting/ending). Since autonomy is key, use an in-house solution (like an SMTP server under the community’s control) for email; or skip email if we want to avoid external entirely, relying on push notifications and the fact that many will use a mobile app that can receive them. Flutter can use Firebase Cloud Messaging for push, but that’s a third-party service; an alternative is to use something like WebPush for web or just rely on users opening the app. For now, in-app notifications plus maybe email is fine.
 • Provide a simple UI for notifications: an icon with unread count, and a list of recent notifications that can be clicked to navigate to the relevant item.
 • Real-Time Collaboration: Expand the use of WebSockets (or chosen real-time tech). The comments section should live-update: if User A posts a comment, User B currently viewing should see it appear. Implement this by broadcasting new comments to all clients subscribed to that proposal’s channel. Similarly, for voting we might live-update the vote count (though that can be sensitive; perhaps only show final result, depending on rules).
 • If pursuing collaborative drafting (perhaps for law texts), now would be the time to experiment with a simple approach: maybe allow multiple editors but lock the proposal description while one is editing. True simultaneous editing (like Google Docs) would be very complex to integrate, so likely skip that unless time permits for a simplified version.
 • Ensure the real-time system is robust: handle reconnects, and security (only authorized users join certain channels, e.g., not let someone subscribe to a jurisdiction’s private admin channel). Use authentication tokens to validate WebSocket connections as well.
 • Jurisdiction Filtering and Org Management: If not done in earlier phases, implement now so the discussion and notifications can respect organizational boundaries:
 • Add interface for users to join/select their jurisdiction (maybe at registration they choose from a list or it’s assigned by an admin). Ensure proposals and notifications are filtered to those belonging to the same org.
 • If the platform is being used by multiple communities, perhaps add a top-level selection UI (e.g., a user can switch context between communities they are part of). This is a multi-tenant UI consideration.
 • Provide admin UI to create new organizations (unless we pre-populate them).
 • Improve UX & Design: With many features now present, take time to refine the user experience:
 • Make sure the app navigation is clear (e.g., tabs or sections for Proposals, Notifications, maybe separate lists for ongoing votes vs new proposals).
 • Possibly implement search or filtering (e.g., filter proposals by status or keyword).
 • Ensure mobile usability if targeting phones (Flutter can adapt UI for smaller screens).
 • Add instructions/tooltips for new users so they understand how to participate (this is content, but important).
 • If using EDNet design system, incorporate consistent styling, theming (dark mode maybe).
 • Performance Tuning: Phase 3 introduces heavier concurrent usage (multiple commenters, lots of notifications). Profile the app and server: optimize any slow queries (maybe add indexes for comments by proposal, etc.), increase WebSocket server capacity, etc. Possibly introduce caching for expensive computations (like if computing some stats repeatedly).
 • Testing Phase 3: Test the discussion thoroughly (posting, editing, deletion flows), including permission (non-authenticated cannot post, etc.). Test notifications: simulate events and see if the right users get notified. If possible, do a usability test with a small group to get feedback on the UI/UX now that core features are present.

Outcome of Phase 3: The platform now supports the full democratic cycle: propose -> discuss -> petition -> vote -> outcome, with real-time engagement and basic moderation. It’s essentially a functional direct democracy platform on par with existing ones like CONSUL in terms of features (proposal forums, voting, etc. ￼). This phase likely completes the key functionality needed for a public launch in a controlled environment.

Phase 4: Scalability, Security, and Refinement
Goal: Prepare the platform for wider deployment, focusing on robustness, scale, and trust.
 • Security Audit and Improvements: Conduct a thorough review of security:
 • Ensure all API endpoints have proper auth checks.
 • Possibly integrate 2-factor authentication for admins or sensitive actions.
 • Encrypt sensitive data at rest (if any, e.g., maybe personal info).
 • Setup monitoring for unusual activities (multiple failed logins could indicate an attack, etc.).
 • Clean up any debug endpoints, enforce strong password rules, etc.
 • If votes are currently stored with user link, consider adding at least shuffling or separating the identification to make it harder for any admin to snoop on how someone voted (if required by the platform’s principles).
 • Evaluate if the blockchain integration is desirable at this point: maybe pilot a simple use-case like writing finalized vote results to a public blockchain for transparency (with a hash of the results data).
 • Backend Scalability: Move the database from any local/SQLite to a proper server (if not already). Implement read replicas if needed for heavy read load. Use the Docker/Kubernetes scripts to deploy on cloud or servers and test horizontal scaling:
 • Run multiple instances of the Dart server, ensure sticky sessions if using websockets (or use a shared broker for WS messages).
 • Use a load balancer for the API. Test with a high number of concurrent users (simulate with scripts or tools).
 • Implement request rate limiting to prevent abuse or accidental overload (like a user spamming refresh).
 • If certain operations are slow (say computing something on the fly), introduce caching layers (Redis or in-memory cache in each instance with appropriate invalidation).
 • Ensure the system can handle data growth: test with thousands of proposals, comments, and votes to see if UI or API slows down anywhere (optimize queries or paginate results as needed).
 • Analytics and Transparency: Build dashboards or at least data export for key metrics:
 • e.g., number of active users, number of proposals per category, average support per proposal, turnout rates for votes, etc.
 • This not only helps admins manage the system but also builds trust if some of these are public. For instance, showing turnout statistics might encourage more participation.
 • If feasible, provide an open data API endpoint (like /api/stats or even /api/export/proposals.csv) that external watchdogs or researchers can use to analyze the democratic process, promoting transparency.
 • Plugin & Extensibility Framework: By now, EDNet’s planned plugin system (if the project timeline aligns) might be available or close. Integrate our modules with the plugin architecture:
 • Factor out any hard-coded dependencies between modules, and register them via plugin interfaces.
 • For example, if EDNet CMS core can detect and load plugins that provide additional models, use that for our Voting and Discussion models.
 • Document the extension points so others can develop add-ons. Possibly create a couple of example plugins to test: e.g., a “Poll” plugin that allows quick informal polls outside the formal proposal process, or a “Translation” plugin that adds machine translation for proposals.
 • This step ensures the longevity of the project as an extensible platform and not a closed set of features.
 • Polish and UI Enhancements: Take feedback from test users and refine:
 • Perhaps implement additional features that were deferred: e.g., an optional delegation feature (allow a user to designate a proxy; then in vote counting, aggregate accordingly). This could be a plugin or core addition if many users request it.
 • Implementing an initiative timeline view - a visual representation of where each proposal is in the pipeline (like a Kanban style: X proposals collecting support, Y in voting, Z approved) for transparency.
 • Accessibility audit: ensure screen reader works on all interactive elements, add alt texts, etc. Possibly add multi-language support for the UI now if translations available.
 • If not already, integrate the design system thoroughly so that the UI is not only functional but also clean and modern (important for public perception).
 • Documentation and Deployment: Write comprehensive documentation:
 • Developer docs for how the domain models are structured, how to extend or customize (e.g., change the petition threshold globally, or adjust time frames).
 • Ops docs for how to deploy, backup data, restore, update (covering Docker, config files, etc.).
 • User guides for both citizens and administrators explaining how to use the platform (this may live outside code, but important).
 • If aiming to build a community, set up a website or wiki for the project. Possibly an online demo environment (with safe data).
 • Pilot and Feedback: By end of Phase 4, the system should be robust enough for a pilot in a real community or as a global test. Facilitate a pilot, gather feedback and bug reports, then iterate to fix any critical issues or pain points.

Outcome of Phase 4: The platform is production-ready for larger audiences. It can scale and has the necessary safeguards. All primary features for direct democracy are in place and refined. We have also set up the basis for an open-source community to contribute via plugins or improvements.

Phase 5: Advanced Features and Innovation
Goal: Tackle the forward-looking or non-critical features that can further distinguish the platform, time permitting. This phase is more about nice-to-have enhancements and future-proofing:
 • Blockchain and Verifiability: If not already integrated, implement an experimental module for vote verification. For example, use a public blockchain (or a private one run by the consortium of communities) to post cryptographic commitments of votes or final counts, so that tech-savvy users can audit the integrity independently. Alternatively, implement end-to-end cryptographic voting where each user gets a receipt (encrypted) that they can use to verify their vote is counted, without revealing their choice. This is complex and might involve heavy cryptography - possibly bring in existing libraries or protocols (like Helios or CIVITAS frameworks). This feature can be an opt-in for communities that require high assurance at the cost of complexity.
 • Liquid Democracy (Delegation): If not done earlier, allow users to delegate their vote to another user globally or by topic. Model this as a relation User->User with maybe a topic tag. Then modify the vote counting process to accumulate delegated votes. Provide UI for managing your proxies and for indicating if you vote directly or let your proxy vote. This feature can increase participation by enabling those who don’t have time to follow all issues to still be represented. It adds complexity in understanding results (we should display when votes were cast by proxy), so careful UI design is needed.
 • Participatory Budgeting Module: Introduce a specialized workflow for budget allocation. For example, allow proposals to have a cost field and be marked as budget proposals in a given fiscal period. Let users vote or allocate points among budget proposals up to a limit. Then implement a result calculation that picks top proposals until budget runs out, etc. This could be implemented as a plugin or extension of the voting module (with a different UI - maybe a slider for how to allocate a budget). Many cities use separate modules for participatory budgeting; building it in would expand the platform’s utility.
 • Integration with Government Systems: Provide connectors for things like:
 • Importing official data (e.g., if a city wants to import an official voter registry to automatically verify users - though this touches personal data, which may or may not be in scope).
 • Exporting approved proposals as PDFs or into legislative tracking software for implementation.
 • Single sign-on with government eID systems (some countries have digital ID that could be used to verify real identity, if required for official binding votes).
These are highly dependent on local needs, so they could be offered as optional plugins or documented integration guides rather than core.
 • AI Assistance: EDNet CMS already flirts with AI integration ￼. We could apply AI to help moderate content (detect hate speech in comments automatically), summarize long discussions, or even suggest related proposals to avoid duplication. Another idea: a chatbot to guide new users (answer “How do I submit a proposal?” etc., trained on the documentation). These features should be carefully sandboxed (and open-source AI models used if possible to keep autonomy, although some external API like OpenAI could be optionally used by communities that allow it).
 • Mobile App Optimization: If not already thoroughly tested, finalize native mobile deployment (Android/iOS). Use Flutter’s capabilities to issue local push notifications for events (which might require hooking into platform-specific notification systems, again possibly via Firebase or other methods - an area to reconcile with autonomy, maybe using Node-RED or custom push service).
 • Community and Governance of the Platform: As an open-source direct democracy platform, consider how the development itself can be driven democratically. Possibly set up a governance model for the project where contributors and users can propose changes to the software through the platform itself (eating our own dogfood). This is more of a project management aspect, but it can influence technical decisions like creating meta-proposals in the system or voting on feature priorities. In any case, fostering an open-source community will bring in new use-cases and help adapt the architecture to be more general or flexible. Already EDNet invites community contributions ￼; extending that principle to decision-making would align with the project’s ethos.

Outcome of Phase 5: The platform reaches a mature state with cutting-edge features that differentiate it and potentially set a benchmark for digital democracy tools. At this stage, EDNet CMS would truly embody a “foundational platform for direct democracy” - covering not just basic voting, but a suite of tools for various democratic processes, all within a coherent, extensible architecture.

⸻

Throughout these phases, iterative development and feedback are key. After Phase 2 or 3, one could deploy a beta and gather user feedback (from usability to feature gaps). That feedback should inform subsequent phases, possibly reordering some priorities. For example, if users say delegation is crucial earlier, we might bump it up; or if security concerns are raised, addressing those might come sooner. The roadmap above provides a logical sequence but should remain adaptable.

By following this roadmap, EDNet CMS will expand from a generic CMS into a comprehensive, democratic operating system that empowers communities to participate in governance online. It will embody all universal features of a digital direct democracy platform - from debating proposals to collective decision-making ￼ ￼ - while remaining modular, scalable, and self-sovereign. The end result will be an open-source, Flutter-powered platform capable of supporting local and global direct democracy with minimal reliance on external services, fulfilling the vision of EDNet.dev’s “explicit democracy” mission.

Sources: The design and recommendations above build upon the EDNet.dev project documentation and roadmap, which outline the existing features of EDNet Core and CMS (domain modeling, code generation, content editing) ￼ ￼ and the planned enhancements for user roles, plugins, and scalability ￼ ￼ ￼. The identified gaps and feature requirements draw from known capabilities of civic platforms like Consul and DemocracyOS, which emphasize debate, proposals, and voting in their feature lists ￼ ￼. This roadmap aligns EDNet’s architecture with those requirements, ensuring that features like voting and deliberation are added in an idiomatic way consistent with EDNet’s event-driven, model-centric approach. By incrementally implementing these features and architectural improvements, EDNet CMS can evolve into a robust platform for global digital direct democracy.
